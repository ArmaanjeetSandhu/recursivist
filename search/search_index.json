{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Recursivist","text":"<p>A powerful command-line tool for visualizing directory structures with rich formatting, color-coding, and comprehensive analysis options.</p> Get Started View Examples recursivist-demo ~ bash $ recursivist visualize --sort-by-loc <pre>\ud83d\udcc2 my-project (1262 lines)\n\u251c\u2500\u2500 \ud83d\udcc1 src (1055 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (245 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (157 lines)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests (653 lines)\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py (412 lines)\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py (241 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md (124 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt (18 lines)\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py (65 lines)</pre>"},{"location":"#key-features","title":"\u2728 Key Features","text":"\ud83c\udfa8 Colorful Visualization Each file type is assigned a unique color for easy identification, created deterministically from file extensions for consistent visual mapping. See visualization  \ud83d\udcca File Statistics Display and sort by lines of code, file sizes, or modification times with formatting appropriate to each metric for better project understanding. File statistics  \ud83d\udcc1 Smart Filtering Powerful filtering options combining directory exclusions, extension filtering, glob patterns, regex matching, and gitignore integration for surgical precision. Filtering options  \ud83e\udde9 Gitignore Support Automatically respects your `.gitignore` patterns and similar ignore files to exclude files and directories you don't want to include in the visualization. Using with Git  \ud83d\udd0d Pattern Matching Use glob patterns for simplicity or regular expressions for complex matching needs, with options for both inclusion and exclusion patterns. Pattern matching  \ud83d\udd04 Directory Comparison Compare two directory structures side by side with color-coded highlighting of differences for effective visual differentiation and change analysis. Compare command  \ud83d\udce4 Multiple Export Formats Export to TXT, JSON, HTML, Markdown, and React components with consistent styling across formats for documentation and integration needs. Export formats  \ud83d\udd0e Depth Control Limit directory traversal depth to focus on higher-level structure or specific layers of your project hierarchy for better visualization management. Depth limiting  \ud83d\udcbb Shell Completion Generate and install completion scripts for Bash, Zsh, Fish, and PowerShell to make command entry faster and easier with intelligent suggestions. Shell completion"},{"location":"#quick-install","title":"\ud83d\ude80 Quick Install","text":"<pre><code>pip install recursivist\n</code></pre> <p>Dependencies</p> <p>Recursivist is built with Rich for beautiful terminal output and Typer for an intuitive command interface.</p>"},{"location":"#getting-started","title":"\ud83c\udfc1 Getting Started","text":"\ud83d\udccb Installation Follow our easy installation guide to get up and running in minutes with pip or from source. Installation guide  \ud83d\ude80 Quick Start Jump in with basic commands and examples to visualize, export, and compare directory structures. Quick start guide  <p>Shell Completion</p> <p>Recursivist supports shell completion for easier command entry. See the shell completion guide for instructions.</p>"},{"location":"#next-steps","title":"\ud83d\udcda Next Steps","text":"\ud83d\udccb CLI Reference Complete reference for all commands, options, and arguments available in Recursivist with detailed explanations. View CLI Reference  \ud83d\udd27 Examples Practical examples showing how to use Recursivist effectively for various scenarios and project types. Explore Examples  \ud83d\udd04 Contributing Guidelines for contributing to the project, including development setup, coding standards, and testing procedures. Contribution Guide"},{"location":"#license","title":"\ud83d\udcdc License","text":"This project is licensed under the MIT License."},{"location":"contributing/","title":"Contributing to Recursivist","text":"<p>Thank you for your interest in contributing to Recursivist! This document provides guidelines and instructions for contributing to this project.</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>Getting Started</li> <li>Setting Up Your Development Environment</li> <li>Understanding the Project Structure</li> <li>Development Workflow</li> <li>Creating a Branch</li> <li>Making Changes</li> <li>Testing Your Changes</li> <li>Submitting a Pull Request</li> <li>Coding Standards</li> <li>Code Style</li> <li>Documentation</li> <li>Type Annotations</li> <li>Testing</li> <li>Running Tests</li> <li>Writing Tests</li> <li>Bug Reports and Feature Requests</li> <li>Reporting Bugs</li> <li>Suggesting Features</li> <li>Release Process</li> <li>Community</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>By participating in this project, you agree to abide by our Code of Conduct. Please be respectful, inclusive, and considerate when interacting with other contributors.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li> <p>Fork the repository:</p> </li> <li> <p>Visit the Recursivist repository and click the \"Fork\" button to create your own copy.</p> </li> <li> <p>Clone your fork:</p> </li> </ol> <pre><code>git clone https://github.com/ArmaanjeetSandhu/recursivist.git\ncd recursivist\n</code></pre> <ol> <li>Set up the upstream remote:</li> </ol> <pre><code>git remote add upstream https://github.com/ArmaanjeetSandhu/recursivist.git\n</code></pre> <ol> <li>Create a virtual environment:</li> </ol> <pre><code>python -m venv venv\n\n# Activate the virtual environment\n# On Windows\nvenv\\Scripts\\activate\n# On macOS/Linux\nsource venv/bin/activate\n</code></pre> <ol> <li>Install development dependencies:    <pre><code>pip install -e \".[dev]\"\n</code></pre></li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#creating-a-branch","title":"Creating a Branch","text":"<ol> <li>Make sure your fork is up to date:</li> </ol> <pre><code>git checkout main\ngit pull upstream main\ngit push origin main\n</code></pre> <ol> <li>Create a new branch for your feature or bugfix:    <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/issue-description\n</code></pre></li> </ol>"},{"location":"contributing/#making-changes","title":"Making Changes","text":"<ol> <li> <p>Make your changes to the codebase according to our coding standards.</p> </li> <li> <p>Commit your changes with clear and descriptive commit messages:</p> </li> </ol> <pre><code>git add .\ngit commit -m \"Add feature: description of what you added\"\n</code></pre> <ol> <li>Keep your branch updated with the upstream repository:    <pre><code>git pull upstream main\n</code></pre></li> </ol>"},{"location":"contributing/#testing-your-changes","title":"Testing Your Changes","text":"<ol> <li>Run the tests to make sure your changes don't break existing functionality:</li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Test the CLI to verify it works as expected:    <pre><code>python -m recursivist --help\n</code></pre></li> </ol>"},{"location":"contributing/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<ol> <li>Push your branch to your fork:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li> <p>Create a Pull Request from your fork to the main repository:</p> </li> <li> <p>Go to the Recursivist repository</p> </li> <li>Click \"Pull Requests\" &gt; \"New Pull Request\"</li> <li>Select \"compare across forks\" and choose your fork and branch</li> <li> <p>Click \"Create Pull Request\"</p> </li> <li> <p>Describe your changes in the PR:</p> </li> <li> <p>What problem does it solve?</p> </li> <li>How can it be tested?</li> <li> <p>Any dependencies or breaking changes?</p> </li> <li> <p>Address review feedback if requested by maintainers.</p> </li> </ol>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We follow PEP 8 and use the following tools to maintain code quality:</p> <ul> <li>Black for code formatting:</li> </ul> <pre><code>pip install black\nblack recursivist/\n</code></pre> <ul> <li>Flake8 for linting:</li> </ul> <pre><code>pip install flake8\nflake8 recursivist/\n</code></pre> <ul> <li>isort for import sorting:</li> </ul> <pre><code>pip install isort\nisort recursivist/\n</code></pre> <ul> <li>mypy for type checking:</li> </ul> <pre><code>pip install mypy\nmypy recursivist/\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Write docstrings for all public modules, functions, classes, and methods.</li> <li>Follow the Google docstring style as shown in existing code.</li> </ul> <p>Example docstring:</p> <pre><code>def function(arg1: str, arg2: int) -&gt; bool:\n    \"\"\"A short description of the function.\n\n    A more detailed description explaining the behavior, edge cases, and implementation details if relevant.\n\n    Args:\n        arg1: Description of the first argument\n        arg2: Description of the second argument\n\n    Returns:\n        Description of the return value\n\n    Raises:\n        ValueError: When the input is invalid\n    \"\"\"\n</code></pre>"},{"location":"contributing/#type-annotations","title":"Type Annotations","text":"<p>We use Python type hints for better code quality and IDE support:</p> <pre><code>from typing import Dict, List, Optional, Set\n\ndef process_data(data: Dict[str, List[str]],\n                 options: Optional[Set[str]] = None) -&gt; bool:\n    # Function implementation\n    return True\n</code></pre>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>We use pytest for testing:</p> <pre><code># Run all tests\npytest\n\n# Run with coverage report\npytest --cov=recursivist\n\n# Run tests from a specific file\npytest tests/test_core.py\n</code></pre>"},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Write tests for all new features and bug fixes.</li> <li>Place tests in the <code>tests/</code> directory with a name that matches the module being tested.</li> <li>Follow the test style used in existing tests.</li> </ul> <p>Example test:</p> <pre><code># tests/test_core.py\nfrom recursivist.core import generate_color_for_extension\n\ndef test_generate_color_for_extension():\n    # Given\n    extension = \".py\"\n\n    # When\n    color = generate_color_for_extension(extension)\n\n    # Then\n    assert isinstance(color, str)\n    assert color.startswith(\"#\")\n    assert len(color) == 7\n</code></pre>"},{"location":"contributing/#bug-reports-and-feature-requests","title":"Bug Reports and Feature Requests","text":""},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>Please report bugs by opening an issue on GitHub with the following information:</p> <ul> <li>A clear and descriptive title</li> <li>Steps to reproduce the issue</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Environment details (OS, Python version, etc.)</li> <li>Any relevant logs or screenshots</li> </ul>"},{"location":"contributing/#suggesting-features","title":"Suggesting Features","text":"<p>We welcome feature requests! Please open an issue with:</p> <ul> <li>A clear and descriptive title</li> <li>A detailed description of the proposed feature</li> <li>Any relevant examples or use cases</li> <li>Information about why this feature would be useful</li> </ul>"},{"location":"contributing/#release-process","title":"Release Process","text":"<ol> <li> <p>Version bump:</p> </li> <li> <p>Update version in <code>__init__.py</code> and <code>pyproject.toml</code></p> </li> <li> <p>Update the changelog</p> </li> <li> <p>Create a release commit:</p> </li> </ol> <pre><code>git add .\ngit commit -m \"Release v0.2.0\"\ngit tag v0.2.0\ngit push origin main --tags\n</code></pre> <ol> <li>Build and publish:    <pre><code>python -m build\npython -m twine upload dist/*\n</code></pre></li> </ol>"},{"location":"contributing/#community","title":"Community","text":"<ul> <li>GitHub Discussions: Use this for questions and general discussion.</li> <li>Issues: Bug reports and feature requests.</li> <li>Pull Requests: Submit changes to the codebase.</li> </ul> <p>Thank you for contributing to Recursivist! Your efforts help make this project better for everyone.</p>"},{"location":"advanced/development/","title":"Development Guide","text":"<p>This guide provides information for developers who want to contribute to or extend Recursivist.</p>"},{"location":"advanced/development/#setting-up-development-environment","title":"Setting Up Development Environment","text":""},{"location":"advanced/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7 or higher</li> <li>Git</li> <li>pip (Python package manager)</li> </ul>"},{"location":"advanced/development/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/username/recursivist.git\ncd recursivist\n</code></pre>"},{"location":"advanced/development/#create-a-virtual-environment","title":"Create a Virtual Environment","text":"<pre><code># Create a virtual environment\npython -m venv venv\n\n# Activate the virtual environment\n# On Windows\nvenv\\Scripts\\activate\n# On macOS/Linux\nsource venv/bin/activate\n</code></pre>"},{"location":"advanced/development/#install-development-dependencies","title":"Install Development Dependencies","text":"<pre><code># Install the package in development mode with development dependencies\npip install -e \".[dev]\"\n</code></pre> <p>This installs Recursivist in \"editable\" mode, so your changes to the source code will be reflected immediately without reinstalling.</p>"},{"location":"advanced/development/#project-structure","title":"Project Structure","text":"<p>Recursivist is organized into several key modules:</p> <pre><code>recursivist/\n\u251c\u2500\u2500 __init__.py          # Package initialization, version info\n\u251c\u2500\u2500 cli.py               # Command-line interface (Typer-based)\n\u251c\u2500\u2500 core.py              # Core functionality (directory traversal, tree building)\n\u251c\u2500\u2500 exports.py           # Export functionality (TXT, JSON, HTML, MD, JSX)\n\u251c\u2500\u2500 compare.py           # Comparison functionality (side-by-side diff)\n\u2514\u2500\u2500 jsx_export.py        # React component generation\n</code></pre>"},{"location":"advanced/development/#module-responsibilities","title":"Module Responsibilities","text":"<ul> <li>cli.py: Defines the command-line interface using Typer, handles command-line arguments and option parsing, and invokes core functionality</li> <li>core.py: Implements the core directory traversal, pattern matching, and tree building functionality</li> <li>exports.py: Contains the <code>DirectoryExporter</code> class for exporting directory structures to various formats</li> <li>compare.py: Implements functionality for comparing two directory structures side by side</li> <li>jsx_export.py: Provides specialized functionality for generating React components</li> </ul>"},{"location":"advanced/development/#development-workflow","title":"Development Workflow","text":""},{"location":"advanced/development/#making-changes","title":"Making Changes","text":"<ol> <li>Create a new branch for your feature or bug fix:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li> <p>Make your changes to the codebase.</p> </li> <li> <p>Run the tests to ensure your changes don't break existing functionality:</p> </li> </ol> <pre><code>pytest\n</code></pre> <ol> <li>Add and commit your changes:</li> </ol> <pre><code>git add .\ngit commit -m \"Add your meaningful commit message here\"\n</code></pre> <ol> <li>Push your changes:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li>Create a pull request.</li> </ol>"},{"location":"advanced/development/#code-style","title":"Code Style","text":"<p>Recursivist follows PEP 8 style guidelines. We recommend using the following tools for code formatting and linting:</p> <ul> <li>Black for code formatting:</li> </ul> <pre><code>black recursivist tests\n</code></pre> <ul> <li>Flake8 for code linting:</li> </ul> <pre><code>flake8 recursivist tests\n</code></pre> <ul> <li>MyPy for type checking:   <pre><code>mypy recursivist\n</code></pre></li> </ul>"},{"location":"advanced/development/#adding-a-new-feature","title":"Adding a New Feature","text":""},{"location":"advanced/development/#adding-a-new-command","title":"Adding a New Command","text":"<p>To add a new command to the CLI:</p> <ol> <li>Open <code>cli.py</code></li> <li>Add your new command using the Typer decorator pattern:</li> </ol> <pre><code>@app.command()\ndef your_command(\n    directory: Path = typer.Argument(\n        \".\", help=\"Directory path to process\"\n    ),\n    # Add more parameters as needed\n):\n    \"\"\"\n    Your command description.\n\n    Detailed information about what the command does and how to use it.\n    \"\"\"\n    # Implement your command logic here\n    pass\n</code></pre> <ol> <li>Implement the core functionality in the appropriate module.</li> <li>Add tests for your new command.</li> </ol>"},{"location":"advanced/development/#adding-a-new-export-format","title":"Adding a New Export Format","text":"<p>To add a new export format:</p> <ol> <li>Open <code>exports.py</code></li> <li>Add a new method to the <code>DirectoryExporter</code> class:</li> </ol> <pre><code>def to_your_format(self, output_path: str) -&gt; None:\n    \"\"\"Export directory structure to your format.\n\n    Args:\n        output_path: Path where the export file will be saved\n    \"\"\"\n    # Implement export to your format\n    try:\n        # Your export logic here\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            # Write your formatted output\n            pass\n    except Exception as e:\n        logger.error(f\"Error exporting to YOUR_FORMAT: {e}\")\n        raise\n</code></pre> <ol> <li>Update the format map in the <code>export_structure</code> function in <code>core.py</code>:</li> </ol> <pre><code>format_map = {\n    \"txt\": exporter.to_txt,\n    \"json\": exporter.to_json,\n    \"html\": exporter.to_html,\n    \"md\": exporter.to_markdown,\n    \"jsx\": exporter.to_jsx,\n    \"your_format\": exporter.to_your_format,  # Add your format here\n}\n</code></pre> <ol> <li>Add tests for your new export format.</li> </ol>"},{"location":"advanced/development/#adding-new-file-statistics","title":"Adding New File Statistics","text":"<p>To add a new statistic (beyond LOC, size, and mtime):</p> <ol> <li>Update the <code>get_directory_structure</code> function in <code>core.py</code> to collect your new statistic.</li> <li>Add appropriate parameters to the function signature for enabling/sorting by the new statistic.</li> <li>Update the <code>build_tree</code> function to display the new statistic.</li> <li>Update export formats to include the new statistic.</li> <li>Add CLI options in <code>cli.py</code> to enable the new statistic.</li> </ol>"},{"location":"advanced/development/#testing","title":"Testing","text":"<p>For detailed information about testing, see the Testing Guide.</p>"},{"location":"advanced/development/#basic-testing","title":"Basic Testing","text":"<pre><code># Run all tests\npytest\n\n# Run tests with code coverage\npytest --cov=recursivist --cov-report=html\n\n# Run specific test file\npytest tests/test_core.py\n\n# Run tests matching a pattern\npytest -k \"pattern\"\n</code></pre>"},{"location":"advanced/development/#debugging","title":"Debugging","text":""},{"location":"advanced/development/#verbose-output","title":"Verbose Output","text":"<p>Use the <code>--verbose</code> flag during development to enable detailed logging:</p> <pre><code>recursivist visualize --verbose\n</code></pre> <p>This provides more information about what's happening during execution, which can be helpful for debugging.</p>"},{"location":"advanced/development/#using-a-debugger","title":"Using a Debugger","text":"<p>For complex issues, you can use a debugger:</p> <pre><code>import pdb\npdb.set_trace()  # Add this line at the point where you want to start debugging\n</code></pre> <p>With modern IDEs like VSCode or PyCharm, you can also set breakpoints and use their built-in debuggers.</p>"},{"location":"advanced/development/#documentation","title":"Documentation","text":""},{"location":"advanced/development/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings for all functions, classes, and methods:</p> <pre><code>def function_name(param1: Type1, param2: Type2) -&gt; ReturnType:\n    \"\"\"Short description of the function.\n\n    More detailed description if needed.\n\n    Args:\n        param1: Description of param1\n        param2: Description of param2\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ExceptionType: When and why this exception is raised\n    \"\"\"\n    # Function implementation\n</code></pre>"},{"location":"advanced/development/#command-line-help","title":"Command-Line Help","text":"<p>Update the command-line help text when you add or modify commands or options:</p> <pre><code>@app.command()\ndef your_command(\n    param: str = typer.Option(\n        None, \"--param\", \"-p\", help=\"Clear description of the parameter\"\n    )\n):\n    \"\"\"\n    Clear, concise description of what the command does.\n\n    More detailed explanation with examples:\n\n    Examples:\n        recursivist your_command --param value\n    \"\"\"\n    # Implementation\n</code></pre>"},{"location":"advanced/development/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced/development/#large-directory-structures","title":"Large Directory Structures","text":"<p>When working with large directories:</p> <ol> <li>Use generators and iterators where possible to minimize memory usage.</li> <li>Implement early filtering to reduce the number of files and directories processed.</li> <li>Use progress indicators (like the <code>Progress</code> class from Rich) for long-running operations.</li> <li>Test with large directories to ensure acceptable performance.</li> </ol>"},{"location":"advanced/development/#profiling","title":"Profiling","text":"<p>Use the <code>cProfile</code> module to profile performance:</p> <pre><code>import cProfile\ncProfile.run('your_function_call()', 'profile_results')\n\n# To analyze the results\nimport pstats\np = pstats.Stats('profile_results')\np.sort_stats('cumulative').print_stats(20)\n</code></pre>"},{"location":"advanced/development/#extending-pattern-matching","title":"Extending Pattern Matching","text":"<p>Recursivist currently supports glob patterns (default) and regular expressions. To add a new pattern type:</p> <ol> <li>Update the <code>should_exclude</code> function in <code>core.py</code> to handle the new pattern type.</li> <li>Add a new flag to the command-line arguments in <code>cli.py</code>.</li> <li>Add appropriate documentation for the new pattern type.</li> <li>Add tests specifically for the new pattern functionality.</li> </ol>"},{"location":"advanced/development/#release-process","title":"Release Process","text":""},{"location":"advanced/development/#version-numbering","title":"Version Numbering","text":"<p>Recursivist follows Semantic Versioning (SemVer):</p> <ul> <li>MAJOR version for incompatible API changes</li> <li>MINOR version for backwards-compatible feature additions</li> <li>PATCH version for backwards-compatible bug fixes</li> </ul>"},{"location":"advanced/development/#creating-a-release","title":"Creating a Release","text":"<ol> <li>Update the version in <code>__init__.py</code>.</li> <li>Update the CHANGELOG.md file.</li> <li>Commit the changes:    <pre><code>git add .\ngit commit -m \"Prepare for release x.y.z\"\n</code></pre></li> <li>Create a tag for the release:    <pre><code>git tag -a vx.y.z -m \"Release x.y.z\"\n</code></pre></li> <li>Push the changes and tag:    <pre><code>git push origin main\ngit push origin vx.y.z\n</code></pre></li> <li>Build the package:    <pre><code>python -m build\n</code></pre></li> <li>Upload to PyPI:    <pre><code>twine upload dist/*\n</code></pre></li> </ol>"},{"location":"advanced/development/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"advanced/development/#adding-a-new-command-line-option","title":"Adding a New Command-Line Option","text":"<ol> <li>Add the option to the appropriate command functions in <code>cli.py</code>:</li> </ol> <pre><code>@app.command()\ndef visualize(\n    # Existing options...\n    new_option: bool = typer.Option(\n        False, \"--new-option\", \"-n\", help=\"Description of the new option\"\n    ),\n):\n    # Pass the new option to the core function\n    display_tree(\n        # Existing parameters...\n        new_option=new_option\n    )\n</code></pre> <ol> <li>Update the core function to handle the new option:</li> </ol> <pre><code>def display_tree(\n    # Existing parameters...\n    new_option: bool = False,\n):\n    # Use the new option in your function\n    if new_option:\n        # Do something\n        pass\n</code></pre>"},{"location":"advanced/development/#improving-colorization","title":"Improving Colorization","text":"<p>The file extension colorization is handled by the <code>generate_color_for_extension</code> function in <code>core.py</code>:</p> <pre><code>def generate_color_for_extension(extension: str) -&gt; str:\n    \"\"\"Generate a consistent color for a file extension.\"\"\"\n    # Current implementation uses hash-based approach\n    # You can modify this to use predefined colors for common extensions\n</code></pre> <p>If you want to add predefined colors for common file types:</p> <ol> <li>Create a mapping of extensions to colors:</li> </ol> <pre><code>EXTENSION_COLORS = {\n    \".py\": \"#3776AB\",  # Python blue\n    \".js\": \"#F7DF1E\",  # JavaScript yellow\n    \".html\": \"#E34C26\",  # HTML orange\n    \".css\": \"#264DE4\",  # CSS blue\n    # Add more extensions and colors\n}\n</code></pre> <ol> <li>Update the <code>generate_color_for_extension</code> function to use this mapping:</li> </ol> <pre><code>def generate_color_for_extension(extension: str) -&gt; str:\n    \"\"\"Generate a consistent color for a file extension.\"\"\"\n    extension = extension.lower()\n    if extension in EXTENSION_COLORS:\n        return EXTENSION_COLORS[extension]\n    # Fall back to the hash-based approach for unknown extensions\n    # ...\n</code></pre> <p>This will give common file types consistent, recognizable colors while maintaining the existing behavior for other file types.</p>"},{"location":"advanced/integration/","title":"Integration with Other Tools","text":"<p>Recursivist can be integrated with other tools and workflows to enhance productivity. This guide provides examples and guidance on various integration options.</p>"},{"location":"advanced/integration/#using-with-git-repositories","title":"Using with Git Repositories","text":""},{"location":"advanced/integration/#gitignore-integration","title":"Gitignore Integration","text":"<p>When working with Git repositories, you can use your existing <code>.gitignore</code> file to filter the directory structure:</p> <pre><code>recursivist visualize --ignore-file .gitignore\n</code></pre> <p>This is particularly useful for quickly visualizing the structure of a Git repository without the noise of ignored files.</p>"},{"location":"advanced/integration/#git-hooks","title":"Git Hooks","text":"<p>You can use Recursivist in Git hooks to automatically document your project structure:</p> <pre><code># .git/hooks/pre-commit\n#!/bin/bash\n\n# Update project structure documentation when committing\nif git diff --cached --name-only | grep -q -v \"STRUCTURE.md\"; then\n  echo \"Updating project structure documentation...\"\n\n  # Generate updated structure with LOC statistics\n  recursivist export --format md --prefix \"STRUCTURE\" --sort-by-loc\n\n  # Add to commit if changed\n  git add STRUCTURE.md\nfi\n</code></pre> <p>Make the hook executable:</p> <pre><code>chmod +x .git/hooks/pre-commit\n</code></pre>"},{"location":"advanced/integration/#git-workflow-scripts","title":"Git Workflow Scripts","text":"<p>This script compares two Git branches:</p> <pre><code>#!/bin/bash\n\n# Compare two Git branches\ncurrent_branch=$(git rev-parse --abbrev-ref HEAD)\ncompare_branch=${1:-main}\n\n# Create temporary directories\nmkdir -p .tmp/$current_branch .tmp/$compare_branch\n\n# Extract current branch files\ngit archive --format=tar $current_branch | tar -xf - -C .tmp/$current_branch/\n\n# Extract comparison branch files\ngit archive --format=tar $compare_branch | tar -xf - -C .tmp/$compare_branch/\n\n# Compare the branches with statistics\nrecursivist compare .tmp/$current_branch .tmp/$compare_branch \\\n  --save \\\n  --prefix \"branch-comparison\" \\\n  --sort-by-loc\n\n# Clean up\nrm -rf .tmp\n\necho \"Branch comparison saved to branch-comparison.html\"\n</code></pre>"},{"location":"advanced/integration/#processing-json-exports-with-jq","title":"Processing JSON Exports with jq","text":"<p>The JSON export format works well with command-line data processors like jq. Here are some useful examples:</p>"},{"location":"advanced/integration/#count-files-by-extension","title":"Count Files by Extension","text":"<pre><code># Export structure to JSON with file statistics\nrecursivist export --format json --prefix structure --sort-by-loc\n\n# Count files by extension and sort by count\njq -r '.structure | .. | objects | select(has(\"_files\")) | ._files[] |\n    select(type==\"object\") |\n    (.path | split(\".\") | .[-1]) |\n    ascii_downcase' structure.json | sort | uniq -c | sort -nr\n</code></pre>"},{"location":"advanced/integration/#find-largest-files","title":"Find Largest Files","text":"<pre><code># Export with file size statistics\nrecursivist export --format json --prefix structure --sort-by-size\n\n# Get the 10 largest files\njq -r '.structure | .. | objects | select(has(\"_files\")) | ._files[] |\n    select(type==\"object\" and has(\"size\")) |\n    [.size, .path] | @tsv' structure.json | sort -nr | head -10\n</code></pre>"},{"location":"advanced/integration/#find-files-with-most-lines-of-code","title":"Find Files with Most Lines of Code","text":"<pre><code># Export with LOC statistics\nrecursivist export --format json --prefix structure --sort-by-loc\n\n# Get the 10 files with most lines of code\njq -r '.structure | .. | objects | select(has(\"_files\")) | ._files[] |\n    select(type==\"object\" and has(\"loc\")) |\n    [.loc, .path] | @tsv' structure.json | sort -nr | head -10\n</code></pre>"},{"location":"advanced/integration/#analyze-code-distribution-by-directory","title":"Analyze Code Distribution by Directory","text":"<pre><code># Get lines of code by directory\njq -r '.structure | to_entries[] |\n    select(.value | type == \"object\" and has(\"_loc\")) |\n    [.key, (.value._loc | tostring)] | @tsv' structure.json | sort -k2 -nr\n</code></pre>"},{"location":"advanced/integration/#programmatic-use-with-python","title":"Programmatic Use with Python","text":"<p>You can integrate Recursivist directly into your Python applications:</p>"},{"location":"advanced/integration/#basic-directory-analysis","title":"Basic Directory Analysis","text":"<pre><code>from recursivist.core import get_directory_structure, export_structure\n\n# Get directory structure with statistics\nstructure, extensions = get_directory_structure(\n    \"path/to/directory\",\n    exclude_dirs=[\"node_modules\", \".git\"],\n    exclude_extensions={\".pyc\", \".log\"},\n    sort_by_loc=True,\n    sort_by_size=True\n)\n\n# Export to multiple formats\nexport_structure(structure, \"path/to/directory\", \"md\", \"output.md\", sort_by_loc=True, sort_by_size=True)\nexport_structure(structure, \"path/to/directory\", \"json\", \"output.json\", sort_by_loc=True, sort_by_size=True)\n\n# Calculate statistics\ntotal_loc = structure.get(\"_loc\", 0)\ntotal_size = structure.get(\"_size\", 0)\nprint(f\"Total lines of code: {total_loc}\")\nprint(f\"Total size: {total_size} bytes\")\n</code></pre>"},{"location":"advanced/integration/#custom-file-analysis","title":"Custom File Analysis","text":"<pre><code>from recursivist.core import get_directory_structure\n\ndef analyze_file_types(directory):\n    \"\"\"Analyze the distribution of file types in a directory.\"\"\"\n    structure, extensions = get_directory_structure(\n        directory,\n        exclude_dirs=[\"node_modules\", \".git\"],\n        sort_by_loc=True\n    )\n\n    # Extract all files with their extensions\n    files_by_ext = {}\n\n    def process_directory(dir_struct, path=\"\"):\n        if \"_files\" in dir_struct:\n            for file_item in dir_struct[\"_files\"]:\n                if isinstance(file_item, tuple):\n                    filename = file_item[0]\n                else:\n                    filename = file_item\n\n                ext = filename.split(\".\")[-1] if \".\" in filename else \"no_extension\"\n                loc = file_item[2] if isinstance(file_item, tuple) and len(file_item) &gt; 2 else 0\n\n                if ext not in files_by_ext:\n                    files_by_ext[ext] = {\"count\": 0, \"loc\": 0}\n\n                files_by_ext[ext][\"count\"] += 1\n                files_by_ext[ext][\"loc\"] += loc\n\n        for name, content in dir_struct.items():\n            if isinstance(content, dict) and name not in [\"_files\", \"_max_depth_reached\", \"_loc\", \"_size\", \"_mtime\"]:\n                process_directory(content, f\"{path}/{name}\")\n\n    process_directory(structure)\n\n    # Print results\n    print(f\"File type distribution in {directory}:\")\n    print(\"-\" * 50)\n    print(f\"{'Extension':&lt;12} {'Count':&lt;8} {'Lines of Code':&lt;14} {'Avg LOC/File':&lt;12}\")\n    print(\"-\" * 50)\n\n    for ext, data in sorted(files_by_ext.items(), key=lambda x: x[1][\"count\"], reverse=True):\n        avg_loc = data[\"loc\"] / data[\"count\"] if data[\"count\"] &gt; 0 else 0\n        print(f\"{ext:&lt;12} {data['count']:&lt;8} {data['loc']:&lt;14} {avg_loc:&lt;12.1f}\")\n\n# Usage\nanalyze_file_types(\"path/to/project\")\n</code></pre>"},{"location":"advanced/integration/#web-application-integration","title":"Web Application Integration","text":""},{"location":"advanced/integration/#using-the-react-component-export","title":"Using the React Component Export","text":"<p>Recursivist can export a directory structure as a React component:</p> <pre><code>recursivist export --format jsx --output-dir ./src/components --prefix DirectoryViewer --sort-by-loc\n</code></pre> <p>Then import it into your React application:</p> <pre><code>// src/App.js\nimport React from \"react\";\nimport DirectoryViewer from \"./components/DirectoryViewer\";\n\nfunction App() {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;header className=\"App-header\"&gt;\n        &lt;h1&gt;Project Structure&lt;/h1&gt;\n      &lt;/header&gt;\n      &lt;main&gt;\n        &lt;DirectoryViewer /&gt;\n      &lt;/main&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre> <p>The generated component includes:</p> <ul> <li>Collapsible folder structure</li> <li>Search functionality</li> <li>Breadcrumb navigation</li> <li>Dark/light mode toggle</li> <li>Statistics display when enabled</li> </ul>"},{"location":"advanced/integration/#custom-api-with-flask","title":"Custom API with Flask","text":"<p>You can build a simple API to serve directory structures:</p> <pre><code>from flask import Flask, jsonify, request\nfrom recursivist.core import get_directory_structure\n\napp = Flask(__name__)\n\n@app.route('/api/directory-structure', methods=['GET'])\ndef get_structure():\n    directory = request.args.get('directory', '.')\n    exclude_dirs = request.args.get('exclude_dirs', '').split(',') if request.args.get('exclude_dirs') else []\n    max_depth = int(request.args.get('max_depth', 0))\n\n    try:\n        structure, _ = get_directory_structure(\n            directory,\n            exclude_dirs=exclude_dirs,\n            max_depth=max_depth,\n            sort_by_loc='sort_by_loc' in request.args,\n            sort_by_size='sort_by_size' in request.args,\n            sort_by_mtime='sort_by_mtime' in request.args\n        )\n        return jsonify({\n            'directory': directory,\n            'structure': structure\n        })\n    except Exception as e:\n        return jsonify({\n            'error': str(e)\n        }), 500\n\nif __name__ == '__main__':\n    app.run(debug=True)\n</code></pre>"},{"location":"advanced/integration/#continuous-integration-integration","title":"Continuous Integration Integration","text":"<p>You can incorporate Recursivist into your CI/CD pipelines:</p>"},{"location":"advanced/integration/#github-actions-example","title":"GitHub Actions Example","text":"<pre><code>name: Generate Project Structure Documentation\n\non:\n  push:\n    branches: [main]\n    paths-ignore:\n      - \"docs/structure.md\"\n\njobs:\n  update-structure:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.10\"\n\n      - name: Install Recursivist\n        run: pip install recursivist\n\n      - name: Generate structure documentation\n        run: |\n          mkdir -p docs\n          recursivist export \\\n            --format md \\\n            --exclude \"node_modules .git\" \\\n            --output-dir ./docs \\\n            --prefix \"structure\" \\\n            --sort-by-loc\n\n      - name: Commit and push if changed\n        run: |\n          git config --local user.email \"action@github.com\"\n          git config --local user.name \"GitHub Action\"\n          git add docs/structure.md\n          git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -m \"Update project structure documentation\"\n          git push\n</code></pre>"},{"location":"advanced/integration/#gitlab-ci-example","title":"GitLab CI Example","text":"<pre><code>generate-structure:\n  image: python:3.10-slim\n  script:\n    - pip install recursivist\n    - mkdir -p docs\n    - recursivist export --format md --exclude \"node_modules .git\" --output-dir ./docs --prefix \"structure\" --sort-by-loc\n  artifacts:\n    paths:\n      - docs/structure.md\n</code></pre>"},{"location":"advanced/integration/#documentation-tools-integration","title":"Documentation Tools Integration","text":""},{"location":"advanced/integration/#mkdocs-integration","title":"MkDocs Integration","text":"<ol> <li>Generate a Markdown export:</li> </ol> <pre><code>recursivist export --format md --output-dir ./docs --prefix \"structure\"\n</code></pre> <ol> <li>Include it in your MkDocs navigation:    <pre><code># mkdocs.yml\nnav:\n  - Home: index.md\n  - Project Structure: structure.md\n  # Other pages...\n</code></pre></li> </ol>"},{"location":"advanced/integration/#sphinx-integration","title":"Sphinx Integration","text":"<p>Add this to your Sphinx configuration to include the exported structure:</p> <pre><code># conf.py\nimport os\nimport subprocess\n\ndef setup(app):\n    app.connect('builder-inited', generate_structure_docs)\n    return {'version': '0.1'}\n\ndef generate_structure_docs(app):\n    # Generate project structure documentation\n    subprocess.run([\n        'recursivist', 'export',\n        '--format', 'md',\n        '--exclude', 'node_modules .git _build',\n        '--output-dir', './source',\n        '--prefix', 'structure',\n        '--sort-by-loc'\n    ])\n</code></pre> <p>Then in your RST files:</p> <pre><code>Project Structure\n================\n\n.. include:: structure.md\n   :parser: myst_parser.sphinx_\n</code></pre>"},{"location":"advanced/integration/#shell-script-integration","title":"Shell Script Integration","text":"<p>Recursivist works well with shell scripts for automation:</p>"},{"location":"advanced/integration/#batch-processing-multiple-directories","title":"Batch Processing Multiple Directories","text":"<pre><code>#!/bin/bash\n\n# Process multiple directories\nfor dir in projects/*/; do\n  if [ -d \"$dir\" ]; then\n    project_name=$(basename \"$dir\")\n    echo \"Processing $project_name...\"\n\n    # Export project structure with LOC stats\n    recursivist export \"$dir\" \\\n      --format md \\\n      --output-dir ./reports \\\n      --prefix \"$project_name\" \\\n      --sort-by-loc\n  fi\ndone\n\n# Create an index file\necho \"# Project Reports\" &gt; reports/index.md\necho \"\" &gt;&gt; reports/index.md\necho \"Generated on $(date)\" &gt;&gt; reports/index.md\necho \"\" &gt;&gt; reports/index.md\n\nfor file in reports/*.md; do\n  if [ \"$(basename \"$file\")\" != \"index.md\" ]; then\n    project_name=$(basename \"$file\" .md)\n    echo \"- [$project_name]($project_name.md)\" &gt;&gt; reports/index.md\n  fi\ndone\n\necho \"Processing complete. Reports are in the ./reports directory.\"\n</code></pre>"},{"location":"advanced/integration/#weekly-project-evolution-report","title":"Weekly Project Evolution Report","text":"<pre><code>#!/bin/bash\n\n# Get date for filename\ndate_str=$(date +%Y-%m-%d)\n\n# Create current snapshot\nmkdir -p snapshots/current\nrecursivist export \\\n  --format json \\\n  --exclude \"node_modules .git snapshots\" \\\n  --output-dir ./snapshots/current \\\n  --prefix \"structure\" \\\n  --sort-by-loc \\\n  --sort-by-size\n\n# Compare with last week's snapshot if it exists\nif [ -f \"snapshots/previous/structure.json\" ]; then\n  echo \"Comparing with previous snapshot...\"\n\n  # Create comparison\n  recursivist compare \\\n    snapshots/previous snapshots/current \\\n    --exclude \"node_modules .git\" \\\n    --save \\\n    --output-dir ./reports \\\n    --prefix \"weekly-${date_str}\" \\\n    --sort-by-loc\n\n  echo \"Comparison saved to reports/weekly-${date_str}.html\"\nfi\n\n# Move current to previous for next time\nrm -rf snapshots/previous\nmv snapshots/current snapshots/previous\n</code></pre>"},{"location":"advanced/integration/#using-with-static-analysis-tools","title":"Using with Static Analysis Tools","text":"<p>Combine Recursivist with other static analysis tools for comprehensive project insights:</p> <pre><code>#!/bin/bash\n\n# Create output directory\nmkdir -p analysis\n\n# Generate directory structure with LOC stats\nrecursivist export \\\n  --format md \\\n  --output-dir ./analysis \\\n  --prefix \"structure\" \\\n  --sort-by-loc\n\n# Run additional tools (examples)\n# 1. radon for code complexity metrics (Python)\nif command -v radon &amp;&gt; /dev/null; then\n  echo \"Running complexity analysis...\"\n  radon cc . -a -s &gt; analysis/complexity.txt\nfi\n\n# 2. cloc for language statistics\nif command -v cloc &amp;&gt; /dev/null; then\n  echo \"Running line count by language...\"\n  cloc . --exclude-dir=node_modules,.git --md &gt; analysis/language-stats.md\nfi\n\n# 3. SonarQube scanner (if configured)\nif command -v sonar-scanner &amp;&gt; /dev/null; then\n  echo \"Running SonarQube scan...\"\n  sonar-scanner\nfi\n\necho \"Analysis complete. Results in ./analysis directory.\"\n</code></pre> <p>By integrating Recursivist with other tools, you can build comprehensive project documentation, analysis, and visualization pipelines that provide valuable insights into your codebase.</p>"},{"location":"advanced/testing/","title":"Testing Guide","text":"<p>This guide covers the testing framework and practices for Recursivist development. It's intended for contributors who want to add features or fix bugs in the codebase.</p>"},{"location":"advanced/testing/#testing-framework","title":"Testing Framework","text":"<p>Recursivist uses pytest for testing. The test suite covers:</p> <ul> <li>Core functionality (directory traversal, pattern matching, tree building)</li> <li>CLI interface (commands, options, argument handling)</li> <li>Export formats (TXT, JSON, HTML, MD, JSX)</li> <li>Comparison functionality (side-by-side directory comparison)</li> <li>Pattern matching (glob patterns, regex patterns)</li> <li>File statistics (lines of code, file sizes, modification times)</li> </ul>"},{"location":"advanced/testing/#running-tests","title":"Running Tests","text":""},{"location":"advanced/testing/#basic-test-commands","title":"Basic Test Commands","text":"<pre><code># Run all tests\npytest\n\n# Run with verbose output\npytest -v\n\n# Stop on first failure and show traceback\npytest -xvs\n\n# Run a specific test file\npytest tests/test_core.py\n\n# Run tests matching a specific name\npytest -k \"pattern\"\n</code></pre>"},{"location":"advanced/testing/#coverage-testing","title":"Coverage Testing","text":"<p>To see how much of the codebase is covered by tests:</p> <pre><code># Basic coverage report\npytest --cov=recursivist\n\n# Detailed HTML coverage report\npytest --cov=recursivist --cov-report=html\n</code></pre> <p>This creates an HTML report in the <code>htmlcov</code> directory that shows which lines of code are covered by tests.</p>"},{"location":"advanced/testing/#test-organization","title":"Test Organization","text":"<p>Tests are organized by module and functionality:</p> <pre><code>tests/\n\u251c\u2500\u2500 test_cli.py          # Command-line interface tests\n\u251c\u2500\u2500 test_core.py         # Core functionality tests\n\u251c\u2500\u2500 test_exports.py      # Export format tests\n\u251c\u2500\u2500 test_compare.py      # Comparison functionality tests\n\u251c\u2500\u2500 test_pattern.py      # Pattern matching tests\n\u251c\u2500\u2500 test_integration.py  # End-to-end integration tests\n\u2514\u2500\u2500 conftest.py          # Test fixtures and configuration\n</code></pre> <p>Each test file focuses on a specific aspect of the codebase to maintain clear separation of concerns.</p>"},{"location":"advanced/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"advanced/testing/#test-structure","title":"Test Structure","text":"<p>Follow this pattern for writing tests:</p> <pre><code>def test_function_name(fixture1, fixture2):\n    \"\"\"Test description - what is being tested.\"\"\"\n    # 1. Setup - prepare the test conditions\n    input_data = ...\n    expected_output = ...\n\n    # 2. Exercise - call the function being tested\n    actual_output = function_under_test(input_data)\n\n    # 3. Verify - check if the function behaved as expected\n    assert actual_output == expected_output\n\n    # 4. Cleanup - if needed (usually handled by pytest fixtures)\n</code></pre>"},{"location":"advanced/testing/#testing-directory-operations","title":"Testing Directory Operations","text":"<p>For testing directory operations, use the <code>tmp_path</code> fixture:</p> <pre><code>def test_get_directory_structure(tmp_path):\n    # Create a test directory structure\n    (tmp_path / \"dir1\").mkdir()\n    (tmp_path / \"dir1\" / \"file1.txt\").write_text(\"content\")\n    (tmp_path / \"dir2\").mkdir()\n    (tmp_path / \"dir2\" / \"file2.py\").write_text(\"print('hello')\")\n\n    # Call the function\n    structure, extensions = get_directory_structure(str(tmp_path))\n\n    # Verify the result\n    assert \"dir1\" in structure\n    assert \"dir2\" in structure\n    assert \"_files\" in structure[\"dir1\"]\n    assert \"file1.txt\" in structure[\"dir1\"][\"_files\"]\n    assert \".py\" in extensions\n</code></pre>"},{"location":"advanced/testing/#testing-cli-commands","title":"Testing CLI Commands","text":"<p>For testing CLI commands, use <code>typer.testing.CliRunner</code>:</p> <pre><code>from typer.testing import CliRunner\nfrom recursivist.cli import app\n\ndef test_visualize_command(tmp_path):\n    # Setup\n    runner = CliRunner()\n    (tmp_path / \"test_file.txt\").write_text(\"content\")\n\n    # Run the command\n    result = runner.invoke(app, [\"visualize\", str(tmp_path)])\n\n    # Verify the result\n    assert result.exit_code == 0\n    assert \"test_file.txt\" in result.stdout\n</code></pre>"},{"location":"advanced/testing/#testing-export-formats","title":"Testing Export Formats","text":"<p>For testing export formats:</p> <pre><code>def test_export_to_markdown(tmp_path):\n    # Setup\n    (tmp_path / \"test_file.txt\").write_text(\"content\")\n    output_path = tmp_path / \"output.md\"\n\n    # Run export\n    structure, _ = get_directory_structure(str(tmp_path))\n    export_structure(structure, str(tmp_path), \"md\", str(output_path))\n\n    # Verify output file\n    assert output_path.exists()\n    content = output_path.read_text()\n    assert \"# \ud83d\udcc2\" in content\n    assert \"test_file.txt\" in content\n</code></pre>"},{"location":"advanced/testing/#testing-with-parametrization","title":"Testing with Parametrization","text":"<p>Use parametrized tests for testing multiple scenarios with the same logic:</p> <pre><code>import pytest\n\n@pytest.mark.parametrize(\"exclude_dirs, expected_files\", [\n    ([\"dir1\"], [\"dir2/file2.txt\"]),\n    ([\"dir2\"], [\"dir1/file1.txt\"]),\n    ([], [\"dir1/file1.txt\", \"dir2/file2.txt\"])\n])\ndef test_exclude_directories(tmp_path, exclude_dirs, expected_files):\n    # Setup\n    (tmp_path / \"dir1\").mkdir()\n    (tmp_path / \"dir1\" / \"file1.txt\").write_text(\"content\")\n    (tmp_path / \"dir2\").mkdir()\n    (tmp_path / \"dir2\" / \"file2.txt\").write_text(\"content\")\n\n    # Get the structure with exclusions\n    structure, _ = get_directory_structure(str(tmp_path), exclude_dirs=exclude_dirs)\n\n    # Extract all files from the structure\n    all_files = []\n\n    def collect_files(struct, path=\"\"):\n        if \"_files\" in struct:\n            for file_item in struct[\"_files\"]:\n                if isinstance(file_item, tuple):\n                    file_name = file_item[0]\n                else:\n                    file_name = file_item\n                all_files.append(f\"{path}/{file_name}\" if path else file_name)\n\n        for name, content in struct.items():\n            if isinstance(content, dict) and name not in [\"_files\", \"_max_depth_reached\", \"_loc\", \"_size\", \"_mtime\"]:\n                new_path = f\"{path}/{name}\" if path else name\n                collect_files(content, new_path)\n\n    collect_files(structure)\n\n    # Verify all expected files are found and no unexpected files are present\n    assert sorted(all_files) == sorted(expected_files)\n</code></pre>"},{"location":"advanced/testing/#test-fixtures","title":"Test Fixtures","text":"<p>Use pytest fixtures for shared test setup:</p> <pre><code>import pytest\n\n@pytest.fixture\ndef simple_dir_structure(tmp_path):\n    \"\"\"Create a simple directory structure for testing.\"\"\"\n    # Create directories\n    (tmp_path / \"dir1\").mkdir()\n    (tmp_path / \"dir2\").mkdir()\n    (tmp_path / \"dir2\" / \"subdir\").mkdir()\n\n    # Create files\n    (tmp_path / \"root_file.txt\").write_text(\"root content\")\n    (tmp_path / \"dir1\" / \"file1.py\").write_text(\"print('hello')\")\n    (tmp_path / \"dir2\" / \"file2.js\").write_text(\"console.log('hello')\")\n    (tmp_path / \"dir2\" / \"subdir\" / \"file3.css\").write_text(\"body { color: red; }\")\n\n    return tmp_path\n\ndef test_directory_traversal(simple_dir_structure):\n    # Now you can use the fixture\n    structure, extensions = get_directory_structure(str(simple_dir_structure))\n\n    # Verify structure\n    assert \"dir1\" in structure\n    assert \"dir2\" in structure\n    assert \"subdir\" in structure[\"dir2\"]\n\n    # Verify extensions\n    assert set(extensions) == {\".txt\", \".py\", \".js\", \".css\"}\n</code></pre>"},{"location":"advanced/testing/#mocking","title":"Mocking","text":"<p>For testing functions that interact with external systems or have side effects, use mocking:</p> <pre><code>from unittest.mock import patch, MagicMock\n\ndef test_count_lines_of_code():\n    # Prepare test content\n    file_content = \"line 1\\nline 2\\nline 3\\n\"\n\n    # Mock the file open operation\n    mock_open = MagicMock()\n    mock_open.return_value.__enter__.return_value.read.return_value = file_content.encode('utf-8')\n    mock_file = MagicMock()\n    mock_file.__iter__.return_value = file_content.splitlines()\n\n    # Apply mocks\n    with patch('builtins.open', mock_open):\n        with patch('recursivist.core.open', mock_open):\n            # Run function with mocked file operations\n            result = count_lines_of_code(\"fake_file.py\")\n\n            # Verify result\n            assert result == 3\n</code></pre>"},{"location":"advanced/testing/#testing-pattern-matching","title":"Testing Pattern Matching","text":"<p>Test different pattern types (glob, regex) thoroughly:</p> <pre><code>@pytest.mark.parametrize(\"pattern, is_regex, paths, expected\", [\n    # Glob patterns\n    (\"*.py\", False, [\"file.py\", \"file.js\", \"test.py\"], [\"file.py\", \"test.py\"]),\n    (\"test_*.py\", False, [\"test_file.py\", \"file_test.py\", \"test.py\"], [\"test_file.py\"]),\n\n    # Regex patterns\n    (r\".*\\.py$\", True, [\"file.py\", \"file.js\", \"test.py\"], [\"file.py\", \"test.py\"]),\n    (r\"^test_.*\\.py$\", True, [\"test_file.py\", \"file_test.py\", \"test.py\"], [\"test_file.py\"]),\n])\ndef test_pattern_matching(tmp_path, pattern, is_regex, paths, expected):\n    # Create test files\n    for path in paths:\n        (tmp_path / path).write_text(\"content\")\n\n    # Compile patterns\n    patterns = compile_regex_patterns([pattern], is_regex)\n\n    # Get structure with patterns\n    structure, _ = get_directory_structure(\n        str(tmp_path),\n        exclude_patterns=patterns if is_regex else None,\n        include_patterns=None\n    )\n\n    # Check that only expected files are included\n    found_files = structure.get(\"_files\", [])\n    found_names = [f[0] if isinstance(f, tuple) else f for f in found_files]\n\n    # If we're using exclude patterns, we expect the opposite\n    if pattern in patterns:\n        # For exclude patterns, check that no excluded files are present\n        for path in paths:\n            filename = os.path.basename(path)\n            if filename in expected:\n                assert filename not in found_names\n            else:\n                assert filename in found_names\n    else:\n        # For include patterns, check that only included files are present\n        assert sorted(found_names) == sorted([os.path.basename(p) for p in expected])\n</code></pre>"},{"location":"advanced/testing/#testing-statistics","title":"Testing Statistics","text":"<p>Test the file statistics collection functionality:</p> <pre><code>def test_file_statistics(tmp_path):\n    # Create test files with known content\n    py_file = tmp_path / \"test.py\"\n    py_file.write_text(\"line 1\\nline 2\\nline 3\\n\")\n\n    # Get structure with statistics\n    structure, _ = get_directory_structure(\n        str(tmp_path),\n        sort_by_loc=True,\n        sort_by_size=True,\n        sort_by_mtime=True\n    )\n\n    # Verify LOC statistic\n    assert structure[\"_loc\"] == 3\n\n    # Verify size statistic\n    py_file_size = os.path.getsize(str(py_file))\n    assert structure[\"_size\"] == py_file_size\n\n    # Verify mtime statistic\n    py_file_mtime = os.path.getmtime(str(py_file))\n    assert structure[\"_mtime\"] == py_file_mtime\n\n    # Verify file structure\n    file_item = structure[\"_files\"][0]\n    assert isinstance(file_item, tuple)\n    assert file_item[0] == \"test.py\"  # Filename\n    assert file_item[2] == 3          # LOC\n    assert file_item[3] == py_file_size  # Size\n    assert file_item[4] == py_file_mtime  # Mtime\n</code></pre>"},{"location":"advanced/testing/#testing-cli-options","title":"Testing CLI Options","text":"<p>Test various CLI option combinations:</p> <pre><code>@pytest.mark.parametrize(\"options, expected_in_output, expected_not_in_output\", [\n    # Test depth limiting\n    ([\"--depth\", \"1\"], [\"dir1\"], [\"file3.txt\"]),\n\n    # Test exclude directories\n    ([\"--exclude\", \"dir1\"], [\"dir2\"], [\"dir1\", \"file1.txt\"]),\n\n    # Test exclude extensions\n    ([\"--exclude-ext\", \".txt\"], [\"file2.py\"], [\"file1.txt\", \"file3.txt\"]),\n\n    # Test LOC sorting\n    ([\"--sort-by-loc\"], [\"lines\"], []),\n\n    # Test size sorting\n    ([\"--sort-by-size\"], [\"KB\", \"B\"], []),\n\n    # Test mtime sorting\n    ([\"--sort-by-mtime\"], [\"Today\", \"Yesterday\"], []),\n\n    # Test multiple options\n    (\n        [\"--exclude\", \"dir2\", \"--sort-by-loc\", \"--depth\", \"1\"],\n        [\"dir1\", \"lines\"],\n        [\"dir2\", \"file3.txt\"]\n    ),\n])\ndef test_cli_options(tmp_path, options, expected_in_output, expected_not_in_output):\n    # Create test directory structure\n    (tmp_path / \"dir1\").mkdir()\n    (tmp_path / \"dir2\").mkdir()\n    (tmp_path / \"dir2\" / \"subdir\").mkdir()\n    (tmp_path / \"dir1\" / \"file1.txt\").write_text(\"content\\ncontent\")\n    (tmp_path / \"dir2\" / \"file2.py\").write_text(\"print('hello')\\nprint('world')\\nprint('!')\")\n    (tmp_path / \"dir2\" / \"subdir\" / \"file3.txt\").write_text(\"content\")\n\n    # Run command with options\n    runner = CliRunner()\n    result = runner.invoke(app, [\"visualize\", str(tmp_path)] + options)\n\n    # Verify exit code\n    assert result.exit_code == 0\n\n    # Verify expected content in output\n    for text in expected_in_output:\n        assert text in result.stdout\n\n    # Verify expected content not in output\n    for text in expected_not_in_output:\n        assert text not in result.stdout\n</code></pre>"},{"location":"advanced/testing/#debugging-tests","title":"Debugging Tests","text":"<p>When a test fails:</p> <ol> <li>Run with <code>-xvs</code> to stop at the first failure and show detailed output:</li> </ol> <pre><code>pytest -xvs tests/test_file.py::test_function\n</code></pre> <ol> <li>Add print statements or use <code>pytest.set_trace()</code> for debugging:</li> </ol> <pre><code>def test_function():\n    result = function_under_test()\n    print(f\"Result: {result}\")  # Will show in pytest output with -v\n    import pytest; pytest.set_trace()  # Will stop and start a debugger\n    assert result == expected\n</code></pre> <ol> <li>Use the <code>--pdb</code> flag to drop into the debugger on failures:</li> </ol> <pre><code>pytest --pdb\n</code></pre>"},{"location":"advanced/testing/#testing-complex-directory-structures","title":"Testing Complex Directory Structures","text":"<p>For testing complex directory hierarchies:</p> <pre><code>def create_complex_structure(tmp_path):\n    \"\"\"Create a more complex directory structure for testing.\"\"\"\n    # Project root files\n    (tmp_path / \"README.md\").write_text(\"# Project\\n\\nDescription\")\n    (tmp_path / \".gitignore\").write_text(\"node_modules/\\n*.pyc\\n\")\n\n    # Source code\n    src = tmp_path / \"src\"\n    src.mkdir()\n    (src / \"main.py\").write_text(\"def main():\\n    print('Hello')\\n\\nif __name__ == '__main__':\\n    main()\")\n    (src / \"utils.py\").write_text(\"def helper():\\n    return 'helper'\")\n\n    # Tests\n    tests = tmp_path / \"tests\"\n    tests.mkdir()\n    (tests / \"test_main.py\").write_text(\"def test_main():\\n    assert True\")\n    (tests / \"test_utils.py\").write_text(\"def test_helper():\\n    assert True\")\n\n    # Build artifacts\n    build = tmp_path / \"build\"\n    build.mkdir()\n    (build / \"output.min.js\").write_text(\"console.log('minified')\")\n\n    # Nested directories\n    (src / \"components\").mkdir()\n    (src / \"components\" / \"button.py\").write_text(\"class Button:\\n    pass\")\n    (src / \"components\" / \"form.py\").write_text(\"class Form:\\n    pass\")\n\n    return tmp_path\n\ndef test_large_directory_structure():\n    \"\"\"Test handling of a larger directory structure.\"\"\"\n    tmp_path = create_complex_structure(tmp_path_factory.getbasetemp())\n\n    # Test various scenarios with the complex structure\n    # ...\n</code></pre>"},{"location":"advanced/testing/#testing-edge-cases","title":"Testing Edge Cases","text":"<p>Always test edge cases and potential failure conditions:</p> <pre><code>def test_empty_directory(tmp_path):\n    \"\"\"Test behavior with an empty directory.\"\"\"\n    # Empty directory\n    structure, extensions = get_directory_structure(str(tmp_path))\n    assert \"_files\" not in structure\n    assert len(extensions) == 0\n\ndef test_nonexistent_directory():\n    \"\"\"Test behavior with a nonexistent directory.\"\"\"\n    with pytest.raises(Exception):\n        get_directory_structure(\"/nonexistent/directory\")\n\ndef test_permission_denied(tmp_path, monkeypatch):\n    \"\"\"Test behavior when permission is denied.\"\"\"\n    # Mock os.listdir to raise PermissionError\n    def mock_listdir(path):\n        raise PermissionError(\"Permission denied\")\n\n    monkeypatch.setattr(os, \"listdir\", mock_listdir)\n\n    # Should handle permission error gracefully\n    structure, extensions = get_directory_structure(str(tmp_path))\n    assert structure == {}\n    assert not extensions\n\ndef test_with_binary_files(tmp_path):\n    \"\"\"Test behavior with binary files.\"\"\"\n    # Create a binary file\n    binary_file = tmp_path / \"binary.bin\"\n    with open(binary_file, \"wb\") as f:\n        f.write(b\"\\x00\\x01\\x02\\x03\")\n\n    # Should handle binary files properly for LOC counting\n    structure, _ = get_directory_structure(str(tmp_path), sort_by_loc=True)\n\n    # Binary files should have 0 lines\n    assert structure[\"_loc\"] == 0\n</code></pre>"},{"location":"advanced/testing/#continuous-integration-testing","title":"Continuous Integration Testing","text":"<p>Run tests in CI environments to catch platform-specific issues:</p> <pre><code># Example GitHub Actions workflow\nname: Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: [\"3.7\", \"3.8\", \"3.9\", \"3.10\", \"3.11\"]\n\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install -e \".[dev]\"\n      - name: Run tests\n        run: |\n          pytest --cov=recursivist\n</code></pre>"},{"location":"advanced/testing/#test-driven-development","title":"Test-Driven Development","text":"<p>For adding new features, consider using Test-Driven Development (TDD):</p> <ol> <li>Write a failing test that defines the expected behavior</li> <li>Implement the minimal code to make the test pass</li> <li>Refactor the code while keeping the tests passing</li> </ol> <p>This approach ensures your new feature has test coverage from the start and helps clarify the requirements before implementation.</p>"},{"location":"advanced/testing/#test-best-practices","title":"Test Best Practices","text":"<ol> <li>Keep tests independent: Each test should run in isolation.</li> <li>Test one thing per test: Focus each test on a specific behavior.</li> <li>Use descriptive test names: Make it clear what is being tested.</li> <li>Test failure cases: Include tests for expected failures and edge cases.</li> <li>Keep tests fast: Optimize tests to run quickly to encourage frequent testing.</li> <li>Maintain test coverage: Add tests for new features and bug fixes.</li> <li>Test real-world scenarios: Include tests that reflect how users will actually use the software.</li> <li>Refactor tests when needed: Keep test code clean and maintainable.</li> </ol> <p>Following these testing practices will help ensure Recursivist remains stable and reliable as it evolves.</p>"},{"location":"examples/advanced/","title":"Advanced Examples","text":"<p>This page provides advanced examples of using Recursivist for more complex scenarios and integrations.</p>"},{"location":"examples/advanced/#working-with-file-statistics","title":"Working with File Statistics","text":""},{"location":"examples/advanced/#finding-large-files-across-projects","title":"Finding Large Files Across Projects","text":"<pre><code>#!/bin/bash\n\n# Process multiple projects to find largest files\necho \"Finding largest files across projects...\"\necho \"----------------------------------------\"\n\nfor dir in projects/*/; do\n  if [ -d \"$dir\" ]; then\n    project_name=$(basename \"$dir\")\n    echo \"Exporting size data for $project_name...\"\n\n    # Export project with size data\n    recursivist export \"$dir\" \\\n      --format json \\\n      --prefix \"${project_name}_sizes\" \\\n      --output-dir ./analysis \\\n      --sort-by-size \\\n      --exclude \"node_modules .git\"\n  fi\ndone\n\n# Find largest files using jq\necho \"Top 10 largest files across all projects:\"\ncat analysis/*_sizes.json | \\\n  jq -r '.structure | .. | objects | select(has(\"_files\")) | ._files[] |\n      select(type==\"object\" and has(\"size\")) |\n      \"\\(.size) \\(.path)\"' | \\\n  sort -nr | head -10 | \\\n  awk '{printf \"%.2f MB: %s\\n\", $1/(1024*1024), substr($0, length($1)+2)}'\n</code></pre>"},{"location":"examples/advanced/#lines-of-code-analysis-with-filtering","title":"Lines of Code Analysis with Filtering","text":"<pre><code>#!/bin/bash\n\n# Analyze code density by file type\necho \"Code density by file type in project:\"\n\n# Export with LOC data\nrecursivist export \\\n  --format json \\\n  --prefix code_stats \\\n  --sort-by-loc \\\n  --sort-by-size \\\n  --exclude \"node_modules .git build dist\"\n\n# Analyze with jq\njq -r '.structure | .. | objects | select(has(\"_files\")) | ._files[] |\n    select(type==\"object\" and has(\"loc\") and has(\"size\") and .loc &gt; 0) |\n    {path: .path, ext: (.path | split(\".\") | .[-1]), loc: .loc, size: .size,\n     density: (.loc / (.size/1024))} |\n    .ext + \",\" + (.density | tostring)' code_stats.json | \\\n  awk -F, '{sum[$1] += $2; count[$1]++}\n    END {for (ext in sum)\n      printf \"%s files: %.2f lines per KB (avg of %d files)\\n\",\n      ext, sum[ext]/count[ext], count[ext]}' | \\\n  sort -k3 -nr\n</code></pre>"},{"location":"examples/advanced/#finding-recently-modified-code","title":"Finding Recently Modified Code","text":"<pre><code>#!/bin/bash\n\n# Show files modified in the last day\necho \"Recent code changes:\"\n\n# Use sort-by-mtime to prioritize recent changes\nrecursivist visualize \\\n  --sort-by-mtime \\\n  --exclude \"node_modules .git dist\" \\\n  --exclude-ext \".log .tmp\" | \\\n  grep \"Today\\|Yesterday\" | head -20\n\n# Alternative script to export recent changes to HTML\nrecursivist export \\\n  --format html \\\n  --prefix recent_changes \\\n  --sort-by-mtime \\\n  --exclude \"node_modules .git\" \\\n  --include-pattern \"src/**/*\" \\\n  --output-dir ./reports\n\necho \"Recent changes exported to reports/recent_changes.html\"\n</code></pre>"},{"location":"examples/advanced/#combining-commands-with-shell-scripts","title":"Combining Commands with Shell Scripts","text":""},{"location":"examples/advanced/#batch-processing-multiple-directories","title":"Batch Processing Multiple Directories","text":"<pre><code>#!/bin/bash\n\n# Process all direct subdirectories with file statistics\nfor dir in */; do\n  if [ -d \"$dir\" ] &amp;&amp; [ \"$dir\" != \"node_modules/\" ] &amp;&amp; [ \"$dir\" != \".git/\" ]; then\n    dir_name=$(basename \"$dir\")\n    echo \"Processing $dir_name...\"\n\n    # Visualize and export with lines of code statistics\n    recursivist visualize \"$dir\" \\\n      --exclude \"node_modules .git\" \\\n      --exclude-ext .log \\\n      --sort-by-loc\n\n    recursivist export \"$dir\" \\\n      --format md \\\n      --output-dir ./reports \\\n      --prefix \"$dir_name\" \\\n      --sort-by-loc \\\n      --sort-by-size\n  fi\ndone\n</code></pre>"},{"location":"examples/advanced/#project-report-generator","title":"Project Report Generator","text":"<pre><code>#!/bin/bash\n\n# Create report directory\nmkdir -p project-report\n\n# Generate project overview\nrecursivist export \\\n  --format md \\\n  --depth 2 \\\n  --exclude \"node_modules .git\" \\\n  --output-dir ./project-report \\\n  --prefix \"01-overview\"\n\n# Generate detailed source structure with statistics\nrecursivist export src \\\n  --format md \\\n  --output-dir ./project-report \\\n  --prefix \"02-source\" \\\n  --sort-by-loc \\\n  --sort-by-size\n\n# Generate test structure\nrecursivist export tests \\\n  --format md \\\n  --output-dir ./project-report \\\n  --prefix \"03-tests\" \\\n  --sort-by-loc\n\n# Generate documentation structure\nrecursivist export docs \\\n  --format md \\\n  --output-dir ./project-report \\\n  --prefix \"04-documentation\"\n\n# Combine into a single report\ncat ./project-report/01-overview.md &gt; ./project-report/project-structure.md\necho \"\" &gt;&gt; ./project-report/project-structure.md\ncat ./project-report/02-source.md &gt;&gt; ./project-report/project-structure.md\necho \"\" &gt;&gt; ./project-report/project-structure.md\ncat ./project-report/03-tests.md &gt;&gt; ./project-report/project-structure.md\necho \"\" &gt;&gt; ./project-report/project-structure.md\ncat ./project-report/04-documentation.md &gt;&gt; ./project-report/project-structure.md\n\necho \"Project report generated at ./project-report/project-structure.md\"\n</code></pre>"},{"location":"examples/advanced/#integration-with-other-tools","title":"Integration with Other Tools","text":""},{"location":"examples/advanced/#git-hook-for-project-structure-documentation","title":"Git Hook for Project Structure Documentation","text":"<p>Create a pre-commit hook (<code>.git/hooks/pre-commit</code>) to keep your project structure documentation up-to-date:</p> <pre><code>#!/bin/bash\n\n# Check if the structure has changed\nif git diff --cached --name-only | grep -q -v \"structure.md\"; then\n  echo \"Updating project structure documentation...\"\n\n  # Generate updated structure documentation with LOC statistics\n  recursivist export \\\n    --format md \\\n    --exclude \"node_modules .git\" \\\n    --prefix \"structure\" \\\n    --sort-by-loc\n\n  # Add the updated file to the commit\n  git add structure.md\nfi\n</code></pre> <p>Make the hook executable:</p> <pre><code>chmod +x .git/hooks/pre-commit\n</code></pre>"},{"location":"examples/advanced/#using-with-continuous-integration","title":"Using with Continuous Integration","text":"<p>Here's a GitHub Actions workflow to document project structure with statistics on each push:</p> <pre><code>name: Update Structure Documentation\n\non:\n  push:\n    branches: [main]\n    paths-ignore:\n      - \"docs/structure.md\"\n\njobs:\n  update-structure:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.10\"\n\n      - name: Install Recursivist\n        run: pip install recursivist\n\n      - name: Generate structure documentation\n        run: |\n          mkdir -p docs\n          recursivist export \\\n            --format md \\\n            --exclude \"node_modules .git\" \\\n            --output-dir ./docs \\\n            --prefix \"structure\" \\\n            --sort-by-loc \\\n            --sort-by-size\n\n      - name: Commit and push if changed\n        run: |\n          git config --local user.email \"action@github.com\"\n          git config --local user.name \"GitHub Action\"\n          git add docs/structure.md\n          git diff --quiet &amp;&amp; git diff --staged --quiet || git commit -m \"Update project structure documentation\"\n          git push\n</code></pre>"},{"location":"examples/advanced/#mkdocs-integration-with-statistics","title":"MkDocs Integration with Statistics","text":"<p>Add this to your MkDocs workflow to include project structure with LOC metrics:</p> <pre><code>name: Build Documentation\n\non:\n  push:\n    branches: [main]\n\njobs:\n  build-docs:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.10\"\n\n      - name: Install dependencies\n        run: |\n          pip install mkdocs mkdocs-material recursivist\n\n      - name: Generate structure documentation\n        run: |\n          recursivist export \\\n            --format md \\\n            --exclude \"node_modules .git\" \\\n            --output-dir ./docs \\\n            --prefix \"structure\" \\\n            --sort-by-loc\n\n      - name: Build and deploy docs\n        run: mkdocs gh-deploy --force\n</code></pre>"},{"location":"examples/advanced/#using-with-git-repositories","title":"Using with Git Repositories","text":""},{"location":"examples/advanced/#comparing-git-branches-with-statistics","title":"Comparing Git Branches with Statistics","text":"<pre><code>#!/bin/bash\n\n# Compare structure between current branch and main with file statistics\ncurrent_branch=$(git rev-parse --abbrev-ref HEAD)\n\n# Create temporary directories\nmkdir -p .tmp/current .tmp/main\n\n# Copy current branch files (excluding .git)\ngit ls-files | xargs -I{} cp --parents {} .tmp/current/\n\n# Checkout main branch files\ngit checkout main -- .\ngit ls-files | xargs -I{} cp --parents {} .tmp/main/\ngit checkout $current_branch -- .\n\n# Compare the structures with LOC stats\nrecursivist compare .tmp/current .tmp/main \\\n  --save \\\n  --prefix \"branch-comparison\" \\\n  --sort-by-loc\n\n# Clean up\nrm -rf .tmp\n\necho \"Branch comparison saved to branch-comparison.html\"\n</code></pre>"},{"location":"examples/advanced/#analyzing-git-repository-structure-with-statistics","title":"Analyzing Git Repository Structure with Statistics","text":"<pre><code>#!/bin/bash\n\n# Clone repository to analyze\nif [ $# -ne 1 ]; then\n  echo \"Usage: $0 &lt;repository-url&gt;\"\n  exit 1\nfi\n\nrepo_url=$1\nrepo_name=$(basename $repo_url .git)\n\necho \"Analyzing repository: $repo_url\"\ngit clone $repo_url --depth 1\ncd $repo_name\n\n# Generate structure reports with file statistics\nrecursivist export \\\n  --format md \\\n  --exclude \"node_modules .git\" \\\n  --prefix \"structure\" \\\n  --sort-by-loc\n\nrecursivist export \\\n  --format json \\\n  --exclude \"node_modules .git\" \\\n  --prefix \"structure\" \\\n  --sort-by-loc \\\n  --sort-by-size\n\n# Analysis using JSON output and jq\necho \"Structure Analysis:\"\necho \"-------------------\"\necho \"Total files: $(jq '.structure | .. | objects | select(has(\"_files\")) | ._files | length' structure.json | jq -s 'add')\"\necho \"Total lines of code: $(jq '.structure._loc // 0' structure.json)\"\n\n# Get directory counts and LOC by directory\necho \"Directory structure with LOC counts:\"\njq -r '.structure | to_entries[] |\n    select(.value | type == \"object\" and has(\"_files\") and has(\"_loc\")) |\n    .key + \": \" + (.value._loc | tostring) + \" lines in \" +\n    (.value._files | length | tostring) + \" files\"' structure.json | sort -t: -k2 -nr\n\n# Cleanup\ncd ..\necho \"Analysis complete. Reports in ./$repo_name/structure.md and ./$repo_name/structure.json\"\n</code></pre>"},{"location":"examples/advanced/#limiting-directory-depth-with-file-statistics","title":"Limiting Directory Depth with File Statistics","text":""},{"location":"examples/advanced/#visualizing-deep-directories-incrementally-with-statistics","title":"Visualizing Deep Directories Incrementally with Statistics","text":"<pre><code>#!/bin/bash\n\n# Start with a high-level overview including LOC counts\necho \"High-level overview (depth=1):\"\nrecursivist visualize --depth 1 --sort-by-loc\n\n# Show more detail for interesting directories\nread -p \"Enter a directory to explore further: \" dir\nif [ -d \"$dir\" ]; then\n  echo \"Detailed view of $dir with LOC statistics:\"\n  recursivist visualize \"$dir\" --depth 2 --sort-by-loc\n\n  # Allow exploring subdirectories\n  read -p \"Enter a subdirectory of $dir to explore fully: \" subdir\n  full_path=\"$dir/$subdir\"\n  if [ -d \"$full_path\" ]; then\n    echo \"Full view of $full_path with LOC statistics:\"\n    recursivist visualize \"$full_path\" --sort-by-loc\n  else\n    echo \"Directory not found: $full_path\"\n  fi\nelse\n  echo \"Directory not found: $dir\"\nfi\n</code></pre>"},{"location":"examples/advanced/#creating-a-multi-level-project-map-with-statistics","title":"Creating a Multi-Level Project Map with Statistics","text":"<pre><code>#!/bin/bash\n\n# Create output directory\nmkdir -p project-map\n\n# Generate structure maps at different levels with file statistics\nrecursivist export \\\n  --format md \\\n  --depth 1 \\\n  --output-dir ./project-map \\\n  --prefix \"L1-overview\" \\\n  --sort-by-size\n\nrecursivist export \\\n  --format md \\\n  --depth 2 \\\n  --output-dir ./project-map \\\n  --prefix \"L2-structure\" \\\n  --sort-by-loc\n\nrecursivist export \\\n  --format md \\\n  --depth 3 \\\n  --output-dir ./project-map \\\n  --prefix \"L3-detailed\" \\\n  --sort-by-loc \\\n  --sort-by-size\n\nrecursivist export \\\n  --format md \\\n  --output-dir ./project-map \\\n  --prefix \"L4-complete\" \\\n  --sort-by-loc \\\n  --sort-by-size \\\n  --sort-by-mtime\n\necho \"Project map generated with multiple detail levels in ./project-map/\"\n</code></pre>"},{"location":"examples/advanced/#react-component-integration-with-statistics","title":"React Component Integration with Statistics","text":""},{"location":"examples/advanced/#creating-a-project-explorer-with-file-statistics","title":"Creating a Project Explorer with File Statistics","text":"<p>This example shows how to integrate a Recursivist-generated React component with file statistics into a web application:</p> <ol> <li>First, export the directory structure as a React component with file statistics:</li> </ol> <pre><code>recursivist export \\\n  --format jsx \\\n  --exclude \"node_modules .git\" \\\n  --output-dir ./src/components \\\n  --prefix \"DirectoryViewer\" \\\n  --sort-by-loc \\\n  --sort-by-size \\\n  --sort-by-mtime\n</code></pre> <ol> <li>Create a wrapper component to integrate it into your app:</li> </ol> <pre><code>// src/components/ProjectExplorer.jsx\nimport React, { useState } from \"react\";\nimport DirectoryViewer from \"./DirectoryViewer\";\n\nconst ProjectExplorer = () =&gt; {\n  const [activeTab, setActiveTab] = useState(\"structure\");\n\n  return (\n    &lt;div className=\"project-explorer\"&gt;\n      &lt;h2&gt;Project Structure&lt;/h2&gt;\n      &lt;p&gt;\n        This interactive view shows the structure of our project with file\n        statistics.\n      &lt;/p&gt;\n      &lt;div className=\"explorer-container p-4 bg-white rounded-lg shadow\"&gt;\n        &lt;DirectoryViewer /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nexport default ProjectExplorer;\n</code></pre> <ol> <li>Use the component in your application:</li> </ol> <pre><code>// src/App.jsx\nimport React from \"react\";\nimport ProjectExplorer from \"./components/ProjectExplorer\";\n\nfunction App() {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;header&gt;\n        &lt;h1&gt;Project Documentation&lt;/h1&gt;\n      &lt;/header&gt;\n      &lt;main&gt;\n        &lt;section&gt;\n          &lt;ProjectExplorer /&gt;\n        &lt;/section&gt;\n        {/* Other sections */}\n      &lt;/main&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default App;\n</code></pre>"},{"location":"examples/advanced/#using-regex-patterns-with-file-statistics","title":"Using Regex Patterns with File Statistics","text":""},{"location":"examples/advanced/#finding-complex-files-by-size","title":"Finding Complex Files by Size","text":"<pre><code># Find large JavaScript files with specific naming patterns\nrecursivist visualize \\\n  --include-pattern \"^src/.*\\.(jsx?|tsx?)$\" \\\n  --exclude-pattern \".*\\.(spec|test)\\.(jsx?|tsx?)$\" \\\n  --regex \\\n  --sort-by-size\n</code></pre>"},{"location":"examples/advanced/#finding-files-by-loc-and-type","title":"Finding Files by LOC and Type","text":"<pre><code># Identify React components with high line counts\nrecursivist visualize \\\n  --include-pattern \"^src/components/.*\\.jsx$\" \\\n  --regex \\\n  --sort-by-loc\n</code></pre>"},{"location":"examples/advanced/#integration-with-analysis-tools","title":"Integration with Analysis Tools","text":""},{"location":"examples/advanced/#structure-analysis-with-loc-statistics","title":"Structure Analysis with LOC Statistics","text":"<pre><code>#!/bin/bash\n\n# Export JSON structure with file statistics\nrecursivist export \\\n  --format json \\\n  --full-path \\\n  --prefix \"structure\" \\\n  --sort-by-loc \\\n  --sort-by-size\n\necho \"Project Structure Analysis:\"\necho \"==========================\"\n\n# Count total lines\ntotal_loc=$(jq '.structure._loc // 0' structure.json)\necho \"Total lines of code: $total_loc\"\n\n# Lines of code by file type\necho -e \"\\nLines of code by file type:\"\njq -r '.structure | .. | objects | select(has(\"_files\")) | ._files[] |\n    select(type==\"object\" and has(\"loc\")) |\n    {ext: (.path | split(\".\") | .[-1]), loc: .loc} |\n    .ext + \",\" + (.loc | tostring)' structure.json | \\\n  awk -F, '{sum[$1] += $2; count[$1]++}\n    END {for (ext in sum)\n      printf \"%s: %d lines (%.1f%% of codebase) in %d files\\n\",\n      ext, sum[$1], sum[$1]*100/'$total_loc', count[$1]}' | \\\n  sort -t: -k2 -nr\n\n# Count files by type\necho -e \"\\nFiles by type:\"\njq -r '.structure | .. | objects | select(has(\"_files\")) | ._files[] |\n    select(type==\"object\") |\n    .path | split(\".\") | .[-1] | ascii_downcase' structure.json | \\\n  sort | uniq -c | sort -nr\n\n# Find largest files\necho -e \"\\nTop 10 largest files by lines of code:\"\njq -r '.structure | .. | objects | select(has(\"_files\")) | ._files[] |\n    select(type==\"object\" and has(\"loc\")) |\n    [.loc, .path] | @tsv' structure.json | \\\n  sort -nr | head -10\n\necho -e \"\\nAnalysis complete!\"\n</code></pre>"},{"location":"examples/advanced/#using-with-ignore-files-and-file-statistics","title":"Using with Ignore Files and File Statistics","text":""},{"location":"examples/advanced/#custom-ignore-file-for-documentation-with-statistics","title":"Custom Ignore File for Documentation with Statistics","text":"<p>Create a <code>.recursivist-ignore</code> file:</p> <pre><code># Ignore build artifacts and dependencies\nnode_modules/\ndist/\nbuild/\n*.min.js\n*.bundle.js\n\n# Ignore temporary files\n*.log\n*.tmp\n*.cache\n.DS_Store\n\n# Ignore test files\n*.test.js\n*.spec.js\n__tests__/\ntest/\ntests/\n\n# Ignore configuration files\n.*rc\n*.config.js\n*.config.ts\n</code></pre> <p>Then use it with file statistics:</p> <pre><code>recursivist visualize \\\n  --ignore-file .recursivist-ignore \\\n  --sort-by-loc \\\n  --sort-by-size\n</code></pre> <p>This provides a clean view focusing on the core source code and documentation, with additional insights from the file statistics.</p>"},{"location":"examples/basic/","title":"Basic Examples","text":"<p>This page provides simple examples of common Recursivist usage patterns. These examples are designed to help you get familiar with the basic capabilities of the tool.</p>"},{"location":"examples/basic/#simple-visualization","title":"Simple Visualization","text":""},{"location":"examples/basic/#viewing-the-current-directory","title":"Viewing the Current Directory","text":"<p>To visualize the current directory structure:</p> <pre><code>recursivist visualize\n</code></pre> <p>This will produce output similar to:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py\n\u251c\u2500\u2500 \ud83d\udcc4 README.md\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py\n</code></pre>"},{"location":"examples/basic/#viewing-a-specific-directory","title":"Viewing a Specific Directory","text":"<p>To visualize a different directory:</p> <pre><code>recursivist visualize ~/projects/my-app\n</code></pre>"},{"location":"examples/basic/#limiting-directory-depth","title":"Limiting Directory Depth","text":"<p>To limit the depth of the directory tree (useful for large projects):</p> <pre><code>recursivist visualize --depth 2\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests\n\u2502       \u22ef (max depth reached)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py\n</code></pre>"},{"location":"examples/basic/#showing-full-paths","title":"Showing Full Paths","text":"<p>To show full file paths instead of just filenames:</p> <pre><code>recursivist visualize --full-path\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 /home/user/my-project/src/main.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 /home/user/my-project/src/utils.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 /home/user/my-project/src/tests/test_main.py\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 /home/user/my-project/src/tests/test_utils.py\n\u251c\u2500\u2500 \ud83d\udcc4 /home/user/my-project/README.md\n\u251c\u2500\u2500 \ud83d\udcc4 /home/user/my-project/requirements.txt\n\u2514\u2500\u2500 \ud83d\udcc4 /home/user/my-project/setup.py\n</code></pre>"},{"location":"examples/basic/#file-statistics","title":"File Statistics","text":""},{"location":"examples/basic/#showing-lines-of-code","title":"Showing Lines of Code","text":"<p>To display and sort by lines of code:</p> <pre><code>recursivist visualize --sort-by-loc\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (4328 lines)\n\u251c\u2500\u2500 \ud83d\udcc1 src (3851 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (245 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (157 lines)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests (653 lines)\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py (412 lines)\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py (241 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md (124 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt (18 lines)\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py (65 lines)\n</code></pre>"},{"location":"examples/basic/#showing-file-sizes","title":"Showing File Sizes","text":"<p>To display and sort by file sizes:</p> <pre><code>recursivist visualize --sort-by-size\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (1.2 MB)\n\u251c\u2500\u2500 \ud83d\udcc1 src (850.5 KB)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (12.4 KB)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (8.2 KB)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests (45.7 KB)\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py (28.9 KB)\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py (16.8 KB)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md (4.2 KB)\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt (512 B)\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py (3.8 KB)\n</code></pre>"},{"location":"examples/basic/#showing-modification-times","title":"Showing Modification Times","text":"<p>To display and sort by modification times:</p> <pre><code>recursivist visualize --sort-by-mtime\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (Today 14:30)\n\u251c\u2500\u2500 \ud83d\udcc1 src (Today 14:25)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (Today 14:25)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (Yesterday 18:10)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests (Feb 15)\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py (Feb 15)\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py (Feb 10)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md (Today 10:15)\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt (Jan 20)\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py (Jan 15)\n</code></pre>"},{"location":"examples/basic/#combining-statistics","title":"Combining Statistics","text":"<p>To show multiple statistics at once:</p> <pre><code>recursivist visualize --sort-by-loc --sort-by-size\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (4328 lines, 1.2 MB)\n\u251c\u2500\u2500 \ud83d\udcc1 src (3851 lines, 850.5 KB)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (245 lines, 12.4 KB)\n...\n</code></pre>"},{"location":"examples/basic/#simple-exclusions","title":"Simple Exclusions","text":""},{"location":"examples/basic/#excluding-specific-directories","title":"Excluding Specific Directories","text":"<p>To exclude directories like <code>node_modules</code> or <code>.git</code>:</p> <pre><code>recursivist visualize --exclude \"node_modules .git\"\n</code></pre>"},{"location":"examples/basic/#excluding-file-extensions","title":"Excluding File Extensions","text":"<p>To exclude files with specific extensions:</p> <pre><code>recursivist visualize --exclude-ext \".pyc .log\"\n</code></pre>"},{"location":"examples/basic/#combining-exclusions","title":"Combining Exclusions","text":"<p>You can combine different exclusion methods:</p> <pre><code>recursivist visualize --exclude \"node_modules .git\" --exclude-ext \".pyc .log\"\n</code></pre>"},{"location":"examples/basic/#basic-exports","title":"Basic Exports","text":""},{"location":"examples/basic/#exporting-to-markdown","title":"Exporting to Markdown","text":"<p>To export the current directory structure to Markdown:</p> <pre><code>recursivist export --format md\n</code></pre> <p>This creates a file named <code>structure.md</code> in the current directory.</p>"},{"location":"examples/basic/#exporting-to-multiple-formats","title":"Exporting to Multiple Formats","text":"<p>To export to multiple formats at once:</p> <pre><code>recursivist export --format \"txt md json\"\n</code></pre>"},{"location":"examples/basic/#exporting-to-a-specific-directory","title":"Exporting to a Specific Directory","text":"<p>To export to a different directory:</p> <pre><code>recursivist export --format html --output-dir ./docs\n</code></pre>"},{"location":"examples/basic/#customizing-the-filename","title":"Customizing the Filename","text":"<p>To use a custom filename prefix:</p> <pre><code>recursivist export --format json --prefix my-project\n</code></pre> <p>This creates a file named <code>my-project.json</code>.</p>"},{"location":"examples/basic/#exporting-with-statistics","title":"Exporting with Statistics","text":"<p>To include file statistics in the export:</p> <pre><code>recursivist export --format html --sort-by-loc --sort-by-size\n</code></pre>"},{"location":"examples/basic/#simple-comparisons","title":"Simple Comparisons","text":""},{"location":"examples/basic/#comparing-two-directories","title":"Comparing Two Directories","text":"<p>To compare two directories:</p> <pre><code>recursivist compare dir1 dir2\n</code></pre> <p>This displays a side-by-side comparison in the terminal.</p>"},{"location":"examples/basic/#exporting-a-comparison","title":"Exporting a Comparison","text":"<p>To save the comparison as an HTML file:</p> <pre><code>recursivist compare dir1 dir2 --save\n</code></pre> <p>This creates a file named <code>comparison.html</code> in the current directory.</p>"},{"location":"examples/basic/#comparing-with-statistics","title":"Comparing with Statistics","text":"<p>To include file statistics in the comparison:</p> <pre><code>recursivist compare dir1 dir2 --sort-by-loc\n</code></pre> <p>This makes it easy to see not just structural differences but also differences in code volume.</p>"},{"location":"examples/basic/#shell-completion","title":"Shell Completion","text":""},{"location":"examples/basic/#generating-shell-completion-for-bash","title":"Generating Shell Completion for Bash","text":"<pre><code>mkdir -p ~/.bash_completion.d\nrecursivist completion bash &gt; ~/.bash_completion.d/recursivist\nsource ~/.bash_completion.d/recursivist\n</code></pre>"},{"location":"examples/basic/#generating-shell-completion-for-zsh","title":"Generating Shell Completion for Zsh","text":"<pre><code>mkdir -p ~/.zsh/completion\nrecursivist completion zsh &gt; ~/.zsh/completion/_recursivist\n</code></pre> <p>Then add to your <code>.zshrc</code>:</p> <pre><code>fpath=(~/.zsh/completion $fpath)\nautoload -U compinit; compinit\n</code></pre>"},{"location":"examples/basic/#version-information","title":"Version Information","text":"<p>To check the version of Recursivist:</p> <pre><code>recursivist version\n</code></pre>"},{"location":"examples/basic/#next-steps","title":"Next Steps","text":"<p>These basic examples should help you get started with Recursivist. For more advanced examples, check out:</p> <ul> <li>Filtering Examples - More complex pattern matching</li> <li>Export Examples - Advanced export options</li> <li>Compare Examples - In-depth comparison examples</li> <li>Advanced Examples - Advanced usage patterns</li> </ul>"},{"location":"examples/compare/","title":"Compare Examples","text":"<p>This page provides practical examples of how to use Recursivist's directory comparison functionality to identify differences between directory structures.</p>"},{"location":"examples/compare/#basic-comparison-examples","title":"Basic Comparison Examples","text":""},{"location":"examples/compare/#simple-directory-comparison","title":"Simple Directory Comparison","text":"<pre><code>recursivist compare dir1 dir2\n</code></pre> <p>This displays a side-by-side comparison of <code>dir1</code> and <code>dir2</code> in the terminal, with differences highlighted.</p>"},{"location":"examples/compare/#saving-comparison-as-html","title":"Saving Comparison as HTML","text":"<pre><code>recursivist compare dir1 dir2 --save\n</code></pre> <p>This generates an HTML file named <code>comparison.html</code> containing the comparison.</p>"},{"location":"examples/compare/#custom-output-location","title":"Custom Output Location","text":"<pre><code>recursivist compare dir1 dir2 --save --output-dir ./reports\n</code></pre> <p>This saves the comparison to <code>./reports/comparison.html</code>.</p>"},{"location":"examples/compare/#custom-filename","title":"Custom Filename","text":"<pre><code>recursivist compare dir1 dir2 --save --prefix dir-diff\n</code></pre> <p>This saves the comparison to <code>dir-diff.html</code>.</p>"},{"location":"examples/compare/#comparison-with-file-statistics","title":"Comparison with File Statistics","text":""},{"location":"examples/compare/#comparing-with-lines-of-code","title":"Comparing with Lines of Code","text":"<pre><code>recursivist compare dir1 dir2 --sort-by-loc\n</code></pre> <p>This compares the directories with line count information, making it easy to identify differences in code volume.</p>"},{"location":"examples/compare/#comparing-with-file-sizes","title":"Comparing with File Sizes","text":"<pre><code>recursivist compare dir1 dir2 --sort-by-size\n</code></pre> <p>This compares the directories with file size information, highlighting differences in file sizes.</p>"},{"location":"examples/compare/#comparing-with-modification-times","title":"Comparing with Modification Times","text":"<pre><code>recursivist compare dir1 dir2 --sort-by-mtime\n</code></pre> <p>This compares the directories with file modification times, showing which files are newer in each directory.</p>"},{"location":"examples/compare/#combining-multiple-statistics","title":"Combining Multiple Statistics","text":"<pre><code>recursivist compare dir1 dir2 --sort-by-loc --sort-by-size\n</code></pre> <p>This combines multiple statistics in a single comparison view.</p>"},{"location":"examples/compare/#filtered-comparisons","title":"Filtered Comparisons","text":""},{"location":"examples/compare/#comparing-with-directory-exclusions","title":"Comparing with Directory Exclusions","text":"<pre><code>recursivist compare dir1 dir2 --exclude \"node_modules .git\"\n</code></pre> <p>This compares the directories while ignoring <code>node_modules</code> and <code>.git</code> directories.</p>"},{"location":"examples/compare/#comparing-with-file-extension-exclusions","title":"Comparing with File Extension Exclusions","text":"<pre><code>recursivist compare dir1 dir2 --exclude-ext \".pyc .log\"\n</code></pre> <p>This compares the directories while ignoring files with <code>.pyc</code> and <code>.log</code> extensions.</p>"},{"location":"examples/compare/#comparing-with-pattern-exclusions","title":"Comparing with Pattern Exclusions","text":"<pre><code>recursivist compare dir1 dir2 --exclude-pattern \"*.test.js\" \"*.spec.js\"\n</code></pre> <p>This compares the directories while ignoring JavaScript test files.</p>"},{"location":"examples/compare/#focusing-on-specific-files","title":"Focusing on Specific Files","text":"<pre><code>recursivist compare dir1 dir2 --include-pattern \"src/**/*.js\" \"*.md\"\n</code></pre> <p>This compares only JavaScript files in the <code>src</code> directory and markdown files.</p>"},{"location":"examples/compare/#comparing-with-gitignore-patterns","title":"Comparing with Gitignore Patterns","text":"<pre><code>recursivist compare dir1 dir2 --ignore-file .gitignore\n</code></pre> <p>This compares the directories while respecting the patterns in <code>.gitignore</code>.</p>"},{"location":"examples/compare/#depth-limited-comparisons","title":"Depth-Limited Comparisons","text":""},{"location":"examples/compare/#comparing-top-level-structure","title":"Comparing Top-Level Structure","text":"<pre><code>recursivist compare dir1 dir2 --depth 1\n</code></pre> <p>This compares only the top level of the directory structures.</p>"},{"location":"examples/compare/#comparing-with-limited-depth","title":"Comparing with Limited Depth","text":"<pre><code>recursivist compare dir1 dir2 --depth 3\n</code></pre> <p>This compares the directories up to 3 levels deep.</p>"},{"location":"examples/compare/#full-path-comparisons","title":"Full Path Comparisons","text":""},{"location":"examples/compare/#comparing-with-full-paths","title":"Comparing with Full Paths","text":"<pre><code>recursivist compare dir1 dir2 --full-path\n</code></pre> <p>This displays full file paths in the comparison instead of just filenames.</p>"},{"location":"examples/compare/#real-world-use-cases","title":"Real-World Use Cases","text":""},{"location":"examples/compare/#project-version-comparison-with-statistics","title":"Project Version Comparison with Statistics","text":"<pre><code>recursivist compare project-v1.0 project-v2.0 \\\n  --exclude \"node_modules .git\" \\\n  --exclude-ext \".log .tmp\" \\\n  --save \\\n  --output-dir ./version-reports \\\n  --prefix v1-vs-v2 \\\n  --sort-by-loc\n</code></pre> <p>This compares two versions of a project, excluding common directories and file types, saving the report with lines of code statistics.</p>"},{"location":"examples/compare/#branch-comparison-with-statistics","title":"Branch Comparison with Statistics","text":"<pre><code># Clone branches to compare\ngit clone -b main repo main-branch\ngit clone -b feature/new-feature repo feature-branch\n\n# Compare directory structures with LOC stats\nrecursivist compare main-branch feature-branch \\\n  --exclude \"node_modules .git\" \\\n  --save \\\n  --prefix branch-comparison \\\n  --sort-by-loc\n</code></pre> <p>This compares the directory structures of two Git branches with line count information.</p>"},{"location":"examples/compare/#source-vs-build-comparison-with-file-sizes","title":"Source vs. Build Comparison with File Sizes","text":"<pre><code>recursivist compare src dist \\\n  --include-pattern \"**/*.js\" \\\n  --save \\\n  --prefix src-vs-dist \\\n  --sort-by-size\n</code></pre> <p>This compares JavaScript files between source and distribution directories with file size information.</p>"},{"location":"examples/compare/#development-vs-production-configuration-comparison","title":"Development vs. Production Configuration Comparison","text":"<pre><code>recursivist compare dev-config prod-config \\\n  --save \\\n  --output-dir ./deployment-validation \\\n  --prefix dev-vs-prod \\\n  --sort-by-size\n</code></pre> <p>This compares development and production configuration directories with file size information.</p>"},{"location":"examples/compare/#specific-comparison-scenarios","title":"Specific Comparison Scenarios","text":""},{"location":"examples/compare/#code-library-upgrade-analysis","title":"Code Library Upgrade Analysis","text":"<pre><code># Extract old and new versions of a library\nmkdir -p old-lib new-lib\ntar -xzf library-1.0.tar.gz -C old-lib\ntar -xzf library-2.0.tar.gz -C new-lib\n\n# Compare library versions with LOC stats\nrecursivist compare old-lib new-lib \\\n  --exclude \"tests examples\" \\\n  --save \\\n  --prefix library-upgrade \\\n  --sort-by-loc\n</code></pre> <p>This extracts and compares two versions of a code library with lines of code metrics.</p>"},{"location":"examples/compare/#project-fork-comparison","title":"Project Fork Comparison","text":"<pre><code>recursivist compare original-project forked-project \\\n  --exclude \"node_modules .git\" \\\n  --save \\\n  --prefix fork-comparison \\\n  --sort-by-loc \\\n  --sort-by-mtime\n</code></pre> <p>This compares an original project with a forked version, showing both line count differences and when files were modified.</p>"},{"location":"examples/compare/#backup-verification-with-file-sizes","title":"Backup Verification with File Sizes","text":"<pre><code>recursivist compare original-files backup-files \\\n  --full-path \\\n  --save \\\n  --prefix backup-verification \\\n  --sort-by-size\n</code></pre> <p>This compares original files with their backups, showing full paths and file sizes to verify backup integrity.</p>"},{"location":"examples/compare/#framework-comparison-with-lines-of-code","title":"Framework Comparison with Lines of Code","text":"<pre><code>recursivist compare react-project vue-project \\\n  --include-pattern \"src/**/*\" \\\n  --exclude-pattern \"**/*.test.js\" \\\n  --save \\\n  --prefix framework-comparison \\\n  --sort-by-loc\n</code></pre> <p>This compares the source structure of projects built with different frameworks, including lines of code metrics for better comparison.</p>"},{"location":"examples/compare/#combining-with-other-tools","title":"Combining with Other Tools","text":""},{"location":"examples/compare/#comparison-and-analysis-script","title":"Comparison and Analysis Script","text":"<pre><code>#!/bin/bash\n\n# Compare projects with LOC stats\nrecursivist compare project-v1 project-v2 \\\n  --save \\\n  --prefix project-comparison \\\n  --sort-by-loc\n\n# Generate summary statistics using HTML parsing\necho \"Code changes summary:\" &gt; comparison-summary.txt\necho \"--------------------\" &gt;&gt; comparison-summary.txt\necho \"Added files:\" &gt;&gt; comparison-summary.txt\ngrep -o \"unique to this directory\" project-comparison.html | wc -l &gt;&gt; comparison-summary.txt\necho \"Removed files:\" &gt;&gt; comparison-summary.txt\ngrep -o \"unique to the other directory\" project-comparison.html | wc -l &gt;&gt; comparison-summary.txt\necho \"Total LOC in v1:\" &gt;&gt; comparison-summary.txt\ngrep -o \"Directory 1.*lines\" project-comparison.html | sed 's/.*(\\([0-9,]*\\) lines.*/\\1/' | tr -d ',' &gt;&gt; comparison-summary.txt\necho \"Total LOC in v2:\" &gt;&gt; comparison-summary.txt\ngrep -o \"Directory 2.*lines\" project-comparison.html | sed 's/.*(\\([0-9,]*\\) lines.*/\\1/' | tr -d ',' &gt;&gt; comparison-summary.txt\n\necho \"Comparison complete. See project-comparison.html and comparison-summary.txt\"\n</code></pre> <p>This script compares two projects with lines of code statistics and generates a summary of the differences.</p>"},{"location":"examples/compare/#continuous-integration-comparison-with-statistics","title":"Continuous Integration Comparison with Statistics","text":"<pre><code># Example GitHub Actions workflow\nname: Structure Comparison\n\non:\n  pull_request:\n    branches: [main]\n\njobs:\n  compare:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout main branch\n        uses: actions/checkout@v3\n        with:\n          ref: main\n          path: main-branch\n\n      - name: Checkout PR branch\n        uses: actions/checkout@v3\n        with:\n          ref: ${{ github.event.pull_request.head.ref }}\n          path: pr-branch\n\n      - name: Setup Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.10\"\n\n      - name: Install Recursivist\n        run: pip install recursivist\n\n      - name: Compare branches with statistics\n        run: |\n          recursivist compare main-branch pr-branch \\\n            --exclude \"node_modules .git\" \\\n            --save \\\n            --prefix structure-diff \\\n            --sort-by-loc \\\n            --sort-by-size\n\n      - name: Upload comparison artifact\n        uses: actions/upload-artifact@v3\n        with:\n          name: structure-comparison\n          path: structure-diff.html\n</code></pre> <p>This GitHub Actions workflow compares the directory structure between the main branch and a pull request branch, including lines of code and file size statistics.</p>"},{"location":"examples/compare/#weekly-project-evolution-report","title":"Weekly Project Evolution Report","text":"<pre><code>#!/bin/bash\n\n# Get current date for filename\ndate_str=$(date +%Y-%m-%d)\n\n# Compare current structure with last week's snapshot\nif [ -d \"snapshots/last_week\" ]; then\n  echo \"Comparing with last week's snapshot...\"\n\n  # Create comparison with LOC and modification time stats\n  recursivist compare snapshots/last_week . \\\n    --exclude \"node_modules .git snapshots\" \\\n    --save \\\n    --output-dir ./reports \\\n    --prefix \"weekly-${date_str}\" \\\n    --sort-by-loc \\\n    --sort-by-mtime\n\n  echo \"Weekly comparison saved to reports/weekly-${date_str}.html\"\nfi\n\n# Create snapshot for next week's comparison\necho \"Creating snapshot for next week's comparison...\"\nmkdir -p snapshots/last_week\ncp -a . snapshots/last_week/ 2&gt;/dev/null || true\nfind snapshots/last_week -name \"node_modules\" -type d -exec rm -rf {} +\n</code></pre> <p>This script compares the current project structure with a snapshot from the previous week, highlighting both code volume changes and when files were modified.</p>"},{"location":"examples/export/","title":"Export Examples","text":"<p>This page provides practical examples of how to use Recursivist's export functionality to save directory structures in various formats.</p>"},{"location":"examples/export/#basic-export-examples","title":"Basic Export Examples","text":""},{"location":"examples/export/#exporting-to-different-formats","title":"Exporting to Different Formats","text":""},{"location":"examples/export/#markdown-export","title":"Markdown Export","text":"<pre><code>recursivist export --format md\n</code></pre> <p>This creates <code>structure.md</code> with a markdown representation of the directory structure.</p>"},{"location":"examples/export/#json-export","title":"JSON Export","text":"<pre><code>recursivist export --format json\n</code></pre> <p>This creates <code>structure.json</code> with a JSON representation of the directory structure.</p>"},{"location":"examples/export/#html-export","title":"HTML Export","text":"<pre><code>recursivist export --format html\n</code></pre> <p>This creates <code>structure.html</code> with an interactive HTML view of the directory structure.</p>"},{"location":"examples/export/#text-export","title":"Text Export","text":"<pre><code>recursivist export --format txt\n</code></pre> <p>This creates <code>structure.txt</code> with a plain text ASCII tree representation.</p>"},{"location":"examples/export/#react-component-export","title":"React Component Export","text":"<pre><code>recursivist export --format jsx\n</code></pre> <p>This creates <code>structure.jsx</code> with a React component for interactive visualization.</p>"},{"location":"examples/export/#exporting-to-multiple-formats-simultaneously","title":"Exporting to Multiple Formats Simultaneously","text":"<pre><code>recursivist export --format \"md json html\"\n</code></pre> <p>This creates three files: <code>structure.md</code>, <code>structure.json</code>, and <code>structure.html</code>.</p>"},{"location":"examples/export/#including-file-statistics","title":"Including File Statistics","text":""},{"location":"examples/export/#exporting-with-lines-of-code-statistics","title":"Exporting with Lines of Code Statistics","text":"<pre><code>recursivist export --format md --sort-by-loc\n</code></pre> <p>This creates a markdown file with line counts for each file and directory:</p> <pre><code># \ud83d\udcc2 my-project (4328 lines)\n\n- \ud83d\udcc1 **src** (3851 lines)\n  - \ud83d\udcc4 `main.py` (245 lines)\n  - \ud83d\udcc4 `utils.py` (157 lines)\n  - \ud83d\udcc1 **tests** (653 lines)\n    - \ud83d\udcc4 `test_main.py` (412 lines)\n    - \ud83d\udcc4 `test_utils.py` (241 lines)\n- \ud83d\udcc4 `README.md` (124 lines)\n- \ud83d\udcc4 `requirements.txt` (18 lines)\n- \ud83d\udcc4 `setup.py` (65 lines)\n</code></pre>"},{"location":"examples/export/#exporting-with-file-sizes","title":"Exporting with File Sizes","text":"<pre><code>recursivist export --format html --sort-by-size\n</code></pre> <p>This creates an HTML file with file size information for each file and directory.</p>"},{"location":"examples/export/#exporting-with-modification-times","title":"Exporting with Modification Times","text":"<pre><code>recursivist export --format json --sort-by-mtime\n</code></pre> <p>This creates a JSON file that includes modification timestamps for each file and directory.</p>"},{"location":"examples/export/#combining-multiple-statistics","title":"Combining Multiple Statistics","text":"<pre><code>recursivist export --format txt --sort-by-loc --sort-by-size --sort-by-mtime\n</code></pre> <p>This combines lines of code, file sizes, and modification times in a single export.</p>"},{"location":"examples/export/#customizing-export-output","title":"Customizing Export Output","text":""},{"location":"examples/export/#custom-output-directory","title":"Custom Output Directory","text":"<pre><code>recursivist export --format md --output-dir ./docs\n</code></pre> <p>This saves the markdown export to <code>./docs/structure.md</code>.</p>"},{"location":"examples/export/#custom-filename-prefix","title":"Custom Filename Prefix","text":"<pre><code>recursivist export --format json --prefix my-project\n</code></pre> <p>This creates <code>my-project.json</code> instead of <code>structure.json</code>.</p>"},{"location":"examples/export/#combining-custom-directory-and-filename","title":"Combining Custom Directory and Filename","text":"<pre><code>recursivist export --format html --output-dir ./documentation --prefix project-structure\n</code></pre> <p>This creates <code>./documentation/project-structure.html</code>.</p>"},{"location":"examples/export/#filtered-exports","title":"Filtered Exports","text":""},{"location":"examples/export/#exporting-with-directory-exclusions","title":"Exporting with Directory Exclusions","text":"<pre><code>recursivist export --format md --exclude \"node_modules .git build\"\n</code></pre> <p>This exports a markdown representation excluding the specified directories.</p>"},{"location":"examples/export/#exporting-with-file-extension-exclusions","title":"Exporting with File Extension Exclusions","text":"<pre><code>recursivist export --format json --exclude-ext \".pyc .log .tmp\"\n</code></pre> <p>This exports a JSON representation excluding files with the specified extensions.</p>"},{"location":"examples/export/#exporting-with-pattern-exclusions","title":"Exporting with Pattern Exclusions","text":"<pre><code>recursivist export --format html --exclude-pattern \"*.test.js\" \"*.spec.js\"\n</code></pre> <p>This exports an HTML representation excluding JavaScript test files.</p>"},{"location":"examples/export/#exporting-only-specific-files","title":"Exporting Only Specific Files","text":"<pre><code>recursivist export --format md --include-pattern \"src/**/*.js\" \"*.md\"\n</code></pre> <p>This exports a markdown representation including only JavaScript files in the <code>src</code> directory and markdown files.</p>"},{"location":"examples/export/#exporting-with-gitignore-patterns","title":"Exporting with Gitignore Patterns","text":"<pre><code>recursivist export --format txt --ignore-file .gitignore\n</code></pre> <p>This exports a text representation respecting the patterns in <code>.gitignore</code>.</p>"},{"location":"examples/export/#depth-limited-exports","title":"Depth-Limited Exports","text":""},{"location":"examples/export/#exporting-with-limited-depth","title":"Exporting with Limited Depth","text":"<pre><code>recursivist export --format html --depth 2\n</code></pre> <p>This exports an HTML representation limited to 2 levels of directory depth.</p>"},{"location":"examples/export/#exporting-top-level-overview","title":"Exporting Top-Level Overview","text":"<pre><code>recursivist export --format md --depth 1\n</code></pre> <p>This exports a markdown representation showing only the top level of the directory structure.</p>"},{"location":"examples/export/#full-path-exports","title":"Full Path Exports","text":""},{"location":"examples/export/#json-export-with-full-paths","title":"JSON Export with Full Paths","text":"<pre><code>recursivist export --format json --full-path\n</code></pre> <p>This exports a JSON representation with full file paths instead of just filenames.</p>"},{"location":"examples/export/#markdown-export-with-full-paths","title":"Markdown Export with Full Paths","text":"<pre><code>recursivist export --format md --full-path\n</code></pre> <p>This exports a markdown representation with full file paths.</p>"},{"location":"examples/export/#specific-project-exports","title":"Specific Project Exports","text":""},{"location":"examples/export/#source-code-documentation-with-loc-stats","title":"Source Code Documentation with LOC Stats","text":"<pre><code>recursivist export \\\n  --format md \\\n  --include-pattern \"src/**/*\" \\\n  --exclude-pattern \"**/*.test.js\" \"**/*.spec.js\" \\\n  --output-dir ./docs \\\n  --prefix source-structure \\\n  --sort-by-loc\n</code></pre> <p>This exports a markdown representation of the source code structure with lines of code information for documentation purposes.</p>"},{"location":"examples/export/#project-overview-for-readme","title":"Project Overview for README","text":"<pre><code>recursivist export \\\n  --format md \\\n  --depth 2 \\\n  --exclude \"node_modules .git build dist\" \\\n  --prefix project-overview \\\n  --sort-by-size\n</code></pre> <p>This creates a concise project overview with file size information suitable for inclusion in a README file.</p>"},{"location":"examples/export/#react-component-export-examples","title":"React Component Export Examples","text":""},{"location":"examples/export/#basic-react-component-export","title":"Basic React Component Export","text":"<pre><code>recursivist export --format jsx --output-dir ./src/components\n</code></pre> <p>This exports a React component to <code>./src/components/structure.jsx</code>.</p>"},{"location":"examples/export/#customized-react-component-with-statistics","title":"Customized React Component with Statistics","text":"<pre><code>recursivist export \\\n  --format jsx \\\n  --include-pattern \"src/**/*\" \\\n  --exclude \"node_modules .git\" \\\n  --output-dir ./src/components \\\n  --prefix project-explorer \\\n  --sort-by-loc \\\n  --sort-by-mtime\n</code></pre> <p>This exports a filtered React component focused on the source code to <code>./src/components/project-explorer.jsx</code> with lines of code and modification time information.</p>"},{"location":"examples/export/#export-for-different-use-cases","title":"Export for Different Use Cases","text":""},{"location":"examples/export/#documentation-export-with-stats","title":"Documentation Export with Stats","text":"<pre><code>recursivist export \\\n  --format \"md html\" \\\n  --exclude \"node_modules .git build dist\" \\\n  --exclude-ext \".log .tmp .cache\" \\\n  --output-dir ./docs \\\n  --prefix project-structure \\\n  --sort-by-loc\n</code></pre> <p>This exports both markdown and HTML representations with lines of code statistics for documentation purposes.</p>"},{"location":"examples/export/#codebase-analysis-export","title":"Codebase Analysis Export","text":"<pre><code>recursivist export \\\n  --format json \\\n  --full-path \\\n  --exclude \"node_modules .git\" \\\n  --prefix codebase-structure \\\n  --sort-by-loc \\\n  --sort-by-size\n</code></pre> <p>This exports a detailed JSON representation with full paths, line counts, and file sizes for codebase analysis.</p>"},{"location":"examples/export/#website-integration-export","title":"Website Integration Export","text":"<pre><code>recursivist export \\\n  --format jsx \\\n  --exclude \"node_modules .git build dist\" \\\n  --output-dir ./website/src/components \\\n  --prefix directory-explorer \\\n  --sort-by-loc \\\n  --sort-by-mtime\n</code></pre> <p>This exports a React component with lines of code and modification time data for integration into a website.</p>"},{"location":"examples/export/#batch-export-examples","title":"Batch Export Examples","text":""},{"location":"examples/export/#multiple-export-configuration-script","title":"Multiple Export Configuration Script","text":"<p>Here's a shell script to export multiple configurations with statistics:</p> <pre><code>#!/bin/bash\n\n# Export overview\nrecursivist export \\\n  --format md \\\n  --depth 2 \\\n  --exclude \"node_modules .git\" \\\n  --output-dir ./docs \\\n  --prefix project-overview \\\n  --sort-by-loc\n\n# Export detailed structure\nrecursivist export \\\n  --format html \\\n  --exclude \"node_modules .git\" \\\n  --output-dir ./docs \\\n  --prefix detailed-structure \\\n  --sort-by-loc \\\n  --sort-by-size\n\n# Export JSON for processing\nrecursivist export \\\n  --format json \\\n  --full-path \\\n  --output-dir ./data \\\n  --prefix directory-data \\\n  --sort-by-loc \\\n  --sort-by-size\n\n# Export React component\nrecursivist export \\\n  --format jsx \\\n  --output-dir ./src/components \\\n  --prefix directory-viewer \\\n  --sort-by-loc \\\n  --sort-by-mtime\n</code></pre>"},{"location":"examples/export/#project-subdirectory-exports-with-stats","title":"Project Subdirectory Exports with Stats","text":"<p>Here's a script to export structures for each subdirectory with statistics:</p> <pre><code>#!/bin/bash\n\n# Get all immediate subdirectories\nfor dir in */; do\n  if [ -d \"$dir\" ] &amp;&amp; [ \"$dir\" != \"node_modules/\" ] &amp;&amp; [ \"$dir\" != \".git/\" ]; then\n    dir_name=$(basename \"$dir\")\n    echo \"Exporting structure for $dir_name...\"\n\n    recursivist export \"$dir\" \\\n      --format md \\\n      --output-dir ./docs/components \\\n      --prefix \"$dir_name-structure\" \\\n      --sort-by-loc \\\n      --sort-by-size\n  fi\ndone\n</code></pre>"},{"location":"examples/export/#combining-with-shell-commands","title":"Combining with Shell Commands","text":""},{"location":"examples/export/#export-and-process-with-jq","title":"Export and Process with jq","text":"<p>Export to JSON with LOC stats and process with jq to count files by type:</p> <pre><code># Export with LOC stats\nrecursivist export --format json --prefix structure --sort-by-loc\n\n# Use jq to analyze LOC data\njq -r '.structure | .. | objects | select(has(\"_files\")) |\n    ._files[] | select(type==\"object\" and has(\"loc\")) |\n    {ext: (.path | split(\".\") | .[-1]), loc: .loc} |\n    .ext + \",\" + (.loc | tostring)' structure.json | \\\n  awk -F, '{sum[$1] += $2; count[$1]++}\n    END {for (ext in sum)\n      printf \"%s files: %d lines in %d files (avg: %.1f lines/file)\\n\",\n      ext, sum[$1], count[$1], sum[$1]/count[$1]}' | \\\n  sort -k2 -nr\n</code></pre>"},{"location":"examples/export/#export-and-include-in-documentation","title":"Export and Include in Documentation","text":"<pre><code># Export with LOC stats to markdown\nrecursivist export --format md --prefix structure --sort-by-loc\n\n# Create README with project structure\necho \"# Project Structure\" &gt; README.md\necho \"\" &gt;&gt; README.md\necho \"## Directory Overview\" &gt;&gt; README.md\necho \"\" &gt;&gt; README.md\ncat structure.md &gt;&gt; README.md\n</code></pre> <p>This creates a README with the project structure including lines of code information.</p>"},{"location":"examples/filtering/","title":"Filtering Examples","text":"<p>Recursivist provides powerful filtering capabilities to help you focus on exactly the files and directories you need. This guide provides practical examples for common filtering scenarios.</p>"},{"location":"examples/filtering/#basic-exclusion-options","title":"Basic Exclusion Options","text":""},{"location":"examples/filtering/#excluding-directories","title":"Excluding Directories","text":"<p>To exclude specific directories from the visualization:</p> <pre><code>recursivist visualize --exclude \"node_modules .git venv\"\n</code></pre> <p>This excludes <code>node_modules</code>, <code>.git</code>, and <code>venv</code> directories from the output.</p> <p>You can also provide multiple <code>--exclude</code> flags:</p> <pre><code>recursivist visualize --exclude node_modules --exclude .git --exclude venv\n</code></pre>"},{"location":"examples/filtering/#excluding-file-extensions","title":"Excluding File Extensions","text":"<p>To exclude files with specific extensions:</p> <pre><code>recursivist visualize --exclude-ext \".pyc .log .cache\"\n</code></pre> <p>This excludes all files with <code>.pyc</code>, <code>.log</code>, or <code>.cache</code> extensions.</p> <p>Extensions can be specified with or without the leading dot (<code>.</code>).</p>"},{"location":"examples/filtering/#pattern-based-filtering","title":"Pattern-Based Filtering","text":""},{"location":"examples/filtering/#using-glob-patterns-default","title":"Using Glob Patterns (Default)","text":"<p>By default, Recursivist uses glob patterns for filtering:</p> <pre><code># Exclude all JavaScript test files\nrecursivist visualize --exclude-pattern \"*.test.js\" \"*.spec.js\"\n\n# Exclude Python cache files and directories\nrecursivist visualize --exclude-pattern \"__pycache__\" \"*.pyc\"\n\n# Exclude minified and bundled JavaScript\nrecursivist visualize --exclude-pattern \"*.min.js\" \"*.bundle.js\"\n</code></pre> <p>Glob pattern syntax includes:</p> <ul> <li><code>*</code>: Matches any number of characters (except <code>/</code>)</li> <li><code>?</code>: Matches a single character (except <code>/</code>)</li> <li><code>[abc]</code>: Matches one character in the brackets</li> <li><code>[!abc]</code>: Matches one character not in the brackets</li> </ul>"},{"location":"examples/filtering/#using-regular-expressions","title":"Using Regular Expressions","text":"<p>For more complex patterns, you can use regular expressions with the <code>--regex</code> flag:</p> <pre><code># Exclude files starting with \"test_\" and ending with \".py\"\nrecursivist visualize --exclude-pattern \"^test_.*\\.py$\" --regex\n\n# Exclude both JavaScript and TypeScript test files\nrecursivist visualize --exclude-pattern \".*\\.(spec|test)\\.(js|ts)x?$\" --regex\n\n# Exclude files in \"vendor\" or \"third_party\" directories\nrecursivist visualize --exclude-pattern \"^(vendor|third_party)/.*$\" --regex\n</code></pre>"},{"location":"examples/filtering/#include-patterns","title":"Include Patterns","text":"<p>Sometimes it's easier to specify what you want to include rather than what to exclude:</p> <pre><code># Show only source code files\nrecursivist visualize --include-pattern \"src/**/*.js\" \"src/**/*.ts\"\n\n# Show only documentation files\nrecursivist visualize --include-pattern \"**/*.md\" \"docs/**/*\"\n\n# Show only Python files in specific directories\nrecursivist visualize --include-pattern \"app/**/*.py\" \"lib/**/*.py\"\n</code></pre> <p>Include patterns take precedence over exclude patterns, showing only files that match at least one include pattern.</p> <p>With regex:</p> <pre><code># Show only React components\nrecursivist visualize --include-pattern \"^src/.*\\.(jsx|tsx)$\" --regex\n\n# Show only Python classes\nrecursivist visualize --include-pattern \"^.*class\\s+[A-Z][a-zA-Z0-9]*:\" --regex --content-match\n</code></pre>"},{"location":"examples/filtering/#using-gitignore-files","title":"Using Gitignore Files","text":"<p>If you have a <code>.gitignore</code> file, you can use it to filter the directory structure:</p> <pre><code>recursivist visualize --ignore-file .gitignore\n</code></pre> <p>You can also specify a different ignore file:</p> <pre><code>recursivist visualize --ignore-file .recursivist-ignore\n</code></pre> <p>Example <code>.recursivist-ignore</code> file:</p> <pre><code># Dependencies\nnode_modules/\nvenv/\n__pycache__/\n\n# Build artifacts\ndist/\nbuild/\n*.min.js\n*.bundle.js\n\n# Logs and caches\n*.log\n.cache/\n.pytest_cache/\n\n# Editor files\n.vscode/\n.idea/\n*.swp\n*~\n</code></pre>"},{"location":"examples/filtering/#combining-filtering-methods","title":"Combining Filtering Methods","text":"<p>You can combine different filtering methods for precise control:</p> <pre><code>recursivist visualize \\\n--exclude \"node_modules .git build\" \\\n--exclude-ext \".pyc .log\" \\\n--exclude-pattern \"*.test.js\" \\\n--include-pattern \"src/*\" \"*.md\" \\\n--ignore-file .gitignore\n</code></pre> <p>This powerful combination lets you:</p> <ol> <li>Exclude specific directories (<code>node_modules</code>, <code>.git</code>, <code>build</code>)</li> <li>Exclude specific file extensions (<code>.pyc</code>, <code>.log</code>)</li> <li>Exclude files matching patterns (<code>*.test.js</code>)</li> <li>Include only files in <code>src</code> and markdown files</li> <li>Also respect patterns from <code>.gitignore</code></li> </ol>"},{"location":"examples/filtering/#filter-order-of-precedence","title":"Filter Order of Precedence","text":"<p>When multiple filtering methods are used, Recursivist applies them in this order:</p> <ol> <li>Include patterns (if specified, only matching files will be considered)</li> <li>Exclude patterns (matching files are excluded)</li> <li>Excluded extensions (files with matching extensions are excluded)</li> <li>Excluded directories (directories matching these names are excluded)</li> <li>Gitignore patterns (patterns from the ignore file are applied)</li> </ol> <p>This means include patterns have the highest precedence and can override all other exclusions.</p>"},{"location":"examples/filtering/#language-specific-examples","title":"Language-Specific Examples","text":""},{"location":"examples/filtering/#python-project","title":"Python Project","text":"<pre><code>recursivist visualize \\\n--exclude \"__pycache__ .pytest_cache .venv venv\" \\\n--exclude-ext \".pyc .pyo .coverage\" \\\n--exclude-pattern \"test_*.py\" \\\n--ignore-file .gitignore\n</code></pre>"},{"location":"examples/filtering/#javascripttypescript-project","title":"JavaScript/TypeScript Project","text":"<pre><code>recursivist visualize \\\n--exclude \"node_modules .git dist build coverage\" \\\n--exclude-ext \".map .log\" \\\n--exclude-pattern \"*.test.js\" \"*.spec.ts\" \"*.min.js\" \\\n--ignore-file .gitignore\n</code></pre>"},{"location":"examples/filtering/#javamaven-project","title":"Java/Maven Project","text":"<pre><code>recursivist visualize \\\n--exclude \"target .git .idea\" \\\n--exclude-ext \".class .jar\" \\\n--exclude-pattern \"*Test.java\" \\\n--ignore-file .gitignore\n</code></pre>"},{"location":"examples/filtering/#ruby-on-rails-project","title":"Ruby on Rails Project","text":"<pre><code>recursivist visualize \\\n--exclude \".git vendor tmp log coverage\" \\\n--exclude-ext \".log\" \\\n--exclude-pattern \"*_spec.rb\" \"*_test.rb\" \\\n--ignore-file .gitignore\n</code></pre>"},{"location":"examples/filtering/#task-specific-filtering","title":"Task-Specific Filtering","text":""},{"location":"examples/filtering/#code-review-focus","title":"Code Review Focus","text":"<p>Show only files that changed in a branch:</p> <pre><code># Get changed files\nchanged_files=$(git diff --name-only main)\n\n# Create include patterns\ninclude_patterns=\"\"\nfor file in $changed_files; do\n    include_patterns+=\" \\\"$file\\\"\"\ndone\n\n# Visualize only changed files\neval \"recursivist visualize --include-pattern $include_patterns\"\n</code></pre>"},{"location":"examples/filtering/#documentation-overview","title":"Documentation Overview","text":"<p>Display only documentation files across the project:</p> <pre><code>recursivist visualize \\\n--include-pattern \"**/*.md\" \"**/*.rst\" \"**/*.txt\" \"docs/**/*\" \\\n--sort-by-mtime\n</code></pre>"},{"location":"examples/filtering/#security-audit","title":"Security Audit","text":"<p>Focus on configuration and security-related files:</p> <pre><code>recursivist visualize \\\n--include-pattern \"**/*.json\" \"**/*.yml\" \"**/*.yaml\" \"**/*.config.*\" \\\n--include-pattern \"**/security/**/*\" \"**/*.env.*\" \"Dockerfile*\" \\\n--sort-by-mtime\n</code></pre>"},{"location":"examples/filtering/#performance-analysis","title":"Performance Analysis","text":"<p>Identify large files that might cause performance issues:</p> <pre><code>recursivist visualize \\\n--exclude \"node_modules .git dist\" \\\n--sort-by-size\n</code></pre>"},{"location":"examples/filtering/#using-filters-with-export","title":"Using Filters with Export","text":"<p>All filtering options work with the <code>export</code> command:</p> <pre><code>recursivist export \\\n--format md \\\n--exclude \"node_modules .git\" \\\n--exclude-ext \".log\" \\\n--include-pattern \"src/**/*\" \"docs/**/*\" \\\n--output-dir ./reports \\\n--prefix filtered-structure\n</code></pre>"},{"location":"examples/filtering/#using-filters-with-compare","title":"Using Filters with Compare","text":"<p>Filtering also works with the <code>compare</code> command:</p> <pre><code>recursivist compare dir1 dir2 \\\n--exclude \"node_modules .git\" \\\n--exclude-ext \".log .tmp\" \\\n--exclude-pattern \"*.min.js\" \\\n--save \\\n--output-dir ./reports \\\n--prefix filtered-comparison\n</code></pre>"},{"location":"examples/filtering/#advanced-pattern-examples","title":"Advanced Pattern Examples","text":""},{"location":"examples/filtering/#frontend-files-only","title":"Frontend Files Only","text":"<pre><code>recursivist visualize \\\n--include-pattern \"**/*.js\" \"**/*.ts\" \"**/*.jsx\" \"**/*.tsx\" \"**/*.css\" \"**/*.scss\" \"**/*.html\"\n</code></pre>"},{"location":"examples/filtering/#backend-files-only","title":"Backend Files Only","text":"<pre><code>recursivist visualize \\\n--include-pattern \"**/*.py\" \"**/*.java\" \"**/*.go\" \"**/*.rb\" \"**/*.php\" \"**/*.sql\"\n</code></pre>"},{"location":"examples/filtering/#configuration-files-only","title":"Configuration Files Only","text":"<pre><code>recursivist visualize \\\n--include-pattern \"**/*.json\" \"**/*.yml\" \"**/*.yaml\" \"**/*.toml\" \"**/*.ini\" \"**/*.xml\" \"**/*.config.*\"\n</code></pre>"},{"location":"examples/filtering/#feature-specific-files","title":"Feature-Specific Files","text":"<p>Focus on files related to a specific feature:</p> <pre><code>recursivist visualize \\\n--include-pattern \"**/auth/**/*\" \"**/login/**/*\" \"**/security/**/*\"\n</code></pre>"},{"location":"examples/filtering/#exclude-generated-code","title":"Exclude Generated Code","text":"<pre><code>recursivist visualize \\\n--exclude-pattern \"**/*.g.dart\" \"**/*.generated.*\" \"**/generated/**/*\"\n</code></pre>"},{"location":"examples/filtering/#focus-on-recently-modified-files","title":"Focus on Recently Modified Files","text":"<p>Show only files modified in the last week:</p> <pre><code># Create a temporary file with recently modified paths\nfind . -type f -mtime -7 | grep -v \"node_modules\\|.git\" &gt; recent_files.txt\n\n# Use these files as include patterns\ninclude_patterns=$(cat recent_files.txt | sed 's/^.//' | xargs -I{} echo -n \" \\\"{}\\\"\")\neval \"recursivist visualize --include-pattern $include_patterns --sort-by-mtime\"\n\n# Clean up\nrm recent_files.txt\n</code></pre>"},{"location":"examples/filtering/#combining-with-file-statistics","title":"Combining with File Statistics","text":"<p>Combining filtering with file statistics provides powerful insights:</p> <pre><code># Find large source files\nrecursivist visualize \\\n--include-pattern \"src/**/*.js\" \\\n--sort-by-size\n\n# Identify complex modules\nrecursivist visualize \\\n--include-pattern \"src/**/*.py\" \\\n--exclude-pattern \"**/*test*.py\" \\\n--sort-by-loc\n\n# Examine recent changes to specific components\nrecursivist visualize \\\n--include-pattern \"src/components/**/*.jsx\" \\\n--sort-by-mtime\n</code></pre>"},{"location":"examples/filtering/#shell-script-for-filtered-analysis","title":"Shell Script for Filtered Analysis","text":"<p>This script demonstrates how to use filtering for targeted code analysis:</p> <pre><code>#!/bin/bash\n\n# Function to analyze specific parts of a codebase\nanalyze_section() {\n    section_name=$1\n    include_patterns=$2\n    exclude_patterns=$3\n\n    echo \"=== Analyzing $section_name ===\"\n    echo \"\"\n\n    # Create directory for output\n    mkdir -p analysis/$section_name\n\n    # Build the command with appropriate options\n    cmd=\"recursivist export\"\n    cmd+=\" --format json\"\n    cmd+=\" --output-dir ./analysis/$section_name\"\n    cmd+=\" --prefix structure\"\n    cmd+=\" --sort-by-loc --sort-by-size\"\n\n    # Add include patterns if provided\n    if [ -n \"$include_patterns\" ]; then\n        for pattern in $include_patterns; do\n            cmd+=\" --include-pattern \\\"$pattern\\\"\"\n        done\n    fi\n\n    # Add exclude patterns if provided\n    if [ -n \"$exclude_patterns\" ]; then\n        for pattern in $exclude_patterns; do\n            cmd+=\" --exclude-pattern \\\"$pattern\\\"\"\n        done\n    fi\n\n    # Execute command\n    eval $cmd\n\n    echo \"Analysis for $section_name complete!\"\n    echo \"\"\n}\n\n# Create analysis directory\nmkdir -p analysis\n\n# Analyze different sections of the codebase\nanalyze_section \"frontend\" \"src/frontend/**/*\" \"**/*.test.*\"\nanalyze_section \"backend\" \"src/backend/**/*\" \"**/*.test.*\"\nanalyze_section \"tests\" \"**/*.test.* **/*_test.* **/test_*.*\" \"\"\nanalyze_section \"documentation\" \"**/*.md docs/**/*\" \"\"\n\necho \"All analyses complete! Results in ./analysis directory.\"\n</code></pre> <p>By mastering Recursivist's filtering capabilities, you can create highly focused views of your project structure, making it easier to understand, document, and analyze specific aspects of your codebase.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Recursivist is available on PyPI and can be installed with pip, the Python package manager.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.7 or higher</li> <li>pip (Python package manager)</li> </ul>"},{"location":"getting-started/installation/#installing-from-pypi","title":"Installing from PyPI","text":"<p>The recommended way to install Recursivist is through PyPI:</p> <pre><code>pip install recursivist\n</code></pre> <p>This will install Recursivist and all of its dependencies, including:</p> <ul> <li>Rich - For beautiful terminal formatting and colored output</li> <li>Typer - For the intuitive CLI interface</li> </ul>"},{"location":"getting-started/installation/#installing-from-source","title":"Installing from Source","text":"<p>For the latest development version or if you want to contribute to the project, you can install Recursivist directly from the source code:</p> <pre><code>git clone https://github.com/ArmaanjeetSandhu/recursivist.git\ncd recursivist\npip install -e .\n</code></pre> <p>The <code>-e</code> flag installs the package in \"editable\" mode, which means changes to the source code will be reflected in the installed package without needing to reinstall.</p>"},{"location":"getting-started/installation/#installing-for-development","title":"Installing for Development","text":"<p>If you plan to contribute to Recursivist, you should install the development dependencies:</p> <pre><code>git clone https://github.com/ArmaanjeetSandhu/recursivist.git\ncd recursivist\npip install -e \".[dev]\"\n</code></pre> <p>This installs Recursivist along with all the development tools, such as pytest for testing.</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, you can verify that Recursivist was installed correctly by checking its version:</p> <pre><code>recursivist version\n</code></pre> <p>You should see the current version of Recursivist displayed.</p>"},{"location":"getting-started/installation/#system-specific-notes","title":"System-specific Notes","text":""},{"location":"getting-started/installation/#windows","title":"Windows","text":"<p>On Windows, it's recommended to use a virtual environment:</p> <pre><code>python -m venv venv\n.\\venv\\Scripts\\activate\npip install recursivist\n</code></pre> <p>For the best experience on Windows, use a terminal that supports Unicode and ANSI colors, such as Windows Terminal.</p>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<p>On macOS, if you're using Homebrew's Python, you might need to use:</p> <pre><code>python3 -m pip install recursivist\n</code></pre>"},{"location":"getting-started/installation/#linux","title":"Linux","text":"<p>On Linux, you might need to install Python development headers first:</p> <pre><code># Debian-based systems (Ubuntu, etc.)\nsudo apt-get install python3-dev\n\n# Red Hat-based systems (Fedora, CentOS, etc.)\nsudo dnf install python3-devel\n\n# Then install Recursivist\npip3 install recursivist\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting-installation-issues","title":"Troubleshooting Installation Issues","text":""},{"location":"getting-started/installation/#unicode-display-problems","title":"Unicode Display Problems","text":"<p>If you see squares or question marks instead of emoji icons in the output:</p> <ol> <li>Ensure your terminal supports Unicode</li> <li>Check that you're using a font that includes emoji characters</li> <li>On Windows, make sure you're using Windows Terminal or another modern terminal</li> </ol>"},{"location":"getting-started/installation/#color-display-issues","title":"Color Display Issues","text":"<p>If colors aren't displaying correctly:</p> <ol> <li>Ensure your terminal supports ANSI colors</li> <li>Check if you need to enable color support in your terminal settings</li> <li>Try running with the <code>TERM=xterm-256color</code> environment variable</li> </ol>"},{"location":"getting-started/installation/#missing-dependencies","title":"Missing Dependencies","text":"<p>If you encounter missing dependency errors:</p> <pre><code># Try reinstalling with the --force-reinstall flag\npip install --force-reinstall recursivist\n\n# Or specify the dependencies explicitly\npip install rich typer\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have Recursivist installed, check out the Quick Start Guide to begin visualizing directory structures.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start Guide","text":"<p>This guide will help you quickly get started with Recursivist, a powerful directory structure visualization tool.</p>"},{"location":"getting-started/quick-start/#basic-commands","title":"Basic Commands","text":"<p>After installing Recursivist, you can start using it right away. Here are the basic commands:</p>"},{"location":"getting-started/quick-start/#visualize-a-directory","title":"Visualize a Directory","text":"<p>To visualize the current directory structure:</p> <pre><code>recursivist visualize\n</code></pre> <p>This will display a colorful tree representation of the current directory in your terminal.</p> <p>To visualize a specific directory:</p> <pre><code>recursivist visualize /path/to/your/directory\n</code></pre>"},{"location":"getting-started/quick-start/#display-file-statistics","title":"Display File Statistics","text":"<p>Recursivist can show and sort by various file statistics:</p> <pre><code># Show lines of code\nrecursivist visualize --sort-by-loc\n\n# Show file sizes\nrecursivist visualize --sort-by-size\n\n# Show modification times\nrecursivist visualize --sort-by-mtime\n\n# Combine multiple statistics\nrecursivist visualize --sort-by-loc --sort-by-size\n</code></pre>"},{"location":"getting-started/quick-start/#export-a-directory-structure","title":"Export a Directory Structure","text":"<p>To export the current directory structure to various formats:</p> <pre><code># Export to Markdown\nrecursivist export --format md\n\n# Export to HTML\nrecursivist export --format html\n\n# Export to JSON\nrecursivist export --format json\n\n# Export to plain text\nrecursivist export --format txt\n\n# Export to React component\nrecursivist export --format jsx\n</code></pre>"},{"location":"getting-started/quick-start/#compare-two-directories","title":"Compare Two Directories","text":"<p>To compare two directory structures side by side:</p> <pre><code>recursivist compare dir1 dir2\n</code></pre> <p>This will display both directory trees with highlighted differences.</p> <p>To save the comparison as an HTML file:</p> <pre><code>recursivist compare dir1 dir2 --save\n</code></pre>"},{"location":"getting-started/quick-start/#common-options","title":"Common Options","text":"<p>Here are some common options that you can use with Recursivist commands:</p>"},{"location":"getting-started/quick-start/#exclude-directories","title":"Exclude Directories","text":"<p>To exclude specific directories (like <code>node_modules</code> or <code>.git</code>):</p> <pre><code>recursivist visualize --exclude \"node_modules .git\"\n</code></pre>"},{"location":"getting-started/quick-start/#exclude-file-extensions","title":"Exclude File Extensions","text":"<p>To exclude files with specific extensions (like <code>.pyc</code> or <code>.log</code>):</p> <pre><code>recursivist visualize --exclude-ext \".pyc .log\"\n</code></pre>"},{"location":"getting-started/quick-start/#pattern-filtering","title":"Pattern Filtering","text":"<p>To exclude files matching specific patterns:</p> <pre><code># Using glob patterns (default)\nrecursivist visualize --exclude-pattern \"*.test.js\" \"*.spec.js\"\n\n# Using regular expressions\nrecursivist visualize --exclude-pattern \"^test_.*\\.py$\" --regex\n</code></pre> <p>To include only specific files:</p> <pre><code>recursivist visualize --include-pattern \"src/**/*.js\" \"*.md\"\n</code></pre>"},{"location":"getting-started/quick-start/#limit-directory-depth","title":"Limit Directory Depth","text":"<p>To limit the depth of the directory tree (useful for large projects):</p> <pre><code>recursivist visualize --depth 3\n</code></pre>"},{"location":"getting-started/quick-start/#show-full-paths","title":"Show Full Paths","text":"<p>To show full paths instead of just filenames:</p> <pre><code>recursivist visualize --full-path\n</code></pre>"},{"location":"getting-started/quick-start/#quick-examples","title":"Quick Examples","text":""},{"location":"getting-started/quick-start/#basic-directory-visualization","title":"Basic Directory Visualization","text":"<pre><code>recursivist visualize\n</code></pre> <p>This will produce output similar to:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py\n\u251c\u2500\u2500 \ud83d\udcc4 README.md\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py\n</code></pre>"},{"location":"getting-started/quick-start/#visualizing-with-file-statistics","title":"Visualizing with File Statistics","text":"<pre><code>recursivist visualize --sort-by-loc\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (4328 lines)\n\u251c\u2500\u2500 \ud83d\udcc1 src (3851 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (245 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (157 lines)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests (653 lines)\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py (412 lines)\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py (241 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md (124 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt (18 lines)\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py (65 lines)\n</code></pre>"},{"location":"getting-started/quick-start/#export-to-multiple-formats","title":"Export to Multiple Formats","text":"<pre><code>recursivist export \\\n--format \"txt md json\" \\\n--output-dir ./exports \\\n--prefix project-structure\n</code></pre> <p>This exports the directory structure to text, markdown, and JSON formats in the <code>./exports</code> directory.</p>"},{"location":"getting-started/quick-start/#compare-with-exclusions","title":"Compare with Exclusions","text":"<pre><code>recursivist compare dir1 dir2 \\\n--exclude node_modules \\\n--exclude-ext .pyc\n</code></pre> <p>This compares two directories while ignoring <code>node_modules</code> directories and <code>.pyc</code> files.</p>"},{"location":"getting-started/quick-start/#compare-with-file-statistics","title":"Compare with File Statistics","text":"<pre><code>recursivist compare dir1 dir2 --sort-by-size\n</code></pre> <p>This compares two directories with file sizes displayed, making it easy to see size differences between the two directories.</p>"},{"location":"getting-started/quick-start/#shell-completion","title":"Shell Completion","text":"<p>Generate shell completion scripts for easier command usage:</p> <pre><code># For Bash\nrecursivist completion bash &gt; ~/.bash_completion.d/recursivist\nsource ~/.bash_completion.d/recursivist\n\n# For Zsh, Fish, or PowerShell\nrecursivist completion zsh|fish|powershell\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Learn more about visualization options</li> <li>Explore pattern filtering for precise control</li> <li>Check out the various export formats</li> <li>See the complete CLI reference for all available options</li> <li>Discover advanced examples for sophisticated usage patterns</li> </ul>"},{"location":"reference/api-reference/","title":"API Reference","text":"<p>This page provides documentation for Recursivist's Python API, automatically generated from the source code's docstrings, which can be used to integrate directory visualization and analysis capabilities into your own Python applications.</p>"},{"location":"reference/api-reference/#core-module","title":"Core Module","text":""},{"location":"reference/api-reference/#recursivist.core","title":"<code>recursivist.core</code>","text":"<p>Core functionality for the Recursivist directory visualization tool.</p> <p>This module provides the fundamental components for building, filtering, displaying, and exporting directory structures. It handles directory traversal, pattern matching, color coding, file statistics calculation, and tree construction.</p> <p>Key components: - Directory structure parsing and representation - Pattern-based filtering (gitignore, glob, regex) - File extension color coding - Tree visualization with rich formatting - Lines of code counting - File size calculation and formatting - Modification time retrieval and formatting - Maximum depth limiting</p>"},{"location":"reference/api-reference/#recursivist.core.build_tree","title":"<code>build_tree(structure, tree, color_map, parent_name='Root', show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Build the tree structure with colored file names.</p> <p>Recursively builds a rich.Tree representation of the directory structure with files color-coded by extension. When sort_by_loc is True, displays lines of code counts for files and directories. When sort_by_size is True, displays file sizes for files and directories. When sort_by_mtime is True, displays file modification times.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Dict</code> <p>Dictionary representation of the directory structure</p> required <code>tree</code> <code>Tree</code> <p>Rich Tree object to build upon</p> required <code>color_map</code> <code>Dict[str, str]</code> <p>Mapping of file extensions to colors</p> required <code>parent_name</code> <code>str</code> <p>Name of the parent directory</p> <code>'Root'</code> <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to display lines of code counts</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to display file sizes</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to display file modification times</p> <code>False</code> Source code in <code>recursivist/core.py</code> <pre><code>def build_tree(\n    structure: Dict,\n    tree: Tree,\n    color_map: Dict[str, str],\n    parent_name: str = \"Root\",\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; None:\n    \"\"\"Build the tree structure with colored file names.\n\n    Recursively builds a rich.Tree representation of the directory structure with files color-coded by extension.\n    When sort_by_loc is True, displays lines of code counts for files and directories.\n    When sort_by_size is True, displays file sizes for files and directories.\n    When sort_by_mtime is True, displays file modification times.\n\n    Args:\n        structure: Dictionary representation of the directory structure\n        tree: Rich Tree object to build upon\n        color_map: Mapping of file extensions to colors\n        parent_name: Name of the parent directory\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to display lines of code counts\n        sort_by_size: Whether to display file sizes\n        sort_by_mtime: Whether to display file modification times\n    \"\"\"\n\n    for folder, content in sorted(structure.items()):\n        if folder == \"_files\":\n            for file_item in sort_files_by_type(\n                content, sort_by_loc, sort_by_size, sort_by_mtime\n            ):\n                if (\n                    sort_by_loc\n                    and sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 4\n                ):\n                    file_name, display_path, loc, size, mtime = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\",\n                        style=color,\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_loc\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, _, mtime = file_item\n                    else:\n                        file_name, display_path, loc, mtime = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({loc} lines, {format_timestamp(mtime)})\",\n                        style=color,\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, size, mtime = file_item\n                    else:\n                        file_name, display_path, size, mtime = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({format_size(size)}, {format_timestamp(mtime)})\",\n                        style=color,\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_loc\n                    and sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, size, _ = file_item\n                    else:\n                        file_name, display_path, loc, size = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({loc} lines, {format_size(size)})\",\n                        style=color,\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, _, mtime = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, _, mtime = file_item\n                    else:\n                        file_name, display_path, mtime = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({format_timestamp(mtime)})\",\n                        style=color,\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_size and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, size, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, _, size = file_item\n                    else:\n                        file_name, display_path, size = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({format_size(size)})\",\n                        style=color,\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_loc and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, loc, _ = file_item\n                    else:\n                        file_name, display_path, loc = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({loc} lines)\",\n                        style=color,\n                    )\n                    tree.add(colored_text)\n                elif show_full_path and isinstance(file_item, tuple):\n                    if len(file_item) &gt; 4:\n                        file_name, full_path, _, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, full_path, _, _ = file_item\n                    elif len(file_item) &gt; 2:\n                        file_name, full_path, _ = file_item\n                    else:\n                        file_name, full_path = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(f\"\ud83d\udcc4 {full_path}\", style=color)\n                    tree.add(colored_text)\n                else:\n                    if isinstance(file_item, tuple):\n                        if len(file_item) &gt; 4:\n                            file_name, _, _, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            file_name, _, _, _ = file_item\n                        elif len(file_item) &gt; 2:\n                            file_name, _, _ = file_item\n                        else:\n                            file_name, _ = file_item\n                    else:\n                        file_name = cast(str, file_item)\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(f\"\ud83d\udcc4 {file_name}\", style=color)\n                    tree.add(colored_text)\n        elif (\n            folder == \"_loc\"\n            or folder == \"_size\"\n            or folder == \"_mtime\"\n            or folder == \"_max_depth_reached\"\n        ):\n            pass\n        else:\n            folder_display = f\"\ud83d\udcc1 {folder}\"\n            if (\n                sort_by_loc\n                and sort_by_size\n                and sort_by_mtime\n                and isinstance(content, dict)\n            ):\n                if \"_loc\" in content and \"_size\" in content and \"_mtime\" in content:\n                    folder_loc = content[\"_loc\"]\n                    folder_size = content[\"_size\"]\n                    folder_mtime = content[\"_mtime\"]\n                    folder_display = f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_size(folder_size)}, {format_timestamp(folder_mtime)})\"\n            elif sort_by_loc and sort_by_size and isinstance(content, dict):\n                if \"_loc\" in content and \"_size\" in content:\n                    folder_loc = content[\"_loc\"]\n                    folder_size = content[\"_size\"]\n                    folder_display = (\n                        f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_size(folder_size)})\"\n                    )\n            elif sort_by_loc and sort_by_mtime and isinstance(content, dict):\n                if \"_loc\" in content and \"_mtime\" in content:\n                    folder_loc = content[\"_loc\"]\n                    folder_mtime = content[\"_mtime\"]\n                    folder_display = f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_timestamp(folder_mtime)})\"\n            elif sort_by_size and sort_by_mtime and isinstance(content, dict):\n                if \"_size\" in content and \"_mtime\" in content:\n                    folder_size = content[\"_size\"]\n                    folder_mtime = content[\"_mtime\"]\n                    folder_display = f\"\ud83d\udcc1 {folder} ({format_size(folder_size)}, {format_timestamp(folder_mtime)})\"\n            elif sort_by_loc and isinstance(content, dict) and \"_loc\" in content:\n                folder_loc = content[\"_loc\"]\n                folder_display = f\"\ud83d\udcc1 {folder} ({folder_loc} lines)\"\n            elif sort_by_size and isinstance(content, dict) and \"_size\" in content:\n                folder_size = content[\"_size\"]\n                folder_display = f\"\ud83d\udcc1 {folder} ({format_size(folder_size)})\"\n            elif sort_by_mtime and isinstance(content, dict) and \"_mtime\" in content:\n                folder_mtime = content[\"_mtime\"]\n                folder_display = f\"\ud83d\udcc1 {folder} ({format_timestamp(folder_mtime)})\"\n            subtree = tree.add(folder_display)\n            if isinstance(content, dict) and content.get(\"_max_depth_reached\"):\n                subtree.add(Text(\"\u22ef (max depth reached)\", style=\"dim\"))\n            else:\n                build_tree(\n                    content,\n                    subtree,\n                    color_map,\n                    folder,\n                    show_full_path,\n                    sort_by_loc,\n                    sort_by_size,\n                    sort_by_mtime,\n                )\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.compile_regex_patterns","title":"<code>compile_regex_patterns(patterns, is_regex=False)</code>","text":"<p>Convert patterns to compiled regex objects when appropriate.</p> <p>When is_regex is True, compiles string patterns into regex pattern objects for efficient matching. For invalid regex patterns, logs a warning and keeps them as strings.</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>Sequence[str]</code> <p>List of patterns to compile</p> required <code>is_regex</code> <code>bool</code> <p>Whether the patterns should be treated as regex (True) or glob patterns (False)</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[str, Pattern[str]]]</code> <p>List of patterns (strings for glob patterns or compiled regex objects)</p> Source code in <code>recursivist/core.py</code> <pre><code>def compile_regex_patterns(\n    patterns: Sequence[str], is_regex: bool = False\n) -&gt; List[Union[str, Pattern[str]]]:\n    \"\"\"Convert patterns to compiled regex objects when appropriate.\n\n    When is_regex is True, compiles string patterns into regex pattern objects for efficient matching.\n    For invalid regex patterns, logs a warning and keeps them as strings.\n\n    Args:\n        patterns: List of patterns to compile\n        is_regex: Whether the patterns should be treated as regex (True) or glob patterns (False)\n\n    Returns:\n        List of patterns (strings for glob patterns or compiled regex objects)\n    \"\"\"\n\n    if not is_regex:\n        return cast(List[Union[str, Pattern[str]]], patterns)\n    compiled_patterns: List[Union[str, Pattern[str]]] = []\n    for pattern in patterns:\n        try:\n            compiled_patterns.append(re.compile(pattern))\n        except re.error as e:\n            logger.warning(f\"Invalid regex pattern '{pattern}': {e}\")\n            compiled_patterns.append(pattern)\n    return compiled_patterns\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.count_lines_of_code","title":"<code>count_lines_of_code(file_path)</code>","text":"<p>Count the number of lines in a file.</p> <p>Counts lines in text files while handling encoding issues and skipping binary files.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of lines in the file, or 0 if the file cannot be read or is binary</p> Source code in <code>recursivist/core.py</code> <pre><code>def count_lines_of_code(file_path: str) -&gt; int:\n    \"\"\"Count the number of lines in a file.\n\n    Counts lines in text files while handling encoding issues and skipping binary files.\n\n    Args:\n        file_path: Path to the file\n\n    Returns:\n        Number of lines in the file, or 0 if the file cannot be read or is binary\n    \"\"\"\n\n    try:\n        with open(file_path, \"rb\") as f:\n            sample = f.read(1024)\n            if b\"\\0\" in sample:\n                logger.debug(f\"Skipping binary file: {file_path}\")\n                return 0\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"replace\") as f:\n            return sum(1 for _ in f)\n    except Exception as e:\n        logger.debug(f\"Could not count lines in {file_path}: {e}\")\n        return 0\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.display_tree","title":"<code>display_tree(root_dir, exclude_dirs=None, ignore_file=None, exclude_extensions=None, exclude_patterns=None, include_patterns=None, use_regex=False, max_depth=0, show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Display a directory tree in the terminal with rich formatting.</p> <p>Presents a directory structure as a tree with: - Color-coded file extensions - Optional statistics (lines of code, sizes, modification times) - Filtered content based on exclusion patterns - Depth limitations if specified</p> <p>This function handles the entire process from scanning the directory to displaying the final tree visualization.</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>str</code> <p>Root directory path to display</p> required <code>exclude_dirs</code> <code>Optional[List[str]]</code> <p>List of directory names to exclude</p> <code>None</code> <code>ignore_file</code> <code>Optional[str]</code> <p>Name of ignore file (like .gitignore)</p> <code>None</code> <code>exclude_extensions</code> <code>Optional[Set[str]]</code> <p>Set of file extensions to exclude</p> <code>None</code> <code>exclude_patterns</code> <code>Optional[List[str]]</code> <p>List of patterns to exclude</p> <code>None</code> <code>include_patterns</code> <code>Optional[List[str]]</code> <p>List of patterns to include (overrides exclusions)</p> <code>None</code> <code>use_regex</code> <code>bool</code> <p>Whether to treat patterns as regex instead of glob patterns</p> <code>False</code> <code>max_depth</code> <code>int</code> <p>Maximum depth to display (0 for unlimited)</p> <code>0</code> <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to show and sort by lines of code</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to show and sort by file size</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to show and sort by modification time</p> <code>False</code> Source code in <code>recursivist/core.py</code> <pre><code>def display_tree(\n    root_dir: str,\n    exclude_dirs: Optional[List[str]] = None,\n    ignore_file: Optional[str] = None,\n    exclude_extensions: Optional[Set[str]] = None,\n    exclude_patterns: Optional[List[str]] = None,\n    include_patterns: Optional[List[str]] = None,\n    use_regex: bool = False,\n    max_depth: int = 0,\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; None:\n    \"\"\"Display a directory tree in the terminal with rich formatting.\n\n    Presents a directory structure as a tree with:\n    - Color-coded file extensions\n    - Optional statistics (lines of code, sizes, modification times)\n    - Filtered content based on exclusion patterns\n    - Depth limitations if specified\n\n    This function handles the entire process from scanning the directory to displaying the final tree visualization.\n\n    Args:\n        root_dir: Root directory path to display\n        exclude_dirs: List of directory names to exclude\n        ignore_file: Name of ignore file (like .gitignore)\n        exclude_extensions: Set of file extensions to exclude\n        exclude_patterns: List of patterns to exclude\n        include_patterns: List of patterns to include (overrides exclusions)\n        use_regex: Whether to treat patterns as regex instead of glob patterns\n        max_depth: Maximum depth to display (0 for unlimited)\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to show and sort by lines of code\n        sort_by_size: Whether to show and sort by file size\n        sort_by_mtime: Whether to show and sort by modification time\n    \"\"\"\n\n    if exclude_dirs is None:\n        exclude_dirs = []\n    if exclude_extensions is None:\n        exclude_extensions = set()\n    if exclude_patterns is None:\n        exclude_patterns = []\n    if include_patterns is None:\n        include_patterns = []\n    exclude_extensions = {\n        ext.lower() if ext.startswith(\".\") else f\".{ext.lower()}\"\n        for ext in exclude_extensions\n    }\n    compiled_exclude = compile_regex_patterns(exclude_patterns, use_regex)\n    compiled_include = compile_regex_patterns(include_patterns, use_regex)\n    structure, extensions = get_directory_structure(\n        root_dir,\n        exclude_dirs,\n        ignore_file,\n        exclude_extensions,\n        exclude_patterns=compiled_exclude,\n        include_patterns=compiled_include,\n        max_depth=max_depth,\n        show_full_path=show_full_path,\n        sort_by_loc=sort_by_loc,\n        sort_by_size=sort_by_size,\n        sort_by_mtime=sort_by_mtime,\n    )\n    color_map = {ext: generate_color_for_extension(ext) for ext in extensions}\n    console = Console()\n    root_label = f\"\ud83d\udcc2 {os.path.basename(root_dir)}\"\n    if (\n        sort_by_loc\n        and sort_by_size\n        and sort_by_mtime\n        and \"_loc\" in structure\n        and \"_size\" in structure\n        and \"_mtime\" in structure\n    ):\n        root_label = f\"\ud83d\udcc2 {os.path.basename(root_dir)} ({structure['_loc']} lines, {format_size(structure['_size'])}, {format_timestamp(structure['_mtime'])})\"\n    elif sort_by_loc and sort_by_size and \"_loc\" in structure and \"_size\" in structure:\n        root_label = f\"\ud83d\udcc2 {os.path.basename(root_dir)} ({structure['_loc']} lines, {format_size(structure['_size'])})\"\n    elif (\n        sort_by_loc and sort_by_mtime and \"_loc\" in structure and \"_mtime\" in structure\n    ):\n        root_label = f\"\ud83d\udcc2 {os.path.basename(root_dir)} ({structure['_loc']} lines, {format_timestamp(structure['_mtime'])})\"\n    elif (\n        sort_by_size\n        and sort_by_mtime\n        and \"_size\" in structure\n        and \"_mtime\" in structure\n    ):\n        root_label = f\"\ud83d\udcc2 {os.path.basename(root_dir)} ({format_size(structure['_size'])}, {format_timestamp(structure['_mtime'])})\"\n    elif sort_by_loc and \"_loc\" in structure:\n        root_label = f\"\ud83d\udcc2 {os.path.basename(root_dir)} ({structure['_loc']} lines)\"\n    elif sort_by_size and \"_size\" in structure:\n        root_label = (\n            f\"\ud83d\udcc2 {os.path.basename(root_dir)} ({format_size(structure['_size'])})\"\n        )\n    elif sort_by_mtime and \"_mtime\" in structure:\n        root_label = (\n            f\"\ud83d\udcc2 {os.path.basename(root_dir)} ({format_timestamp(structure['_mtime'])})\"\n        )\n    tree = Tree(root_label)\n    build_tree(\n        structure,\n        tree,\n        color_map,\n        show_full_path=show_full_path,\n        sort_by_loc=sort_by_loc,\n        sort_by_size=sort_by_size,\n        sort_by_mtime=sort_by_mtime,\n    )\n    console.print(tree)\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.export_structure","title":"<code>export_structure(structure, root_dir, format_type, output_path, show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Export the directory structure to various formats.</p> <p>Maps the requested format to the appropriate export method using DirectoryExporter. Handles txt, json, html, md, and jsx formats with consistent styling.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Dict</code> <p>Directory structure dictionary</p> required <code>root_dir</code> <code>str</code> <p>Root directory name</p> required <code>format_type</code> <code>str</code> <p>Export format ('txt', 'json', 'html', 'md', 'jsx')</p> required <code>output_path</code> <code>str</code> <p>Path where the export file will be saved</p> required <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to include lines of code counts in the export</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to include file size information in the export</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to include file modification times in the export</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the format_type is not supported</p> Source code in <code>recursivist/core.py</code> <pre><code>def export_structure(\n    structure: Dict,\n    root_dir: str,\n    format_type: str,\n    output_path: str,\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; None:\n    \"\"\"Export the directory structure to various formats.\n\n    Maps the requested format to the appropriate export method using DirectoryExporter. Handles txt, json, html, md, and jsx formats with consistent styling.\n\n    Args:\n        structure: Directory structure dictionary\n        root_dir: Root directory name\n        format_type: Export format ('txt', 'json', 'html', 'md', 'jsx')\n        output_path: Path where the export file will be saved\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to include lines of code counts in the export\n        sort_by_size: Whether to include file size information in the export\n        sort_by_mtime: Whether to include file modification times in the export\n\n    Raises:\n        ValueError: If the format_type is not supported\n    \"\"\"\n\n    from recursivist.exports import DirectoryExporter\n\n    exporter = DirectoryExporter(\n        structure,\n        os.path.basename(root_dir),\n        root_dir if show_full_path else None,\n        sort_by_loc,\n        sort_by_size,\n        sort_by_mtime,\n    )\n    format_map = {\n        \"txt\": exporter.to_txt,\n        \"json\": exporter.to_json,\n        \"html\": exporter.to_html,\n        \"md\": exporter.to_markdown,\n        \"jsx\": exporter.to_jsx,\n    }\n    if format_type.lower() not in format_map:\n        raise ValueError(f\"Unsupported format: {format_type}\")\n    export_func = format_map[format_type.lower()]\n    export_func(output_path)\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.format_size","title":"<code>format_size(size_in_bytes)</code>","text":"<p>Format a size in bytes to a human-readable string.</p> <p>Converts raw byte counts to appropriate units (B, KB, MB, GB) with consistent formatting.</p> <p>Parameters:</p> Name Type Description Default <code>size_in_bytes</code> <code>int</code> <p>Size in bytes</p> required <p>Returns:</p> Type Description <code>str</code> <p>Human-readable size string (e.g., \"4.2 MB\")</p> Source code in <code>recursivist/core.py</code> <pre><code>def format_size(size_in_bytes: int) -&gt; str:\n    \"\"\"Format a size in bytes to a human-readable string.\n\n    Converts raw byte counts to appropriate units (B, KB, MB, GB) with consistent formatting.\n\n    Args:\n        size_in_bytes: Size in bytes\n\n    Returns:\n        Human-readable size string (e.g., \"4.2 MB\")\n    \"\"\"\n\n    if size_in_bytes &lt; 1024:\n        return f\"{size_in_bytes} B\"\n    elif size_in_bytes &lt; 1024 * 1024:\n        return f\"{size_in_bytes / 1024:.1f} KB\"\n    elif size_in_bytes &lt; 1024 * 1024 * 1024:\n        return f\"{size_in_bytes / (1024 * 1024):.1f} MB\"\n    else:\n        return f\"{size_in_bytes / (1024 * 1024 * 1024):.1f} GB\"\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.format_timestamp","title":"<code>format_timestamp(timestamp)</code>","text":"<p>Format a Unix timestamp to a human-readable string.</p> <p>Intelligently formats timestamps with different representations based on recency: - Today: \"Today HH:MM\" - Yesterday: \"Yesterday HH:MM\" - Last week: \"Day HH:MM\" (e.g., \"Mon 14:30\") - This year: \"Month Day\" (e.g., \"Mar 15\") - Older: \"YYYY-MM-DD\"</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>float</code> <p>Unix timestamp (seconds since epoch)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Human-readable date/time string</p> Source code in <code>recursivist/core.py</code> <pre><code>def format_timestamp(timestamp: float) -&gt; str:\n    \"\"\"Format a Unix timestamp to a human-readable string.\n\n    Intelligently formats timestamps with different representations based on recency:\n    - Today: \"Today HH:MM\"\n    - Yesterday: \"Yesterday HH:MM\"\n    - Last week: \"Day HH:MM\" (e.g., \"Mon 14:30\")\n    - This year: \"Month Day\" (e.g., \"Mar 15\")\n    - Older: \"YYYY-MM-DD\"\n\n    Args:\n        timestamp: Unix timestamp (seconds since epoch)\n\n    Returns:\n        Human-readable date/time string\n    \"\"\"\n\n    dt_object = dt.fromtimestamp(timestamp)\n    current_dt = dt.now()\n    current_date = current_dt.date()\n    if dt_object.date() == current_date:\n        return f\"Today {dt_object.strftime('%H:%M')}\"\n    elif dt_object.date() == current_date - datetime.timedelta(days=1):\n        return f\"Yesterday {dt_object.strftime('%H:%M')}\"\n    elif current_date - dt_object.date() &lt; datetime.timedelta(days=7):\n        return dt_object.strftime(\"%a %H:%M\")\n    elif dt_object.year == current_dt.year:\n        return dt_object.strftime(\"%b %d\")\n    else:\n        return dt_object.strftime(\"%Y-%m-%d\")\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.generate_color_for_extension","title":"<code>generate_color_for_extension(extension)</code>","text":"<p>Generate a consistent color for a file extension.</p> <p>Creates a deterministic color based on the extension string using a hash function. The same extension will always get the same color within a session, ensuring visual consistency.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>File extension (with or without leading dot)</p> required <p>Returns:</p> Type Description <code>str</code> <p>Hex color code (e.g., \"#FF5733\")</p> Source code in <code>recursivist/core.py</code> <pre><code>def generate_color_for_extension(extension: str) -&gt; str:\n    \"\"\"Generate a consistent color for a file extension.\n\n    Creates a deterministic color based on the extension string using a hash function.\n    The same extension will always get the same color within a session, ensuring visual consistency.\n\n    Args:\n        extension: File extension (with or without leading dot)\n\n    Returns:\n        Hex color code (e.g., \"#FF5733\")\n    \"\"\"\n\n    if not extension:\n        return \"#FFFFFF\"\n    hash_value = int(hashlib.md5(extension.encode()).hexdigest(), 16)\n    hue = hash_value % 360 / 360.0\n    saturation = 0.7\n    value = 0.95\n    rgb = colorsys.hsv_to_rgb(hue, saturation, value)\n    return \"#{:02x}{:02x}{:02x}\".format(\n        int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255)\n    )\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.get_directory_structure","title":"<code>get_directory_structure(root_dir, exclude_dirs=None, ignore_file=None, exclude_extensions=None, parent_ignore_patterns=None, exclude_patterns=None, include_patterns=None, max_depth=0, current_depth=0, current_path='', show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Build a nested dictionary representing a directory structure.</p> <p>Recursively traverses the file system applying filters and collecting statistics. The resulting structure contains: - Hierarchical representation of directories and files - Optional statistics (lines of code, sizes, modification times) - Filtered entries based on various exclusion patterns</p> <p>Special dictionary keys: - \"_files\": List of files in the directory - \"_loc\": Total lines of code (if sort_by_loc is True) - \"_size\": Total size in bytes (if sort_by_size is True) - \"_mtime\": Latest modification timestamp (if sort_by_mtime is True) - \"_max_depth_reached\": Flag indicating max depth was reached</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>str</code> <p>Root directory path to start from</p> required <code>exclude_dirs</code> <code>Optional[Sequence[str]]</code> <p>List of directory names to exclude</p> <code>None</code> <code>ignore_file</code> <code>Optional[str]</code> <p>Name of ignore file (like .gitignore)</p> <code>None</code> <code>exclude_extensions</code> <code>Optional[Set[str]]</code> <p>Set of file extensions to exclude</p> <code>None</code> <code>parent_ignore_patterns</code> <code>Optional[Sequence[str]]</code> <p>Patterns from parent directories' ignore files</p> <code>None</code> <code>exclude_patterns</code> <code>Optional[Sequence[Union[str, Pattern[str]]]]</code> <p>List of patterns (glob or regex) to exclude</p> <code>None</code> <code>include_patterns</code> <code>Optional[Sequence[Union[str, Pattern[str]]]]</code> <p>List of patterns (glob or regex) to include (overrides exclusions)</p> <code>None</code> <code>max_depth</code> <code>int</code> <p>Maximum depth to traverse (0 for unlimited)</p> <code>0</code> <code>current_depth</code> <code>int</code> <p>Current depth in the directory tree (for internal recursion)</p> <code>0</code> <code>current_path</code> <code>str</code> <p>Current path for full path display (for internal recursion)</p> <code>''</code> <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to calculate and track lines of code counts</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to calculate and track file sizes</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to track file modification times</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[Dict[str, Any], Set[str]]</code> <p>Tuple of (structure dictionary, set of file extensions found)</p> Source code in <code>recursivist/core.py</code> <pre><code>def get_directory_structure(\n    root_dir: str,\n    exclude_dirs: Optional[Sequence[str]] = None,\n    ignore_file: Optional[str] = None,\n    exclude_extensions: Optional[Set[str]] = None,\n    parent_ignore_patterns: Optional[Sequence[str]] = None,\n    exclude_patterns: Optional[Sequence[Union[str, Pattern[str]]]] = None,\n    include_patterns: Optional[Sequence[Union[str, Pattern[str]]]] = None,\n    max_depth: int = 0,\n    current_depth: int = 0,\n    current_path: str = \"\",\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; Tuple[Dict[str, Any], Set[str]]:\n    \"\"\"Build a nested dictionary representing a directory structure.\n\n    Recursively traverses the file system applying filters and collecting statistics.\n    The resulting structure contains:\n    - Hierarchical representation of directories and files\n    - Optional statistics (lines of code, sizes, modification times)\n    - Filtered entries based on various exclusion patterns\n\n    Special dictionary keys:\n    - \"_files\": List of files in the directory\n    - \"_loc\": Total lines of code (if sort_by_loc is True)\n    - \"_size\": Total size in bytes (if sort_by_size is True)\n    - \"_mtime\": Latest modification timestamp (if sort_by_mtime is True)\n    - \"_max_depth_reached\": Flag indicating max depth was reached\n\n    Args:\n        root_dir: Root directory path to start from\n        exclude_dirs: List of directory names to exclude\n        ignore_file: Name of ignore file (like .gitignore)\n        exclude_extensions: Set of file extensions to exclude\n        parent_ignore_patterns: Patterns from parent directories' ignore files\n        exclude_patterns: List of patterns (glob or regex) to exclude\n        include_patterns: List of patterns (glob or regex) to include (overrides exclusions)\n        max_depth: Maximum depth to traverse (0 for unlimited)\n        current_depth: Current depth in the directory tree (for internal recursion)\n        current_path: Current path for full path display (for internal recursion)\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to calculate and track lines of code counts\n        sort_by_size: Whether to calculate and track file sizes\n        sort_by_mtime: Whether to track file modification times\n\n    Returns:\n        Tuple of (structure dictionary, set of file extensions found)\n    \"\"\"\n\n    if exclude_dirs is None:\n        exclude_dirs = []\n    if exclude_extensions is None:\n        exclude_extensions = set()\n    if exclude_patterns is None:\n        exclude_patterns = []\n    if include_patterns is None:\n        include_patterns = []\n    ignore_patterns = list(parent_ignore_patterns) if parent_ignore_patterns else []\n    if ignore_file and os.path.exists(os.path.join(root_dir, ignore_file)):\n        current_ignore_patterns = parse_ignore_file(os.path.join(root_dir, ignore_file))\n        ignore_patterns.extend(current_ignore_patterns)\n    ignore_context = {\"patterns\": ignore_patterns, \"current_dir\": root_dir}\n    structure: Dict[str, Any] = {}\n    extensions_set: Set[str] = set()\n    total_loc = 0\n    total_size = 0\n    latest_mtime = 0.0\n    if max_depth &gt; 0 and current_depth &gt;= max_depth:\n        return {\"_max_depth_reached\": True}, extensions_set\n    try:\n        items = os.listdir(root_dir)\n    except PermissionError:\n        logger.warning(f\"Permission denied: {root_dir}\")\n        return structure, extensions_set\n    except Exception as e:\n        logger.error(f\"Error reading directory {root_dir}: {e}\")\n        return structure, extensions_set\n    for item in items:\n        item_path = os.path.join(root_dir, item)\n        if item in exclude_dirs or should_exclude(\n            item_path,\n            ignore_context,\n            exclude_extensions,\n            exclude_patterns,\n            include_patterns,\n        ):\n            continue\n        if not os.path.isdir(item_path):\n            _, ext = os.path.splitext(item)\n            if ext.lower() not in exclude_extensions:\n                if \"_files\" not in structure:\n                    structure[\"_files\"] = []\n                file_loc = 0\n                file_size = 0\n                file_mtime = 0.0\n                if sort_by_loc:\n                    file_loc = count_lines_of_code(item_path)\n                    total_loc += file_loc\n                if sort_by_size:\n                    file_size = get_file_size(item_path)\n                    total_size += file_size\n                if sort_by_mtime:\n                    file_mtime = get_file_mtime(item_path)\n                    latest_mtime = max(latest_mtime, file_mtime)\n                if show_full_path:\n                    abs_path = os.path.abspath(item_path)\n                    abs_path = abs_path.replace(os.sep, \"/\")\n                    if sort_by_loc and sort_by_size and sort_by_mtime:\n                        structure[\"_files\"].append(\n                            (item, abs_path, file_loc, file_size, file_mtime)\n                        )\n                    elif sort_by_loc and sort_by_size:\n                        structure[\"_files\"].append(\n                            (item, abs_path, file_loc, file_size)\n                        )\n                    elif sort_by_loc and sort_by_mtime:\n                        structure[\"_files\"].append(\n                            (item, abs_path, file_loc, 0, file_mtime)\n                        )\n                    elif sort_by_size and sort_by_mtime:\n                        structure[\"_files\"].append(\n                            (item, abs_path, 0, file_size, file_mtime)\n                        )\n                    elif sort_by_loc:\n                        structure[\"_files\"].append((item, abs_path, file_loc))\n                    elif sort_by_size:\n                        structure[\"_files\"].append((item, abs_path, file_size))\n                    elif sort_by_mtime:\n                        structure[\"_files\"].append((item, abs_path, file_mtime))\n                    else:\n                        structure[\"_files\"].append((item, abs_path))\n                else:\n                    if sort_by_loc and sort_by_size and sort_by_mtime:\n                        structure[\"_files\"].append(\n                            (item, item, file_loc, file_size, file_mtime)\n                        )\n                    elif sort_by_loc and sort_by_size:\n                        structure[\"_files\"].append((item, item, file_loc, file_size))\n                    elif sort_by_loc and sort_by_mtime:\n                        structure[\"_files\"].append(\n                            (item, item, file_loc, 0, file_mtime)\n                        )\n                    elif sort_by_size and sort_by_mtime:\n                        structure[\"_files\"].append(\n                            (item, item, 0, file_size, file_mtime)\n                        )\n                    elif sort_by_loc:\n                        structure[\"_files\"].append((item, item, file_loc))\n                    elif sort_by_size:\n                        structure[\"_files\"].append((item, item, file_size))\n                    elif sort_by_mtime:\n                        structure[\"_files\"].append((item, item, file_mtime))\n                    else:\n                        structure[\"_files\"].append(item)\n                if ext:\n                    extensions_set.add(ext.lower())\n    for item in items:\n        item_path = os.path.join(root_dir, item)\n        if item in exclude_dirs or should_exclude(\n            item_path,\n            ignore_context,\n            exclude_extensions,\n            exclude_patterns,\n            include_patterns,\n        ):\n            continue\n        if os.path.isdir(item_path):\n            next_path = os.path.join(current_path, item) if current_path else item\n            substructure, sub_extensions = get_directory_structure(\n                item_path,\n                exclude_dirs,\n                ignore_file,\n                exclude_extensions,\n                ignore_patterns,\n                exclude_patterns,\n                include_patterns,\n                max_depth,\n                current_depth + 1,\n                next_path,\n                show_full_path,\n                sort_by_loc,\n                sort_by_size,\n                sort_by_mtime,\n            )\n            structure[item] = substructure\n            extensions_set.update(sub_extensions)\n            if sort_by_loc and \"_loc\" in substructure:\n                total_loc += substructure[\"_loc\"]\n            if sort_by_size and \"_size\" in substructure:\n                total_size += substructure[\"_size\"]\n            if sort_by_mtime and \"_mtime\" in substructure:\n                latest_mtime = max(latest_mtime, substructure[\"_mtime\"])\n    if sort_by_loc:\n        structure[\"_loc\"] = total_loc\n    if sort_by_size:\n        structure[\"_size\"] = total_size\n    if sort_by_mtime:\n        structure[\"_mtime\"] = latest_mtime\n    return structure, extensions_set\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.get_file_mtime","title":"<code>get_file_mtime(file_path)</code>","text":"<p>Get the modification time of a file in seconds since epoch.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>float</code> <p>Modification time as a float (seconds since epoch), or 0 if the file cannot be accessed</p> Source code in <code>recursivist/core.py</code> <pre><code>def get_file_mtime(file_path: str) -&gt; float:\n    \"\"\"Get the modification time of a file in seconds since epoch.\n\n    Args:\n        file_path: Path to the file\n\n    Returns:\n        Modification time as a float (seconds since epoch), or 0 if the file cannot be accessed\n    \"\"\"\n\n    try:\n        return os.path.getmtime(file_path)\n    except Exception as e:\n        logger.debug(f\"Could not get modification time for {file_path}: {e}\")\n        return 0.0\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.get_file_size","title":"<code>get_file_size(file_path)</code>","text":"<p>Get the size of a file in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the file</p> required <p>Returns:</p> Type Description <code>int</code> <p>Size of the file in bytes, or 0 if the file cannot be accessed</p> Source code in <code>recursivist/core.py</code> <pre><code>def get_file_size(file_path: str) -&gt; int:\n    \"\"\"Get the size of a file in bytes.\n\n    Args:\n        file_path: Path to the file\n\n    Returns:\n        Size of the file in bytes, or 0 if the file cannot be accessed\n    \"\"\"\n\n    try:\n        return os.path.getsize(file_path)\n    except Exception as e:\n        logger.debug(f\"Could not get size for {file_path}: {e}\")\n        return 0\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.parse_ignore_file","title":"<code>parse_ignore_file(ignore_file_path)</code>","text":"<p>Parse an ignore file (like .gitignore) and return patterns.</p> <p>Reads an ignore file and extracts patterns for excluding files and directories. Handles comments and trailing slashes in directories.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_file_path</code> <code>str</code> <p>Path to the ignore file</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of patterns to ignore</p> Source code in <code>recursivist/core.py</code> <pre><code>def parse_ignore_file(ignore_file_path: str) -&gt; List[str]:\n    \"\"\"Parse an ignore file (like .gitignore) and return patterns.\n\n    Reads an ignore file and extracts patterns for excluding files and directories. Handles comments and trailing slashes in directories.\n\n    Args:\n        ignore_file_path: Path to the ignore file\n\n    Returns:\n        List of patterns to ignore\n    \"\"\"\n\n    if not os.path.exists(ignore_file_path):\n        return []\n    patterns = []\n    with open(ignore_file_path, \"r\") as f:\n        for line in f:\n            line = line.strip()\n            if line and not line.startswith(\"#\"):\n                if line.endswith(\"/\"):\n                    line = line[:-1]\n                patterns.append(line)\n    return patterns\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.should_exclude","title":"<code>should_exclude(path, ignore_context, exclude_extensions=None, exclude_patterns=None, include_patterns=None)</code>","text":"<p>Determine if a path should be excluded based on filtering rules.</p> <p>Applies a hierarchical filtering logic: 1. If include_patterns match, INCLUDE the path (overrides all exclusions) 2. If exclude_patterns match, EXCLUDE the path 3. If file extension is in exclude_extensions, EXCLUDE the path 4. If gitignore-style patterns match, follow their rules (including negations)</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to check for exclusion</p> required <code>ignore_context</code> <code>Dict</code> <p>Dictionary with 'patterns' and 'current_dir' keys</p> required <code>exclude_extensions</code> <code>Optional[Set[str]]</code> <p>Set of file extensions to exclude</p> <code>None</code> <code>exclude_patterns</code> <code>Optional[Sequence[Union[str, Pattern[str]]]]</code> <p>List of patterns (glob or regex) to exclude</p> <code>None</code> <code>include_patterns</code> <code>Optional[Sequence[Union[str, Pattern[str]]]]</code> <p>List of patterns (glob or regex) to include (overrides exclusions)</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if path should be excluded, False otherwise</p> Source code in <code>recursivist/core.py</code> <pre><code>def should_exclude(\n    path: str,\n    ignore_context: Dict,\n    exclude_extensions: Optional[Set[str]] = None,\n    exclude_patterns: Optional[Sequence[Union[str, Pattern[str]]]] = None,\n    include_patterns: Optional[Sequence[Union[str, Pattern[str]]]] = None,\n) -&gt; bool:\n    \"\"\"Determine if a path should be excluded based on filtering rules.\n\n    Applies a hierarchical filtering logic:\n    1. If include_patterns match, INCLUDE the path (overrides all exclusions)\n    2. If exclude_patterns match, EXCLUDE the path\n    3. If file extension is in exclude_extensions, EXCLUDE the path\n    4. If gitignore-style patterns match, follow their rules (including negations)\n\n    Args:\n        path: Path to check for exclusion\n        ignore_context: Dictionary with 'patterns' and 'current_dir' keys\n        exclude_extensions: Set of file extensions to exclude\n        exclude_patterns: List of patterns (glob or regex) to exclude\n        include_patterns: List of patterns (glob or regex) to include (overrides exclusions)\n\n    Returns:\n        True if path should be excluded, False otherwise\n    \"\"\"\n\n    patterns = ignore_context.get(\"patterns\", [])\n    current_dir = ignore_context.get(\"current_dir\", os.path.dirname(path))\n    if exclude_extensions and os.path.isfile(path):\n        _, ext = os.path.splitext(path)\n        if ext.lower() in exclude_extensions:\n            return True\n    rel_path = os.path.relpath(path, current_dir)\n    if os.name == \"nt\":\n        rel_path = rel_path.replace(\"\\\\\", \"/\")\n    basename = os.path.basename(path)\n    if include_patterns:\n        included = False\n        for pattern in include_patterns:\n            if isinstance(pattern, Pattern):\n                if pattern.search(rel_path) or pattern.search(basename):\n                    included = True\n                    break\n            else:\n                if fnmatch.fnmatch(rel_path, pattern) or fnmatch.fnmatch(\n                    basename, pattern\n                ):\n                    included = True\n                    break\n        if included:\n            return False\n        else:\n            return True\n    if exclude_patterns:\n        for pattern in exclude_patterns:\n            if isinstance(pattern, Pattern):\n                if pattern.search(rel_path) or pattern.search(basename):\n                    return True\n            else:\n                if fnmatch.fnmatch(rel_path, pattern) or fnmatch.fnmatch(\n                    basename, pattern\n                ):\n                    return True\n    if not patterns:\n        return False\n    for pattern in patterns:\n        if isinstance(pattern, str) and pattern.startswith(\"!\"):\n            if fnmatch.fnmatch(rel_path, pattern[1:]):\n                return False\n    for pattern in patterns:\n        if isinstance(pattern, str) and not pattern.startswith(\"!\"):\n            if fnmatch.fnmatch(rel_path, pattern):\n                return True\n    return False\n</code></pre>"},{"location":"reference/api-reference/#recursivist.core.sort_files_by_type","title":"<code>sort_files_by_type(files, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Sort files by extension and then by name, or by LOC/size/mtime if requested.</p> <p>The sort precedence follows: LOC &gt; size &gt; mtime &gt; extension/name</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>Sequence[Union[str, Tuple[str, str], Tuple[str, str, int], Tuple[str, str, int, int], Tuple[str, str, int, int, float]]]</code> <p>List of file items, which can be strings or tuples of various forms</p> required <code>sort_by_loc</code> <code>bool</code> <p>Whether to sort by lines of code</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to sort by file size</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to sort by modification time</p> <code>False</code> <p>Returns:</p> Type Description <code>List[Union[str, Tuple[str, str], Tuple[str, str, int], Tuple[str, str, int, int], Tuple[str, str, int, int, float]]]</code> <p>Sorted list of file items</p> Source code in <code>recursivist/core.py</code> <pre><code>def sort_files_by_type(\n    files: Sequence[\n        Union[\n            str,\n            Tuple[str, str],\n            Tuple[str, str, int],\n            Tuple[str, str, int, int],\n            Tuple[str, str, int, int, float],\n        ]\n    ],\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; List[\n    Union[\n        str,\n        Tuple[str, str],\n        Tuple[str, str, int],\n        Tuple[str, str, int, int],\n        Tuple[str, str, int, int, float],\n    ]\n]:\n    \"\"\"Sort files by extension and then by name, or by LOC/size/mtime if requested.\n\n    The sort precedence follows: LOC &gt; size &gt; mtime &gt; extension/name\n\n    Args:\n        files: List of file items, which can be strings or tuples of various forms\n        sort_by_loc: Whether to sort by lines of code\n        sort_by_size: Whether to sort by file size\n        sort_by_mtime: Whether to sort by modification time\n\n    Returns:\n        Sorted list of file items\n    \"\"\"\n\n    if not files:\n        return []\n    has_loc = any(isinstance(item, tuple) and len(item) &gt; 2 for item in files)\n    has_size = any(isinstance(item, tuple) and len(item) &gt; 3 for item in files)\n    has_mtime = any(isinstance(item, tuple) and len(item) &gt; 4 for item in files)\n    has_simple_size = sort_by_size and not sort_by_loc and has_loc\n    has_simple_mtime = (\n        sort_by_mtime and not sort_by_loc and not sort_by_size and (has_loc or has_size)\n    )\n\n    def get_size(item):\n        if not isinstance(item, tuple):\n            return 0\n        if len(item) &gt; 3:\n            if sort_by_loc and sort_by_size:\n                return item[3]\n            elif sort_by_size and not sort_by_loc:\n                return item[2]\n        elif len(item) == 3 and sort_by_size:\n            return item[2]\n        return 0\n\n    def get_loc(item):\n        if not isinstance(item, tuple) or len(item) &lt;= 2:\n            return 0\n        return item[2] if sort_by_loc else 0\n\n    def get_mtime(item):\n        if not isinstance(item, tuple):\n            return 0\n        if len(item) &gt; 4 and sort_by_loc and sort_by_size and sort_by_mtime:\n            return item[4]\n        elif len(item) &gt; 3 and (\n            (sort_by_loc and sort_by_mtime and not sort_by_size)\n            or (sort_by_size and sort_by_mtime and not sort_by_loc)\n        ):\n            return item[3]\n        elif len(item) &gt; 2 and sort_by_mtime and not sort_by_loc and not sort_by_size:\n            return item[2]\n        return 0\n\n    if sort_by_loc and sort_by_size and sort_by_mtime and has_mtime:\n        return sorted(files, key=lambda f: (-get_loc(f), -get_size(f), -get_mtime(f)))\n    elif sort_by_loc and sort_by_size and (has_size or has_simple_size) and has_loc:\n        return sorted(files, key=lambda f: (-get_loc(f), -get_size(f)))\n    elif sort_by_loc and sort_by_mtime and has_mtime:\n        return sorted(files, key=lambda f: (-get_loc(f), -get_mtime(f)))\n    elif sort_by_size and sort_by_mtime and has_mtime:\n        return sorted(files, key=lambda f: (-get_size(f), -get_mtime(f)))\n    elif sort_by_loc and has_loc:\n        return sorted(files, key=lambda f: (-get_loc(f)))\n    elif sort_by_size and (has_size or has_simple_size):\n        return sorted(files, key=lambda f: (-get_size(f)))\n    elif sort_by_mtime and (has_mtime or has_simple_mtime):\n        return sorted(files, key=lambda f: (-get_mtime(f)))\n    all_tuples = all(isinstance(item, tuple) for item in files)\n    all_strings = all(isinstance(item, str) for item in files)\n    if all_strings:\n        files_as_strings = cast(List[str], files)\n        return cast(\n            List[\n                Union[\n                    str,\n                    Tuple[str, str],\n                    Tuple[str, str, int],\n                    Tuple[str, str, int, int],\n                    Tuple[str, str, int, int, float],\n                ]\n            ],\n            sorted(\n                files_as_strings,\n                key=lambda f: (os.path.splitext(f)[1].lower(), f.lower()),\n            ),\n        )\n    elif all_tuples:\n        return sorted(\n            files,\n            key=lambda t: (os.path.splitext(t[0])[1].lower(), t[0].lower()),\n        )\n    else:\n        str_items: List[str] = []\n        tuple_items: List[\n            Union[\n                Tuple[str, str],\n                Tuple[str, str, int],\n                Tuple[str, str, int, int],\n                Tuple[str, str, int, int, float],\n            ]\n        ] = []\n        for item in files:\n            if isinstance(item, tuple):\n                tuple_items.append(item)\n            else:\n                str_items.append(cast(str, item))\n        sorted_strings = sorted(\n            str_items, key=lambda f: (os.path.splitext(f)[1].lower(), f.lower())\n        )\n        sorted_tuples = sorted(\n            tuple_items, key=lambda t: (os.path.splitext(t[0])[1].lower(), t[0].lower())\n        )\n        result: List[\n            Union[\n                str,\n                Tuple[str, str],\n                Tuple[str, str, int],\n                Tuple[str, str, int, int],\n                Tuple[str, str, int, int, float],\n            ]\n        ] = []\n        result.extend(sorted_strings)\n        result.extend(sorted_tuples)\n        return result\n</code></pre>"},{"location":"reference/api-reference/#exports-module","title":"Exports Module","text":""},{"location":"reference/api-reference/#recursivist.exports","title":"<code>recursivist.exports</code>","text":"<p>Export functionality for the Recursivist directory visualization tool.</p> <p>This module handles the export of directory structures to various formats through the DirectoryExporter class, which provides a unified interface for transforming directory structures into different output formats.</p> <p>Supported export formats: - TXT: ASCII tree representation - JSON: Structured data for programmatic use - HTML: Interactive web page with styling - Markdown: Clean representation for documentation - JSX: React component for web integration</p> <p>Each format maintains consistent styling and organization, with support for showing lines of code, file sizes, and modification times.</p>"},{"location":"reference/api-reference/#recursivist.exports.DirectoryExporter","title":"<code>DirectoryExporter</code>","text":"<p>Export directory structures to various formats.</p> <p>Provides a unified interface for transforming directory structures into different output formats with consistent styling and organization.</p> <p>Supported formats: - TXT: ASCII tree representation - JSON: Structured data for programmatic use - HTML: Interactive web page with styling - Markdown: Clean representation for documentation - JSX: React component for web integration</p> <p>Each format maintains consistent features for: - Directory and file hierarchical representation - Optional statistics (lines of code, sizes, modification times) - Path display options (full or relative paths)</p> Source code in <code>recursivist/exports.py</code> <pre><code>class DirectoryExporter:\n    \"\"\"Export directory structures to various formats.\n\n    Provides a unified interface for transforming directory structures into different output formats with consistent styling and organization.\n\n    Supported formats:\n    - TXT: ASCII tree representation\n    - JSON: Structured data for programmatic use\n    - HTML: Interactive web page with styling\n    - Markdown: Clean representation for documentation\n    - JSX: React component for web integration\n\n    Each format maintains consistent features for:\n    - Directory and file hierarchical representation\n    - Optional statistics (lines of code, sizes, modification times)\n    - Path display options (full or relative paths)\n    \"\"\"\n\n    def __init__(\n        self,\n        structure: Dict[str, Any],\n        root_name: str,\n        base_path: Optional[str] = None,\n        sort_by_loc: bool = False,\n        sort_by_size: bool = False,\n        sort_by_mtime: bool = False,\n    ):\n        \"\"\"Initialize the exporter with directory structure and root name.\n\n        Args:\n            structure: The directory structure dictionary\n            root_name: Name of the root directory\n            base_path: Base path for full path display (if None, only show filenames)\n            sort_by_loc: Whether to include lines of code counts in exports\n            sort_by_size: Whether to include file size information in exports\n            sort_by_mtime: Whether to include modification time information in exports\n        \"\"\"\n\n        self.structure = structure\n        self.root_name = root_name\n        self.base_path = base_path\n        self.show_full_path = base_path is not None\n        self.sort_by_loc = sort_by_loc\n        self.sort_by_size = sort_by_size\n        self.sort_by_mtime = sort_by_mtime\n\n    def to_txt(self, output_path: str) -&gt; None:\n        \"\"\"Export directory structure to a text file with ASCII tree representation.\n\n        Creates a text file containing an ASCII tree representation of the directory structure using standard box-drawing characters and indentation.\n\n        Args:\n            output_path: Path where the txt file will be saved\n        \"\"\"\n\n        def _build_txt_tree(\n            structure: Dict[str, Any],\n            prefix: str = \"\",\n            path_prefix: str = \"\",\n        ) -&gt; List[str]:\n            lines = []\n            items = sorted(structure.items())\n            for i, (name, content) in enumerate(items):\n                if name == \"_files\":\n                    file_items = sort_files_by_type(\n                        content, self.sort_by_loc, self.sort_by_size, self.sort_by_mtime\n                    )\n                    for j, file_item in enumerate(file_items):\n                        is_last_file = j == len(file_items) - 1\n                        is_last_item = is_last_file and i == len(items) - 1\n                        item_prefix = prefix + (\"\u2514\u2500\u2500 \" if is_last_item else \"\u251c\u2500\u2500 \")\n                        if (\n                            self.sort_by_loc\n                            and self.sort_by_size\n                            and self.sort_by_mtime\n                            and isinstance(file_item, tuple)\n                            and len(file_item) &gt; 4\n                        ):\n                            _, display_path, loc, size, mtime = file_item\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc4 {display_path} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\"\n                            )\n                        elif (\n                            self.sort_by_loc\n                            and self.sort_by_mtime\n                            and isinstance(file_item, tuple)\n                            and len(file_item) &gt; 3\n                        ):\n                            if len(file_item) &gt; 4:\n                                _, display_path, loc, _, mtime = file_item\n                            else:\n                                _, display_path, loc, mtime = file_item\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc4 {display_path} ({loc} lines, {format_timestamp(mtime)})\"\n                            )\n                        elif (\n                            self.sort_by_size\n                            and self.sort_by_mtime\n                            and isinstance(file_item, tuple)\n                            and len(file_item) &gt; 3\n                        ):\n                            if len(file_item) &gt; 4:\n                                _, display_path, _, size, mtime = file_item\n                            else:\n                                _, display_path, size, mtime = file_item\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc4 {display_path} ({format_size(size)}, {format_timestamp(mtime)})\"\n                            )\n                        elif (\n                            self.sort_by_loc\n                            and self.sort_by_size\n                            and isinstance(file_item, tuple)\n                            and len(file_item) &gt; 3\n                        ):\n                            if len(file_item) &gt; 4:\n                                _, display_path, loc, size, _ = file_item\n                            else:\n                                _, display_path, loc, size = file_item\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc4 {display_path} ({loc} lines, {format_size(size)})\"\n                            )\n                        elif (\n                            self.sort_by_mtime\n                            and isinstance(file_item, tuple)\n                            and len(file_item) &gt; 2\n                        ):\n                            if len(file_item) &gt; 4:\n                                _, display_path, _, _, mtime = file_item\n                            elif len(file_item) &gt; 3:\n                                _, display_path, _, mtime = file_item\n                            else:\n                                _, display_path, mtime = file_item\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc4 {display_path} ({format_timestamp(mtime)})\"\n                            )\n                        elif (\n                            self.sort_by_size\n                            and isinstance(file_item, tuple)\n                            and len(file_item) &gt; 2\n                        ):\n                            if len(file_item) &gt; 4:\n                                _, display_path, _, size, _ = file_item\n                            elif len(file_item) &gt; 3:\n                                _, display_path, _, size = file_item\n                            else:\n                                _, display_path, size = file_item\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc4 {display_path} ({format_size(size)})\"\n                            )\n                        elif (\n                            self.sort_by_loc\n                            and isinstance(file_item, tuple)\n                            and len(file_item) &gt; 2\n                        ):\n                            if len(file_item) &gt; 4:\n                                _, display_path, loc, _, _ = file_item\n                            elif len(file_item) &gt; 3:\n                                _, display_path, loc, _ = file_item\n                            else:\n                                _, display_path, loc = file_item\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc4 {display_path} ({loc} lines)\"\n                            )\n                        elif self.show_full_path and isinstance(file_item, tuple):\n                            if len(file_item) &gt; 4:\n                                _, full_path, _, _, _ = file_item\n                            elif len(file_item) &gt; 3:\n                                _, full_path, _, _ = file_item\n                            elif len(file_item) &gt; 2:\n                                _, full_path, _ = file_item\n                            else:\n                                _, full_path = file_item\n                            lines.append(f\"{item_prefix}\ud83d\udcc4 {full_path}\")\n                        else:\n                            if isinstance(file_item, tuple):\n                                if len(file_item) &gt; 4:\n                                    file_name, _, _, _, _ = file_item\n                                elif len(file_item) &gt; 3:\n                                    file_name, _, _, _ = file_item\n                                elif len(file_item) &gt; 2:\n                                    file_name, _, _ = file_item\n                                else:\n                                    file_name, _ = file_item\n                            else:\n                                file_name = file_item\n                            lines.append(f\"{item_prefix}\ud83d\udcc4 {file_name}\")\n                        if not is_last_item:\n                            next_prefix = prefix + \"\u2502   \"\n                        else:\n                            next_prefix = prefix + \"    \"\n                elif (\n                    name == \"_loc\"\n                    or name == \"_size\"\n                    or name == \"_mtime\"\n                    or name == \"_max_depth_reached\"\n                ):\n                    continue\n                else:\n                    is_last_dir = True\n                    for j in range(i + 1, len(items)):\n                        next_name, next_content = items[j]\n                        if next_name not in [\n                            \"_files\",\n                            \"_max_depth_reached\",\n                            \"_loc\",\n                            \"_size\",\n                            \"_mtime\",\n                        ]:\n                            is_last_dir = False\n                            break\n                    is_last_item = is_last_dir and (\n                        i == len(items) - 1\n                        or all(\n                            key\n                            in [\n                                \"_files\",\n                                \"_max_depth_reached\",\n                                \"_loc\",\n                                \"_size\",\n                                \"_mtime\",\n                            ]\n                            for key, _ in items[i + 1 :]\n                        )\n                    )\n                    item_prefix = prefix + (\"\u2514\u2500\u2500 \" if is_last_item else \"\u251c\u2500\u2500 \")\n                    next_path = os.path.join(path_prefix, name) if path_prefix else name\n                    if isinstance(content, dict):\n                        if (\n                            self.sort_by_loc\n                            and self.sort_by_size\n                            and self.sort_by_mtime\n                            and \"_loc\" in content\n                            and \"_size\" in content\n                            and \"_mtime\" in content\n                        ):\n                            folder_loc = content[\"_loc\"]\n                            folder_size = content[\"_size\"]\n                            folder_mtime = content[\"_mtime\"]\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc1 {name} ({folder_loc} lines, {format_size(folder_size)}, {format_timestamp(folder_mtime)})\"\n                            )\n                        elif (\n                            self.sort_by_loc\n                            and self.sort_by_size\n                            and \"_loc\" in content\n                            and \"_size\" in content\n                        ):\n                            folder_loc = content[\"_loc\"]\n                            folder_size = content[\"_size\"]\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc1 {name} ({folder_loc} lines, {format_size(folder_size)})\"\n                            )\n                        elif (\n                            self.sort_by_loc\n                            and self.sort_by_mtime\n                            and \"_loc\" in content\n                            and \"_mtime\" in content\n                        ):\n                            folder_loc = content[\"_loc\"]\n                            folder_mtime = content[\"_mtime\"]\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc1 {name} ({folder_loc} lines, {format_timestamp(folder_mtime)})\"\n                            )\n                        elif (\n                            self.sort_by_size\n                            and self.sort_by_mtime\n                            and \"_size\" in content\n                            and \"_mtime\" in content\n                        ):\n                            folder_size = content[\"_size\"]\n                            folder_mtime = content[\"_mtime\"]\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc1 {name} ({format_size(folder_size)}, {format_timestamp(folder_mtime)})\"\n                            )\n                        elif self.sort_by_loc and \"_loc\" in content:\n                            folder_loc = content[\"_loc\"]\n                            lines.append(f\"{item_prefix}\ud83d\udcc1 {name} ({folder_loc} lines)\")\n                        elif self.sort_by_size and \"_size\" in content:\n                            folder_size = content[\"_size\"]\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc1 {name} ({format_size(folder_size)})\"\n                            )\n                        elif self.sort_by_mtime and \"_mtime\" in content:\n                            folder_mtime = content[\"_mtime\"]\n                            lines.append(\n                                f\"{item_prefix}\ud83d\udcc1 {name} ({format_timestamp(folder_mtime)})\"\n                            )\n                        else:\n                            lines.append(f\"{item_prefix}\ud83d\udcc1 {name}\")\n                        if content.get(\"_max_depth_reached\"):\n                            next_prefix = prefix + (\"    \" if is_last_item else \"\u2502   \")\n                            lines.append(f\"{next_prefix}\u2514\u2500\u2500 \u22ef (max depth reached)\")\n                        else:\n                            next_prefix = prefix + (\"    \" if is_last_item else \"\u2502   \")\n                            sublines = _build_txt_tree(content, next_prefix, next_path)\n                            lines.extend(sublines)\n                    else:\n                        lines.append(f\"{item_prefix}\ud83d\udcc1 {name}\")\n            return lines\n\n        root_label = f\"\ud83d\udcc2 {self.root_name}\"\n        if (\n            self.sort_by_loc\n            and self.sort_by_size\n            and self.sort_by_mtime\n            and \"_loc\" in self.structure\n            and \"_size\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            root_label = f\"\ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\"\n        elif (\n            self.sort_by_loc\n            and self.sort_by_size\n            and \"_loc\" in self.structure\n            and \"_size\" in self.structure\n        ):\n            root_label = f\"\ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])})\"\n        elif (\n            self.sort_by_loc\n            and self.sort_by_mtime\n            and \"_loc\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            root_label = f\"\ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_timestamp(self.structure['_mtime'])})\"\n        elif (\n            self.sort_by_size\n            and self.sort_by_mtime\n            and \"_size\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            root_label = f\"\ud83d\udcc2 {self.root_name} ({format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\"\n        elif self.sort_by_loc and \"_loc\" in self.structure:\n            root_label = f\"\ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines)\"\n        elif self.sort_by_size and \"_size\" in self.structure:\n            root_label = f\"\ud83d\udcc2 {self.root_name} ({format_size(self.structure['_size'])})\"\n        elif self.sort_by_mtime and \"_mtime\" in self.structure:\n            root_label = (\n                f\"\ud83d\udcc2 {self.root_name} ({format_timestamp(self.structure['_mtime'])})\"\n            )\n        tree_lines = [root_label]\n        tree_lines.extend(\n            _build_txt_tree(\n                self.structure, \"\", self.root_name if self.show_full_path else \"\"\n            )\n        )\n        try:\n            with open(output_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"\\n\".join(tree_lines))\n        except Exception as e:\n            logger.error(f\"Error exporting to TXT: {e}\")\n            raise\n\n    def to_json(self, output_path: str) -&gt; None:\n        \"\"\"Export directory structure to a JSON file.\n\n        Creates a JSON file containing the directory structure with options for including full paths, LOC counts, file sizes, and modification times. The JSON structure includes a root name and the hierarchical structure of directories and files.\n\n        Args:\n            output_path: Path where the JSON file will be saved\n        \"\"\"\n\n        if (\n            self.show_full_path\n            or self.sort_by_loc\n            or self.sort_by_size\n            or self.sort_by_mtime\n        ):\n\n            def convert_structure_for_json(structure):\n                result = {}\n                for k, v in structure.items():\n                    if k == \"_files\":\n                        result[k] = []\n                        for item in v:\n                            if (\n                                self.sort_by_loc\n                                and self.sort_by_size\n                                and self.sort_by_mtime\n                                and isinstance(item, tuple)\n                                and len(item) &gt; 4\n                            ):\n                                file_name, full_path, loc, size, mtime = item\n                                result[k].append(\n                                    {\n                                        \"name\": file_name,\n                                        \"path\": full_path,\n                                        \"loc\": loc,\n                                        \"size\": size,\n                                        \"size_formatted\": format_size(size),\n                                        \"mtime\": mtime,\n                                        \"mtime_formatted\": format_timestamp(mtime),\n                                    }\n                                )\n                            elif (\n                                self.sort_by_loc\n                                and self.sort_by_mtime\n                                and isinstance(item, tuple)\n                                and len(item) &gt; 4\n                            ):\n                                file_name, full_path, loc, _, mtime = item\n                                result[k].append(\n                                    {\n                                        \"name\": file_name,\n                                        \"path\": full_path,\n                                        \"loc\": loc,\n                                        \"mtime\": mtime,\n                                        \"mtime_formatted\": format_timestamp(mtime),\n                                    }\n                                )\n                            elif (\n                                self.sort_by_size\n                                and self.sort_by_mtime\n                                and isinstance(item, tuple)\n                                and len(item) &gt; 4\n                            ):\n                                file_name, full_path, _, size, mtime = item\n                                result[k].append(\n                                    {\n                                        \"name\": file_name,\n                                        \"path\": full_path,\n                                        \"size\": size,\n                                        \"size_formatted\": format_size(size),\n                                        \"mtime\": mtime,\n                                        \"mtime_formatted\": format_timestamp(mtime),\n                                    }\n                                )\n                            elif (\n                                self.sort_by_loc\n                                and self.sort_by_size\n                                and isinstance(item, tuple)\n                                and len(item) &gt; 3\n                            ):\n                                file_name, full_path, loc, size = item\n                                result[k].append(\n                                    {\n                                        \"name\": file_name,\n                                        \"path\": full_path,\n                                        \"loc\": loc,\n                                        \"size\": size,\n                                        \"size_formatted\": format_size(size),\n                                    }\n                                )\n                            elif self.sort_by_mtime and isinstance(item, tuple):\n                                if len(item) &gt; 4:\n                                    file_name, full_path, _, _, mtime = item\n                                elif len(item) &gt; 3:\n                                    file_name, full_path, _, mtime = item\n                                else:\n                                    file_name, full_path, mtime = item\n                                result[k].append(\n                                    {\n                                        \"name\": file_name,\n                                        \"path\": full_path,\n                                        \"mtime\": mtime,\n                                        \"mtime_formatted\": format_timestamp(mtime),\n                                    }\n                                )\n                            elif self.sort_by_size and isinstance(item, tuple):\n                                if len(item) &gt; 3:\n                                    file_name, full_path, _, size = item\n                                    result[k].append(\n                                        {\n                                            \"name\": file_name,\n                                            \"path\": full_path,\n                                            \"size\": size,\n                                            \"size_formatted\": format_size(size),\n                                        }\n                                    )\n                                elif len(item) &gt; 2:\n                                    file_name, full_path, size = item\n                                    result[k].append(\n                                        {\n                                            \"name\": file_name,\n                                            \"path\": full_path,\n                                            \"size\": size,\n                                            \"size_formatted\": format_size(size),\n                                        }\n                                    )\n                                else:\n                                    file_name, full_path = item\n                                    result[k].append(\n                                        full_path if self.show_full_path else file_name\n                                    )\n                            elif (\n                                self.sort_by_loc\n                                and isinstance(item, tuple)\n                                and len(item) &gt; 2\n                            ):\n                                file_name, full_path, loc = item\n                                result[k].append(\n                                    {\"name\": file_name, \"path\": full_path, \"loc\": loc}\n                                )\n                            elif isinstance(item, tuple):\n                                if len(item) &gt; 4:\n                                    _, full_path, _, _, _ = item\n                                elif len(item) &gt; 3:\n                                    _, full_path, _, _ = item\n                                elif len(item) &gt; 2:\n                                    _, full_path, _ = item\n                                else:\n                                    _, full_path = item\n                                result[k].append(full_path)\n                            else:\n                                result[k].append(item)\n                    elif k == \"_loc\":\n                        if self.sort_by_loc:\n                            result[k] = v\n                    elif k == \"_size\":\n                        if self.sort_by_size:\n                            result[k] = v\n                            result[\"_size_formatted\"] = format_size(v)\n                    elif k == \"_mtime\":\n                        if self.sort_by_mtime:\n                            result[k] = v\n                            result[\"_mtime_formatted\"] = format_timestamp(v)\n                    elif k == \"_max_depth_reached\":\n                        result[k] = v\n                    elif isinstance(v, dict):\n                        result[k] = convert_structure_for_json(v)\n                    else:\n                        result[k] = v\n                return result\n\n            export_structure = convert_structure_for_json(self.structure)\n        else:\n            export_structure = self.structure\n        try:\n            with open(output_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(\n                    {\n                        \"root\": self.root_name,\n                        \"structure\": export_structure,\n                        \"show_loc\": self.sort_by_loc,\n                        \"show_size\": self.sort_by_size,\n                        \"show_mtime\": self.sort_by_mtime,\n                    },\n                    f,\n                    indent=2,\n                )\n        except Exception as e:\n            logger.error(f\"Error exporting to JSON: {e}\")\n            raise\n\n    def to_html(self, output_path: str) -&gt; None:\n        \"\"\"Export directory structure to an HTML file.\n\n        Creates a standalone HTML file with a styled representation of the directory structure using\n        nested unordered lists with CSS styling for colors and indentation.\n\n        Args:\n            output_path: Path where the HTML file will be saved\n        \"\"\"\n\n        def _build_html_tree(\n            structure: Dict[str, Any],\n            path_prefix: str = \"\",\n        ) -&gt; str:\n            html_content = [\"&lt;ul&gt;\"]\n            if \"_files\" in structure:\n                for file_item in sort_files_by_type(\n                    structure[\"_files\"],\n                    self.sort_by_loc,\n                    self.sort_by_size,\n                    self.sort_by_mtime,\n                ):\n                    if (\n                        self.sort_by_loc\n                        and self.sort_by_size\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 4\n                    ):\n                        _, display_path, loc, size, mtime = file_item\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})&lt;/li&gt;'\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, _, mtime = file_item\n                        else:\n                            _, display_path, loc, mtime = file_item\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({loc} lines, {format_timestamp(mtime)})&lt;/li&gt;'\n                        )\n                    elif (\n                        self.sort_by_size\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, size, mtime = file_item\n                        else:\n                            _, display_path, size, mtime = file_item\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({format_size(size)}, {format_timestamp(mtime)})&lt;/li&gt;'\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and self.sort_by_size\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, size, _ = file_item\n                        else:\n                            _, display_path, loc, size = file_item\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({loc} lines, {format_size(size)})&lt;/li&gt;'\n                        )\n                    elif (\n                        self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, _, mtime = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, _, mtime = file_item\n                        else:\n                            _, display_path, mtime = file_item\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({format_timestamp(mtime)})&lt;/li&gt;'\n                        )\n                    elif (\n                        self.sort_by_size\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, size, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, _, size = file_item\n                        else:\n                            _, display_path, size = file_item\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({format_size(size)})&lt;/li&gt;'\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, loc, _ = file_item\n                        else:\n                            _, display_path, loc = file_item\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({loc} lines)&lt;/li&gt;'\n                        )\n                    elif self.show_full_path and isinstance(file_item, tuple):\n                        if len(file_item) &gt; 4:\n                            _, full_path, _, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, full_path, _, _ = file_item\n                        elif len(file_item) &gt; 2:\n                            _, full_path, _ = file_item\n                        else:\n                            _, full_path = file_item\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(full_path)}&lt;/li&gt;'\n                        )\n                    else:\n                        if isinstance(file_item, tuple):\n                            if len(file_item) &gt; 4:\n                                filename_str, _, _, _, _ = file_item\n                            elif len(file_item) &gt; 3:\n                                filename_str, _, _, _ = file_item\n                            elif len(file_item) &gt; 2:\n                                filename_str, _, _ = file_item\n                            else:\n                                filename_str, _ = file_item\n                        else:\n                            filename_str = cast(str, file_item)\n                        html_content.append(\n                            f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(filename_str)}&lt;/li&gt;'\n                        )\n            for name, content in sorted(structure.items()):\n                if (\n                    name == \"_files\"\n                    or name == \"_max_depth_reached\"\n                    or name == \"_loc\"\n                    or name == \"_size\"\n                    or name == \"_mtime\"\n                ):\n                    continue\n                if (\n                    self.sort_by_loc\n                    and self.sort_by_size\n                    and self.sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_size\" in content\n                    and \"_mtime\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    size_count = content[\"_size\"]\n                    mtime_count = content[\"_mtime\"]\n                    html_content.append(\n                        f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                        f'&lt;span class=\"metric-count\"&gt;({loc_count} lines, {format_size(size_count)}, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    self.sort_by_loc\n                    and self.sort_by_size\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_size\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    size_count = content[\"_size\"]\n                    html_content.append(\n                        f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                        f'&lt;span class=\"metric-count\"&gt;({loc_count} lines, {format_size(size_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    self.sort_by_loc\n                    and self.sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_mtime\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    mtime_count = content[\"_mtime\"]\n                    html_content.append(\n                        f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                        f'&lt;span class=\"metric-count\"&gt;({loc_count} lines, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    self.sort_by_size\n                    and self.sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_size\" in content\n                    and \"_mtime\" in content\n                ):\n                    size_count = content[\"_size\"]\n                    mtime_count = content[\"_mtime\"]\n                    html_content.append(\n                        f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                        f'&lt;span class=\"metric-count\"&gt;({format_size(size_count)}, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    self.sort_by_loc and isinstance(content, dict) and \"_loc\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    html_content.append(\n                        f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                        f'&lt;span class=\"loc-count\"&gt;({loc_count} lines)&lt;/span&gt;'\n                    )\n                elif (\n                    self.sort_by_size\n                    and isinstance(content, dict)\n                    and \"_size\" in content\n                ):\n                    size_count = content[\"_size\"]\n                    html_content.append(\n                        f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                        f'&lt;span class=\"size-count\"&gt;({format_size(size_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    self.sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_mtime\" in content\n                ):\n                    mtime_count = content[\"_mtime\"]\n                    html_content.append(\n                        f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                        f'&lt;span class=\"mtime-count\"&gt;({format_timestamp(mtime_count)})&lt;/span&gt;'\n                    )\n                else:\n                    html_content.append(\n                        f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt;'\n                    )\n                next_path = os.path.join(path_prefix, name) if path_prefix else name\n                if isinstance(content, dict):\n                    if content.get(\"_max_depth_reached\"):\n                        html_content.append(\n                            '&lt;ul&gt;&lt;li class=\"max-depth\"&gt;\u22ef (max depth reached)&lt;/li&gt;&lt;/ul&gt;'\n                        )\n                    else:\n                        html_content.append(_build_html_tree(content, next_path))\n                html_content.append(\"&lt;/li&gt;\")\n            html_content.append(\"&lt;/ul&gt;\")\n            return \"\\n\".join(html_content)\n\n        title = f\"\ud83d\udcc2 {html.escape(self.root_name)}\"\n        if (\n            self.sort_by_loc\n            and self.sort_by_size\n            and self.sort_by_mtime\n            and \"_loc\" in self.structure\n            and \"_size\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\"\n        elif (\n            self.sort_by_loc\n            and self.sort_by_size\n            and \"_loc\" in self.structure\n            and \"_size\" in self.structure\n        ):\n            title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])})\"\n        elif (\n            self.sort_by_loc\n            and self.sort_by_mtime\n            and \"_loc\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({self.structure['_loc']} lines, {format_timestamp(self.structure['_mtime'])})\"\n        elif (\n            self.sort_by_size\n            and self.sort_by_mtime\n            and \"_size\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\"\n        elif self.sort_by_loc and \"_loc\" in self.structure:\n            title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({self.structure['_loc']} lines)\"\n        elif self.sort_by_size and \"_size\" in self.structure:\n            title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({format_size(self.structure['_size'])})\"\n        elif self.sort_by_mtime and \"_mtime\" in self.structure:\n            title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({format_timestamp(self.structure['_mtime'])})\"\n        loc_styles = (\n            \"\"\"\n            .loc-count {\n                color: #666;\n                font-size: 0.9em;\n                font-weight: normal;\n            }\n        \"\"\"\n            if self.sort_by_loc\n            else \"\"\n        )\n        size_styles = (\n            \"\"\"\n            .size-count {\n                color: #666;\n                font-size: 0.9em;\n                font-weight: normal;\n            }\n        \"\"\"\n            if self.sort_by_size\n            else \"\"\n        )\n        mtime_styles = (\n            \"\"\"\n            .mtime-count {\n                color: #666;\n                font-size: 0.9em;\n                font-weight: normal;\n            }\n        \"\"\"\n            if self.sort_by_mtime\n            else \"\"\n        )\n        metric_styles = (\n            \"\"\"\n            .metric-count {\n                color: #666;\n                font-size: 0.9em;\n                font-weight: normal;\n            }\n        \"\"\"\n            if (self.sort_by_size and self.sort_by_loc)\n            or (self.sort_by_mtime and (self.sort_by_loc or self.sort_by_size))\n            else \"\"\n        )\n        html_template = f\"\"\"\n        &lt;!DOCTYPE html&gt;\n        &lt;html&gt;\n        &lt;head&gt;\n            &lt;meta charset=\"utf-8\"&gt;\n            &lt;title&gt;Directory Structure - {html.escape(self.root_name)}&lt;/title&gt;\n            &lt;style&gt;\n                body {{\n                    font-family: Arial, sans-serif;\n                    margin: 20px;\n                }}\n                ul {{\n                    list-style-type: none;\n                    padding-left: 20px;\n                }}\n                .directory {{\n                    color: #2c3e50;\n                }}\n                .dir-name {{\n                    font-weight: bold;\n                }}\n                .file {{\n                    color: #34495e;\n                }}\n                .max-depth {{\n                    color: #999;\n                    font-style: italic;\n                }}\n                .path-info {{\n                    margin-bottom: 20px;\n                    font-style: italic;\n                    color: #666;\n                }}\n                {loc_styles}\n                {size_styles}\n                {mtime_styles}\n                {metric_styles}\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;h1&gt;{title}&lt;/h1&gt;\n            {_build_html_tree(self.structure, self.root_name if self.show_full_path else \"\")}\n        &lt;/body&gt;\n        &lt;/html&gt;\n        \"\"\"\n\n        try:\n            with open(output_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(html_template)\n        except Exception as e:\n            logger.error(f\"Error exporting to HTML: {e}\")\n            raise\n\n    def to_markdown(self, output_path: str) -&gt; None:\n        \"\"\"Export directory structure to a Markdown file.\n\n        Creates a Markdown file with a structured representation of the directory hierarchy using\n        headings, lists, and formatting to distinguish between files and directories.\n\n        Args:\n            output_path: Path where the Markdown file will be saved\n        \"\"\"\n\n        def _build_md_tree(\n            structure: Dict[str, Any],\n            level: int = 0,\n            path_prefix: str = \"\",\n        ) -&gt; List[str]:\n            lines = []\n            indent = \"    \" * level\n            if \"_files\" in structure:\n                for file_item in sort_files_by_type(\n                    structure[\"_files\"],\n                    self.sort_by_loc,\n                    self.sort_by_size,\n                    self.sort_by_mtime,\n                ):\n                    if (\n                        self.sort_by_loc\n                        and self.sort_by_size\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 4\n                    ):\n                        _, display_path, loc, size, mtime = file_item\n                        lines.append(\n                            f\"{indent}- \ud83d\udcc4 `{display_path}` ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, _, mtime = file_item\n                        else:\n                            _, display_path, loc, mtime = file_item\n                        lines.append(\n                            f\"{indent}- \ud83d\udcc4 `{display_path}` ({loc} lines, {format_timestamp(mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_size\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, size, mtime = file_item\n                        else:\n                            _, display_path, size, mtime = file_item\n                        lines.append(\n                            f\"{indent}- \ud83d\udcc4 `{display_path}` ({format_size(size)}, {format_timestamp(mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and self.sort_by_size\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, size, _ = file_item\n                        else:\n                            _, display_path, loc, size = file_item\n                        lines.append(\n                            f\"{indent}- \ud83d\udcc4 `{display_path}` ({loc} lines, {format_size(size)})\"\n                        )\n                    elif (\n                        self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, _, mtime = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, _, mtime = file_item\n                        else:\n                            _, display_path, mtime = file_item\n                        lines.append(\n                            f\"{indent}- \ud83d\udcc4 `{display_path}` ({format_timestamp(mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_size\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, size, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, _, size = file_item\n                        else:\n                            _, display_path, size = file_item\n                        lines.append(\n                            f\"{indent}- \ud83d\udcc4 `{display_path}` ({format_size(size)})\"\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, loc, _ = file_item\n                        else:\n                            _, display_path, loc = file_item\n                        lines.append(f\"{indent}- \ud83d\udcc4 `{display_path}` ({loc} lines)\")\n                    elif self.show_full_path and isinstance(file_item, tuple):\n                        if len(file_item) &gt; 4:\n                            _, full_path, _, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, full_path, _, _ = file_item\n                        elif len(file_item) &gt; 2:\n                            _, full_path, _ = file_item\n                        else:\n                            _, full_path = file_item\n                        lines.append(f\"{indent}- \ud83d\udcc4 `{full_path}`\")\n                    else:\n                        if isinstance(file_item, tuple):\n                            if len(file_item) &gt; 4:\n                                file_name, _, _, _, _ = file_item\n                            elif len(file_item) &gt; 3:\n                                file_name, _, _, _ = file_item\n                            elif len(file_item) &gt; 2:\n                                file_name, _, _ = file_item\n                            else:\n                                file_name, _ = file_item\n                        else:\n                            file_name = file_item\n                        lines.append(f\"{indent}- \ud83d\udcc4 `{file_name}`\")\n            for name, content in sorted(structure.items()):\n                if (\n                    name == \"_files\"\n                    or name == \"_max_depth_reached\"\n                    or name == \"_loc\"\n                    or name == \"_size\"\n                    or name == \"_mtime\"\n                ):\n                    continue\n                if (\n                    self.sort_by_loc\n                    and self.sort_by_size\n                    and self.sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_size\" in content\n                    and \"_mtime\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    size_count = content[\"_size\"]\n                    mtime_count = content[\"_mtime\"]\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc1 **{name}** ({loc_count} lines, {format_size(size_count)}, {format_timestamp(mtime_count)})\"\n                    )\n                elif (\n                    self.sort_by_loc\n                    and self.sort_by_size\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_size\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    size_count = content[\"_size\"]\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc1 **{name}** ({loc_count} lines, {format_size(size_count)})\"\n                    )\n                elif (\n                    self.sort_by_loc\n                    and self.sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_mtime\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    mtime_count = content[\"_mtime\"]\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc1 **{name}** ({loc_count} lines, {format_timestamp(mtime_count)})\"\n                    )\n                elif (\n                    self.sort_by_size\n                    and self.sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_size\" in content\n                    and \"_mtime\" in content\n                ):\n                    size_count = content[\"_size\"]\n                    mtime_count = content[\"_mtime\"]\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc1 **{name}** ({format_size(size_count)}, {format_timestamp(mtime_count)})\"\n                    )\n                elif (\n                    self.sort_by_loc and isinstance(content, dict) and \"_loc\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    lines.append(f\"{indent}- \ud83d\udcc1 **{name}** ({loc_count} lines)\")\n                elif (\n                    self.sort_by_size\n                    and isinstance(content, dict)\n                    and \"_size\" in content\n                ):\n                    size_count = content[\"_size\"]\n                    lines.append(f\"{indent}- \ud83d\udcc1 **{name}** ({format_size(size_count)})\")\n                elif (\n                    self.sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_mtime\" in content\n                ):\n                    mtime_count = content[\"_mtime\"]\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc1 **{name}** ({format_timestamp(mtime_count)})\"\n                    )\n                else:\n                    lines.append(f\"{indent}- \ud83d\udcc1 **{name}**\")\n                next_path = os.path.join(path_prefix, name) if path_prefix else name\n                if isinstance(content, dict):\n                    if content.get(\"_max_depth_reached\"):\n                        lines.append(f\"{indent}    - \u22ef *(max depth reached)*\")\n                    else:\n                        lines.extend(_build_md_tree(content, level + 1, next_path))\n            return lines\n\n        if (\n            self.sort_by_loc\n            and self.sort_by_size\n            and self.sort_by_mtime\n            and \"_loc\" in self.structure\n            and \"_size\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            md_content = [\n                f\"# \ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\",\n                \"\",\n            ]\n        elif (\n            self.sort_by_loc\n            and self.sort_by_size\n            and \"_loc\" in self.structure\n            and \"_size\" in self.structure\n        ):\n            md_content = [\n                f\"# \ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])})\",\n                \"\",\n            ]\n        elif (\n            self.sort_by_loc\n            and self.sort_by_mtime\n            and \"_loc\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            md_content = [\n                f\"# \ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_timestamp(self.structure['_mtime'])})\",\n                \"\",\n            ]\n        elif (\n            self.sort_by_size\n            and self.sort_by_mtime\n            and \"_size\" in self.structure\n            and \"_mtime\" in self.structure\n        ):\n            md_content = [\n                f\"# \ud83d\udcc2 {self.root_name} ({format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\",\n                \"\",\n            ]\n        elif self.sort_by_loc and \"_loc\" in self.structure:\n            md_content = [f\"# \ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines)\", \"\"]\n        elif self.sort_by_size and \"_size\" in self.structure:\n            md_content = [\n                f\"# \ud83d\udcc2 {self.root_name} ({format_size(self.structure['_size'])})\",\n                \"\",\n            ]\n        elif self.sort_by_mtime and \"_mtime\" in self.structure:\n            md_content = [\n                f\"# \ud83d\udcc2 {self.root_name} ({format_timestamp(self.structure['_mtime'])})\",\n                \"\",\n            ]\n        else:\n            md_content = [f\"# \ud83d\udcc2 {self.root_name}\", \"\"]\n        md_content.extend(\n            _build_md_tree(\n                self.structure, 0, self.root_name if self.show_full_path else \"\"\n            )\n        )\n        try:\n            with open(output_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"\\n\".join(md_content))\n        except Exception as e:\n            logger.error(f\"Error exporting to Markdown: {e}\")\n            raise\n\n    def to_jsx(self, output_path: str) -&gt; None:\n        \"\"\"Export directory structure to a React component (JSX file).\n\n        Creates a JSX file containing a React component for interactive visualization\n        of the directory structure with collapsible folders and styling.\n\n        Args:\n            output_path: Path where the React component file will be saved\n        \"\"\"\n\n        try:\n            generate_jsx_component(\n                self.structure,\n                self.root_name,\n                output_path,\n                self.show_full_path,\n                self.sort_by_loc,\n                self.sort_by_size,\n                self.sort_by_mtime,\n            )\n        except Exception as e:\n            logger.error(f\"Error exporting to React component: {e}\")\n            raise\n</code></pre>"},{"location":"reference/api-reference/#recursivist.exports.DirectoryExporter.__init__","title":"<code>__init__(structure, root_name, base_path=None, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Initialize the exporter with directory structure and root name.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Dict[str, Any]</code> <p>The directory structure dictionary</p> required <code>root_name</code> <code>str</code> <p>Name of the root directory</p> required <code>base_path</code> <code>Optional[str]</code> <p>Base path for full path display (if None, only show filenames)</p> <code>None</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to include lines of code counts in exports</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to include file size information in exports</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to include modification time information in exports</p> <code>False</code> Source code in <code>recursivist/exports.py</code> <pre><code>def __init__(\n    self,\n    structure: Dict[str, Any],\n    root_name: str,\n    base_path: Optional[str] = None,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n):\n    \"\"\"Initialize the exporter with directory structure and root name.\n\n    Args:\n        structure: The directory structure dictionary\n        root_name: Name of the root directory\n        base_path: Base path for full path display (if None, only show filenames)\n        sort_by_loc: Whether to include lines of code counts in exports\n        sort_by_size: Whether to include file size information in exports\n        sort_by_mtime: Whether to include modification time information in exports\n    \"\"\"\n\n    self.structure = structure\n    self.root_name = root_name\n    self.base_path = base_path\n    self.show_full_path = base_path is not None\n    self.sort_by_loc = sort_by_loc\n    self.sort_by_size = sort_by_size\n    self.sort_by_mtime = sort_by_mtime\n</code></pre>"},{"location":"reference/api-reference/#recursivist.exports.DirectoryExporter.to_html","title":"<code>to_html(output_path)</code>","text":"<p>Export directory structure to an HTML file.</p> <p>Creates a standalone HTML file with a styled representation of the directory structure using nested unordered lists with CSS styling for colors and indentation.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>Path where the HTML file will be saved</p> required Source code in <code>recursivist/exports.py</code> <pre><code>def to_html(self, output_path: str) -&gt; None:\n    \"\"\"Export directory structure to an HTML file.\n\n    Creates a standalone HTML file with a styled representation of the directory structure using\n    nested unordered lists with CSS styling for colors and indentation.\n\n    Args:\n        output_path: Path where the HTML file will be saved\n    \"\"\"\n\n    def _build_html_tree(\n        structure: Dict[str, Any],\n        path_prefix: str = \"\",\n    ) -&gt; str:\n        html_content = [\"&lt;ul&gt;\"]\n        if \"_files\" in structure:\n            for file_item in sort_files_by_type(\n                structure[\"_files\"],\n                self.sort_by_loc,\n                self.sort_by_size,\n                self.sort_by_mtime,\n            ):\n                if (\n                    self.sort_by_loc\n                    and self.sort_by_size\n                    and self.sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 4\n                ):\n                    _, display_path, loc, size, mtime = file_item\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})&lt;/li&gt;'\n                    )\n                elif (\n                    self.sort_by_loc\n                    and self.sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, loc, _, mtime = file_item\n                    else:\n                        _, display_path, loc, mtime = file_item\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({loc} lines, {format_timestamp(mtime)})&lt;/li&gt;'\n                    )\n                elif (\n                    self.sort_by_size\n                    and self.sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, _, size, mtime = file_item\n                    else:\n                        _, display_path, size, mtime = file_item\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({format_size(size)}, {format_timestamp(mtime)})&lt;/li&gt;'\n                    )\n                elif (\n                    self.sort_by_loc\n                    and self.sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, loc, size, _ = file_item\n                    else:\n                        _, display_path, loc, size = file_item\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({loc} lines, {format_size(size)})&lt;/li&gt;'\n                    )\n                elif (\n                    self.sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, _, _, mtime = file_item\n                    elif len(file_item) &gt; 3:\n                        _, display_path, _, mtime = file_item\n                    else:\n                        _, display_path, mtime = file_item\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({format_timestamp(mtime)})&lt;/li&gt;'\n                    )\n                elif (\n                    self.sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, _, size, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        _, display_path, _, size = file_item\n                    else:\n                        _, display_path, size = file_item\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({format_size(size)})&lt;/li&gt;'\n                    )\n                elif (\n                    self.sort_by_loc\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, loc, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        _, display_path, loc, _ = file_item\n                    else:\n                        _, display_path, loc = file_item\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(display_path)} ({loc} lines)&lt;/li&gt;'\n                    )\n                elif self.show_full_path and isinstance(file_item, tuple):\n                    if len(file_item) &gt; 4:\n                        _, full_path, _, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        _, full_path, _, _ = file_item\n                    elif len(file_item) &gt; 2:\n                        _, full_path, _ = file_item\n                    else:\n                        _, full_path = file_item\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(full_path)}&lt;/li&gt;'\n                    )\n                else:\n                    if isinstance(file_item, tuple):\n                        if len(file_item) &gt; 4:\n                            filename_str, _, _, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            filename_str, _, _, _ = file_item\n                        elif len(file_item) &gt; 2:\n                            filename_str, _, _ = file_item\n                        else:\n                            filename_str, _ = file_item\n                    else:\n                        filename_str = cast(str, file_item)\n                    html_content.append(\n                        f'&lt;li class=\"file\"&gt;\ud83d\udcc4 {html.escape(filename_str)}&lt;/li&gt;'\n                    )\n        for name, content in sorted(structure.items()):\n            if (\n                name == \"_files\"\n                or name == \"_max_depth_reached\"\n                or name == \"_loc\"\n                or name == \"_size\"\n                or name == \"_mtime\"\n            ):\n                continue\n            if (\n                self.sort_by_loc\n                and self.sort_by_size\n                and self.sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                size_count = content[\"_size\"]\n                mtime_count = content[\"_mtime\"]\n                html_content.append(\n                    f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                    f'&lt;span class=\"metric-count\"&gt;({loc_count} lines, {format_size(size_count)}, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                )\n            elif (\n                self.sort_by_loc\n                and self.sort_by_size\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                size_count = content[\"_size\"]\n                html_content.append(\n                    f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                    f'&lt;span class=\"metric-count\"&gt;({loc_count} lines, {format_size(size_count)})&lt;/span&gt;'\n                )\n            elif (\n                self.sort_by_loc\n                and self.sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_mtime\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                mtime_count = content[\"_mtime\"]\n                html_content.append(\n                    f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                    f'&lt;span class=\"metric-count\"&gt;({loc_count} lines, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                )\n            elif (\n                self.sort_by_size\n                and self.sort_by_mtime\n                and isinstance(content, dict)\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                size_count = content[\"_size\"]\n                mtime_count = content[\"_mtime\"]\n                html_content.append(\n                    f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                    f'&lt;span class=\"metric-count\"&gt;({format_size(size_count)}, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                )\n            elif (\n                self.sort_by_loc and isinstance(content, dict) and \"_loc\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                html_content.append(\n                    f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                    f'&lt;span class=\"loc-count\"&gt;({loc_count} lines)&lt;/span&gt;'\n                )\n            elif (\n                self.sort_by_size\n                and isinstance(content, dict)\n                and \"_size\" in content\n            ):\n                size_count = content[\"_size\"]\n                html_content.append(\n                    f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                    f'&lt;span class=\"size-count\"&gt;({format_size(size_count)})&lt;/span&gt;'\n                )\n            elif (\n                self.sort_by_mtime\n                and isinstance(content, dict)\n                and \"_mtime\" in content\n            ):\n                mtime_count = content[\"_mtime\"]\n                html_content.append(\n                    f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt; '\n                    f'&lt;span class=\"mtime-count\"&gt;({format_timestamp(mtime_count)})&lt;/span&gt;'\n                )\n            else:\n                html_content.append(\n                    f'&lt;li class=\"directory\"&gt;\ud83d\udcc1 &lt;span class=\"dir-name\"&gt;{html.escape(name)}&lt;/span&gt;'\n                )\n            next_path = os.path.join(path_prefix, name) if path_prefix else name\n            if isinstance(content, dict):\n                if content.get(\"_max_depth_reached\"):\n                    html_content.append(\n                        '&lt;ul&gt;&lt;li class=\"max-depth\"&gt;\u22ef (max depth reached)&lt;/li&gt;&lt;/ul&gt;'\n                    )\n                else:\n                    html_content.append(_build_html_tree(content, next_path))\n            html_content.append(\"&lt;/li&gt;\")\n        html_content.append(\"&lt;/ul&gt;\")\n        return \"\\n\".join(html_content)\n\n    title = f\"\ud83d\udcc2 {html.escape(self.root_name)}\"\n    if (\n        self.sort_by_loc\n        and self.sort_by_size\n        and self.sort_by_mtime\n        and \"_loc\" in self.structure\n        and \"_size\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\"\n    elif (\n        self.sort_by_loc\n        and self.sort_by_size\n        and \"_loc\" in self.structure\n        and \"_size\" in self.structure\n    ):\n        title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])})\"\n    elif (\n        self.sort_by_loc\n        and self.sort_by_mtime\n        and \"_loc\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({self.structure['_loc']} lines, {format_timestamp(self.structure['_mtime'])})\"\n    elif (\n        self.sort_by_size\n        and self.sort_by_mtime\n        and \"_size\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\"\n    elif self.sort_by_loc and \"_loc\" in self.structure:\n        title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({self.structure['_loc']} lines)\"\n    elif self.sort_by_size and \"_size\" in self.structure:\n        title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({format_size(self.structure['_size'])})\"\n    elif self.sort_by_mtime and \"_mtime\" in self.structure:\n        title = f\"\ud83d\udcc2 {html.escape(self.root_name)} ({format_timestamp(self.structure['_mtime'])})\"\n    loc_styles = (\n        \"\"\"\n        .loc-count {\n            color: #666;\n            font-size: 0.9em;\n            font-weight: normal;\n        }\n    \"\"\"\n        if self.sort_by_loc\n        else \"\"\n    )\n    size_styles = (\n        \"\"\"\n        .size-count {\n            color: #666;\n            font-size: 0.9em;\n            font-weight: normal;\n        }\n    \"\"\"\n        if self.sort_by_size\n        else \"\"\n    )\n    mtime_styles = (\n        \"\"\"\n        .mtime-count {\n            color: #666;\n            font-size: 0.9em;\n            font-weight: normal;\n        }\n    \"\"\"\n        if self.sort_by_mtime\n        else \"\"\n    )\n    metric_styles = (\n        \"\"\"\n        .metric-count {\n            color: #666;\n            font-size: 0.9em;\n            font-weight: normal;\n        }\n    \"\"\"\n        if (self.sort_by_size and self.sort_by_loc)\n        or (self.sort_by_mtime and (self.sort_by_loc or self.sort_by_size))\n        else \"\"\n    )\n    html_template = f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\"&gt;\n        &lt;title&gt;Directory Structure - {html.escape(self.root_name)}&lt;/title&gt;\n        &lt;style&gt;\n            body {{\n                font-family: Arial, sans-serif;\n                margin: 20px;\n            }}\n            ul {{\n                list-style-type: none;\n                padding-left: 20px;\n            }}\n            .directory {{\n                color: #2c3e50;\n            }}\n            .dir-name {{\n                font-weight: bold;\n            }}\n            .file {{\n                color: #34495e;\n            }}\n            .max-depth {{\n                color: #999;\n                font-style: italic;\n            }}\n            .path-info {{\n                margin-bottom: 20px;\n                font-style: italic;\n                color: #666;\n            }}\n            {loc_styles}\n            {size_styles}\n            {mtime_styles}\n            {metric_styles}\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;{title}&lt;/h1&gt;\n        {_build_html_tree(self.structure, self.root_name if self.show_full_path else \"\")}\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    try:\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(html_template)\n    except Exception as e:\n        logger.error(f\"Error exporting to HTML: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api-reference/#recursivist.exports.DirectoryExporter.to_json","title":"<code>to_json(output_path)</code>","text":"<p>Export directory structure to a JSON file.</p> <p>Creates a JSON file containing the directory structure with options for including full paths, LOC counts, file sizes, and modification times. The JSON structure includes a root name and the hierarchical structure of directories and files.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>Path where the JSON file will be saved</p> required Source code in <code>recursivist/exports.py</code> <pre><code>def to_json(self, output_path: str) -&gt; None:\n    \"\"\"Export directory structure to a JSON file.\n\n    Creates a JSON file containing the directory structure with options for including full paths, LOC counts, file sizes, and modification times. The JSON structure includes a root name and the hierarchical structure of directories and files.\n\n    Args:\n        output_path: Path where the JSON file will be saved\n    \"\"\"\n\n    if (\n        self.show_full_path\n        or self.sort_by_loc\n        or self.sort_by_size\n        or self.sort_by_mtime\n    ):\n\n        def convert_structure_for_json(structure):\n            result = {}\n            for k, v in structure.items():\n                if k == \"_files\":\n                    result[k] = []\n                    for item in v:\n                        if (\n                            self.sort_by_loc\n                            and self.sort_by_size\n                            and self.sort_by_mtime\n                            and isinstance(item, tuple)\n                            and len(item) &gt; 4\n                        ):\n                            file_name, full_path, loc, size, mtime = item\n                            result[k].append(\n                                {\n                                    \"name\": file_name,\n                                    \"path\": full_path,\n                                    \"loc\": loc,\n                                    \"size\": size,\n                                    \"size_formatted\": format_size(size),\n                                    \"mtime\": mtime,\n                                    \"mtime_formatted\": format_timestamp(mtime),\n                                }\n                            )\n                        elif (\n                            self.sort_by_loc\n                            and self.sort_by_mtime\n                            and isinstance(item, tuple)\n                            and len(item) &gt; 4\n                        ):\n                            file_name, full_path, loc, _, mtime = item\n                            result[k].append(\n                                {\n                                    \"name\": file_name,\n                                    \"path\": full_path,\n                                    \"loc\": loc,\n                                    \"mtime\": mtime,\n                                    \"mtime_formatted\": format_timestamp(mtime),\n                                }\n                            )\n                        elif (\n                            self.sort_by_size\n                            and self.sort_by_mtime\n                            and isinstance(item, tuple)\n                            and len(item) &gt; 4\n                        ):\n                            file_name, full_path, _, size, mtime = item\n                            result[k].append(\n                                {\n                                    \"name\": file_name,\n                                    \"path\": full_path,\n                                    \"size\": size,\n                                    \"size_formatted\": format_size(size),\n                                    \"mtime\": mtime,\n                                    \"mtime_formatted\": format_timestamp(mtime),\n                                }\n                            )\n                        elif (\n                            self.sort_by_loc\n                            and self.sort_by_size\n                            and isinstance(item, tuple)\n                            and len(item) &gt; 3\n                        ):\n                            file_name, full_path, loc, size = item\n                            result[k].append(\n                                {\n                                    \"name\": file_name,\n                                    \"path\": full_path,\n                                    \"loc\": loc,\n                                    \"size\": size,\n                                    \"size_formatted\": format_size(size),\n                                }\n                            )\n                        elif self.sort_by_mtime and isinstance(item, tuple):\n                            if len(item) &gt; 4:\n                                file_name, full_path, _, _, mtime = item\n                            elif len(item) &gt; 3:\n                                file_name, full_path, _, mtime = item\n                            else:\n                                file_name, full_path, mtime = item\n                            result[k].append(\n                                {\n                                    \"name\": file_name,\n                                    \"path\": full_path,\n                                    \"mtime\": mtime,\n                                    \"mtime_formatted\": format_timestamp(mtime),\n                                }\n                            )\n                        elif self.sort_by_size and isinstance(item, tuple):\n                            if len(item) &gt; 3:\n                                file_name, full_path, _, size = item\n                                result[k].append(\n                                    {\n                                        \"name\": file_name,\n                                        \"path\": full_path,\n                                        \"size\": size,\n                                        \"size_formatted\": format_size(size),\n                                    }\n                                )\n                            elif len(item) &gt; 2:\n                                file_name, full_path, size = item\n                                result[k].append(\n                                    {\n                                        \"name\": file_name,\n                                        \"path\": full_path,\n                                        \"size\": size,\n                                        \"size_formatted\": format_size(size),\n                                    }\n                                )\n                            else:\n                                file_name, full_path = item\n                                result[k].append(\n                                    full_path if self.show_full_path else file_name\n                                )\n                        elif (\n                            self.sort_by_loc\n                            and isinstance(item, tuple)\n                            and len(item) &gt; 2\n                        ):\n                            file_name, full_path, loc = item\n                            result[k].append(\n                                {\"name\": file_name, \"path\": full_path, \"loc\": loc}\n                            )\n                        elif isinstance(item, tuple):\n                            if len(item) &gt; 4:\n                                _, full_path, _, _, _ = item\n                            elif len(item) &gt; 3:\n                                _, full_path, _, _ = item\n                            elif len(item) &gt; 2:\n                                _, full_path, _ = item\n                            else:\n                                _, full_path = item\n                            result[k].append(full_path)\n                        else:\n                            result[k].append(item)\n                elif k == \"_loc\":\n                    if self.sort_by_loc:\n                        result[k] = v\n                elif k == \"_size\":\n                    if self.sort_by_size:\n                        result[k] = v\n                        result[\"_size_formatted\"] = format_size(v)\n                elif k == \"_mtime\":\n                    if self.sort_by_mtime:\n                        result[k] = v\n                        result[\"_mtime_formatted\"] = format_timestamp(v)\n                elif k == \"_max_depth_reached\":\n                    result[k] = v\n                elif isinstance(v, dict):\n                    result[k] = convert_structure_for_json(v)\n                else:\n                    result[k] = v\n            return result\n\n        export_structure = convert_structure_for_json(self.structure)\n    else:\n        export_structure = self.structure\n    try:\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(\n                {\n                    \"root\": self.root_name,\n                    \"structure\": export_structure,\n                    \"show_loc\": self.sort_by_loc,\n                    \"show_size\": self.sort_by_size,\n                    \"show_mtime\": self.sort_by_mtime,\n                },\n                f,\n                indent=2,\n            )\n    except Exception as e:\n        logger.error(f\"Error exporting to JSON: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api-reference/#recursivist.exports.DirectoryExporter.to_jsx","title":"<code>to_jsx(output_path)</code>","text":"<p>Export directory structure to a React component (JSX file).</p> <p>Creates a JSX file containing a React component for interactive visualization of the directory structure with collapsible folders and styling.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>Path where the React component file will be saved</p> required Source code in <code>recursivist/exports.py</code> <pre><code>def to_jsx(self, output_path: str) -&gt; None:\n    \"\"\"Export directory structure to a React component (JSX file).\n\n    Creates a JSX file containing a React component for interactive visualization\n    of the directory structure with collapsible folders and styling.\n\n    Args:\n        output_path: Path where the React component file will be saved\n    \"\"\"\n\n    try:\n        generate_jsx_component(\n            self.structure,\n            self.root_name,\n            output_path,\n            self.show_full_path,\n            self.sort_by_loc,\n            self.sort_by_size,\n            self.sort_by_mtime,\n        )\n    except Exception as e:\n        logger.error(f\"Error exporting to React component: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api-reference/#recursivist.exports.DirectoryExporter.to_markdown","title":"<code>to_markdown(output_path)</code>","text":"<p>Export directory structure to a Markdown file.</p> <p>Creates a Markdown file with a structured representation of the directory hierarchy using headings, lists, and formatting to distinguish between files and directories.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>Path where the Markdown file will be saved</p> required Source code in <code>recursivist/exports.py</code> <pre><code>def to_markdown(self, output_path: str) -&gt; None:\n    \"\"\"Export directory structure to a Markdown file.\n\n    Creates a Markdown file with a structured representation of the directory hierarchy using\n    headings, lists, and formatting to distinguish between files and directories.\n\n    Args:\n        output_path: Path where the Markdown file will be saved\n    \"\"\"\n\n    def _build_md_tree(\n        structure: Dict[str, Any],\n        level: int = 0,\n        path_prefix: str = \"\",\n    ) -&gt; List[str]:\n        lines = []\n        indent = \"    \" * level\n        if \"_files\" in structure:\n            for file_item in sort_files_by_type(\n                structure[\"_files\"],\n                self.sort_by_loc,\n                self.sort_by_size,\n                self.sort_by_mtime,\n            ):\n                if (\n                    self.sort_by_loc\n                    and self.sort_by_size\n                    and self.sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 4\n                ):\n                    _, display_path, loc, size, mtime = file_item\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc4 `{display_path}` ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\"\n                    )\n                elif (\n                    self.sort_by_loc\n                    and self.sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, loc, _, mtime = file_item\n                    else:\n                        _, display_path, loc, mtime = file_item\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc4 `{display_path}` ({loc} lines, {format_timestamp(mtime)})\"\n                    )\n                elif (\n                    self.sort_by_size\n                    and self.sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, _, size, mtime = file_item\n                    else:\n                        _, display_path, size, mtime = file_item\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc4 `{display_path}` ({format_size(size)}, {format_timestamp(mtime)})\"\n                    )\n                elif (\n                    self.sort_by_loc\n                    and self.sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, loc, size, _ = file_item\n                    else:\n                        _, display_path, loc, size = file_item\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc4 `{display_path}` ({loc} lines, {format_size(size)})\"\n                    )\n                elif (\n                    self.sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, _, _, mtime = file_item\n                    elif len(file_item) &gt; 3:\n                        _, display_path, _, mtime = file_item\n                    else:\n                        _, display_path, mtime = file_item\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc4 `{display_path}` ({format_timestamp(mtime)})\"\n                    )\n                elif (\n                    self.sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, _, size, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        _, display_path, _, size = file_item\n                    else:\n                        _, display_path, size = file_item\n                    lines.append(\n                        f\"{indent}- \ud83d\udcc4 `{display_path}` ({format_size(size)})\"\n                    )\n                elif (\n                    self.sort_by_loc\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, loc, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        _, display_path, loc, _ = file_item\n                    else:\n                        _, display_path, loc = file_item\n                    lines.append(f\"{indent}- \ud83d\udcc4 `{display_path}` ({loc} lines)\")\n                elif self.show_full_path and isinstance(file_item, tuple):\n                    if len(file_item) &gt; 4:\n                        _, full_path, _, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        _, full_path, _, _ = file_item\n                    elif len(file_item) &gt; 2:\n                        _, full_path, _ = file_item\n                    else:\n                        _, full_path = file_item\n                    lines.append(f\"{indent}- \ud83d\udcc4 `{full_path}`\")\n                else:\n                    if isinstance(file_item, tuple):\n                        if len(file_item) &gt; 4:\n                            file_name, _, _, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            file_name, _, _, _ = file_item\n                        elif len(file_item) &gt; 2:\n                            file_name, _, _ = file_item\n                        else:\n                            file_name, _ = file_item\n                    else:\n                        file_name = file_item\n                    lines.append(f\"{indent}- \ud83d\udcc4 `{file_name}`\")\n        for name, content in sorted(structure.items()):\n            if (\n                name == \"_files\"\n                or name == \"_max_depth_reached\"\n                or name == \"_loc\"\n                or name == \"_size\"\n                or name == \"_mtime\"\n            ):\n                continue\n            if (\n                self.sort_by_loc\n                and self.sort_by_size\n                and self.sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                size_count = content[\"_size\"]\n                mtime_count = content[\"_mtime\"]\n                lines.append(\n                    f\"{indent}- \ud83d\udcc1 **{name}** ({loc_count} lines, {format_size(size_count)}, {format_timestamp(mtime_count)})\"\n                )\n            elif (\n                self.sort_by_loc\n                and self.sort_by_size\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                size_count = content[\"_size\"]\n                lines.append(\n                    f\"{indent}- \ud83d\udcc1 **{name}** ({loc_count} lines, {format_size(size_count)})\"\n                )\n            elif (\n                self.sort_by_loc\n                and self.sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_mtime\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                mtime_count = content[\"_mtime\"]\n                lines.append(\n                    f\"{indent}- \ud83d\udcc1 **{name}** ({loc_count} lines, {format_timestamp(mtime_count)})\"\n                )\n            elif (\n                self.sort_by_size\n                and self.sort_by_mtime\n                and isinstance(content, dict)\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                size_count = content[\"_size\"]\n                mtime_count = content[\"_mtime\"]\n                lines.append(\n                    f\"{indent}- \ud83d\udcc1 **{name}** ({format_size(size_count)}, {format_timestamp(mtime_count)})\"\n                )\n            elif (\n                self.sort_by_loc and isinstance(content, dict) and \"_loc\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                lines.append(f\"{indent}- \ud83d\udcc1 **{name}** ({loc_count} lines)\")\n            elif (\n                self.sort_by_size\n                and isinstance(content, dict)\n                and \"_size\" in content\n            ):\n                size_count = content[\"_size\"]\n                lines.append(f\"{indent}- \ud83d\udcc1 **{name}** ({format_size(size_count)})\")\n            elif (\n                self.sort_by_mtime\n                and isinstance(content, dict)\n                and \"_mtime\" in content\n            ):\n                mtime_count = content[\"_mtime\"]\n                lines.append(\n                    f\"{indent}- \ud83d\udcc1 **{name}** ({format_timestamp(mtime_count)})\"\n                )\n            else:\n                lines.append(f\"{indent}- \ud83d\udcc1 **{name}**\")\n            next_path = os.path.join(path_prefix, name) if path_prefix else name\n            if isinstance(content, dict):\n                if content.get(\"_max_depth_reached\"):\n                    lines.append(f\"{indent}    - \u22ef *(max depth reached)*\")\n                else:\n                    lines.extend(_build_md_tree(content, level + 1, next_path))\n        return lines\n\n    if (\n        self.sort_by_loc\n        and self.sort_by_size\n        and self.sort_by_mtime\n        and \"_loc\" in self.structure\n        and \"_size\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        md_content = [\n            f\"# \ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\",\n            \"\",\n        ]\n    elif (\n        self.sort_by_loc\n        and self.sort_by_size\n        and \"_loc\" in self.structure\n        and \"_size\" in self.structure\n    ):\n        md_content = [\n            f\"# \ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])})\",\n            \"\",\n        ]\n    elif (\n        self.sort_by_loc\n        and self.sort_by_mtime\n        and \"_loc\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        md_content = [\n            f\"# \ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_timestamp(self.structure['_mtime'])})\",\n            \"\",\n        ]\n    elif (\n        self.sort_by_size\n        and self.sort_by_mtime\n        and \"_size\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        md_content = [\n            f\"# \ud83d\udcc2 {self.root_name} ({format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\",\n            \"\",\n        ]\n    elif self.sort_by_loc and \"_loc\" in self.structure:\n        md_content = [f\"# \ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines)\", \"\"]\n    elif self.sort_by_size and \"_size\" in self.structure:\n        md_content = [\n            f\"# \ud83d\udcc2 {self.root_name} ({format_size(self.structure['_size'])})\",\n            \"\",\n        ]\n    elif self.sort_by_mtime and \"_mtime\" in self.structure:\n        md_content = [\n            f\"# \ud83d\udcc2 {self.root_name} ({format_timestamp(self.structure['_mtime'])})\",\n            \"\",\n        ]\n    else:\n        md_content = [f\"# \ud83d\udcc2 {self.root_name}\", \"\"]\n    md_content.extend(\n        _build_md_tree(\n            self.structure, 0, self.root_name if self.show_full_path else \"\"\n        )\n    )\n    try:\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(\"\\n\".join(md_content))\n    except Exception as e:\n        logger.error(f\"Error exporting to Markdown: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api-reference/#recursivist.exports.DirectoryExporter.to_txt","title":"<code>to_txt(output_path)</code>","text":"<p>Export directory structure to a text file with ASCII tree representation.</p> <p>Creates a text file containing an ASCII tree representation of the directory structure using standard box-drawing characters and indentation.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>Path where the txt file will be saved</p> required Source code in <code>recursivist/exports.py</code> <pre><code>def to_txt(self, output_path: str) -&gt; None:\n    \"\"\"Export directory structure to a text file with ASCII tree representation.\n\n    Creates a text file containing an ASCII tree representation of the directory structure using standard box-drawing characters and indentation.\n\n    Args:\n        output_path: Path where the txt file will be saved\n    \"\"\"\n\n    def _build_txt_tree(\n        structure: Dict[str, Any],\n        prefix: str = \"\",\n        path_prefix: str = \"\",\n    ) -&gt; List[str]:\n        lines = []\n        items = sorted(structure.items())\n        for i, (name, content) in enumerate(items):\n            if name == \"_files\":\n                file_items = sort_files_by_type(\n                    content, self.sort_by_loc, self.sort_by_size, self.sort_by_mtime\n                )\n                for j, file_item in enumerate(file_items):\n                    is_last_file = j == len(file_items) - 1\n                    is_last_item = is_last_file and i == len(items) - 1\n                    item_prefix = prefix + (\"\u2514\u2500\u2500 \" if is_last_item else \"\u251c\u2500\u2500 \")\n                    if (\n                        self.sort_by_loc\n                        and self.sort_by_size\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 4\n                    ):\n                        _, display_path, loc, size, mtime = file_item\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc4 {display_path} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, _, mtime = file_item\n                        else:\n                            _, display_path, loc, mtime = file_item\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc4 {display_path} ({loc} lines, {format_timestamp(mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_size\n                        and self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, size, mtime = file_item\n                        else:\n                            _, display_path, size, mtime = file_item\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc4 {display_path} ({format_size(size)}, {format_timestamp(mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and self.sort_by_size\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 3\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, size, _ = file_item\n                        else:\n                            _, display_path, loc, size = file_item\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc4 {display_path} ({loc} lines, {format_size(size)})\"\n                        )\n                    elif (\n                        self.sort_by_mtime\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, _, mtime = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, _, mtime = file_item\n                        else:\n                            _, display_path, mtime = file_item\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc4 {display_path} ({format_timestamp(mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_size\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, _, size, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, _, size = file_item\n                        else:\n                            _, display_path, size = file_item\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc4 {display_path} ({format_size(size)})\"\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and isinstance(file_item, tuple)\n                        and len(file_item) &gt; 2\n                    ):\n                        if len(file_item) &gt; 4:\n                            _, display_path, loc, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, display_path, loc, _ = file_item\n                        else:\n                            _, display_path, loc = file_item\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc4 {display_path} ({loc} lines)\"\n                        )\n                    elif self.show_full_path and isinstance(file_item, tuple):\n                        if len(file_item) &gt; 4:\n                            _, full_path, _, _, _ = file_item\n                        elif len(file_item) &gt; 3:\n                            _, full_path, _, _ = file_item\n                        elif len(file_item) &gt; 2:\n                            _, full_path, _ = file_item\n                        else:\n                            _, full_path = file_item\n                        lines.append(f\"{item_prefix}\ud83d\udcc4 {full_path}\")\n                    else:\n                        if isinstance(file_item, tuple):\n                            if len(file_item) &gt; 4:\n                                file_name, _, _, _, _ = file_item\n                            elif len(file_item) &gt; 3:\n                                file_name, _, _, _ = file_item\n                            elif len(file_item) &gt; 2:\n                                file_name, _, _ = file_item\n                            else:\n                                file_name, _ = file_item\n                        else:\n                            file_name = file_item\n                        lines.append(f\"{item_prefix}\ud83d\udcc4 {file_name}\")\n                    if not is_last_item:\n                        next_prefix = prefix + \"\u2502   \"\n                    else:\n                        next_prefix = prefix + \"    \"\n            elif (\n                name == \"_loc\"\n                or name == \"_size\"\n                or name == \"_mtime\"\n                or name == \"_max_depth_reached\"\n            ):\n                continue\n            else:\n                is_last_dir = True\n                for j in range(i + 1, len(items)):\n                    next_name, next_content = items[j]\n                    if next_name not in [\n                        \"_files\",\n                        \"_max_depth_reached\",\n                        \"_loc\",\n                        \"_size\",\n                        \"_mtime\",\n                    ]:\n                        is_last_dir = False\n                        break\n                is_last_item = is_last_dir and (\n                    i == len(items) - 1\n                    or all(\n                        key\n                        in [\n                            \"_files\",\n                            \"_max_depth_reached\",\n                            \"_loc\",\n                            \"_size\",\n                            \"_mtime\",\n                        ]\n                        for key, _ in items[i + 1 :]\n                    )\n                )\n                item_prefix = prefix + (\"\u2514\u2500\u2500 \" if is_last_item else \"\u251c\u2500\u2500 \")\n                next_path = os.path.join(path_prefix, name) if path_prefix else name\n                if isinstance(content, dict):\n                    if (\n                        self.sort_by_loc\n                        and self.sort_by_size\n                        and self.sort_by_mtime\n                        and \"_loc\" in content\n                        and \"_size\" in content\n                        and \"_mtime\" in content\n                    ):\n                        folder_loc = content[\"_loc\"]\n                        folder_size = content[\"_size\"]\n                        folder_mtime = content[\"_mtime\"]\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc1 {name} ({folder_loc} lines, {format_size(folder_size)}, {format_timestamp(folder_mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and self.sort_by_size\n                        and \"_loc\" in content\n                        and \"_size\" in content\n                    ):\n                        folder_loc = content[\"_loc\"]\n                        folder_size = content[\"_size\"]\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc1 {name} ({folder_loc} lines, {format_size(folder_size)})\"\n                        )\n                    elif (\n                        self.sort_by_loc\n                        and self.sort_by_mtime\n                        and \"_loc\" in content\n                        and \"_mtime\" in content\n                    ):\n                        folder_loc = content[\"_loc\"]\n                        folder_mtime = content[\"_mtime\"]\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc1 {name} ({folder_loc} lines, {format_timestamp(folder_mtime)})\"\n                        )\n                    elif (\n                        self.sort_by_size\n                        and self.sort_by_mtime\n                        and \"_size\" in content\n                        and \"_mtime\" in content\n                    ):\n                        folder_size = content[\"_size\"]\n                        folder_mtime = content[\"_mtime\"]\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc1 {name} ({format_size(folder_size)}, {format_timestamp(folder_mtime)})\"\n                        )\n                    elif self.sort_by_loc and \"_loc\" in content:\n                        folder_loc = content[\"_loc\"]\n                        lines.append(f\"{item_prefix}\ud83d\udcc1 {name} ({folder_loc} lines)\")\n                    elif self.sort_by_size and \"_size\" in content:\n                        folder_size = content[\"_size\"]\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc1 {name} ({format_size(folder_size)})\"\n                        )\n                    elif self.sort_by_mtime and \"_mtime\" in content:\n                        folder_mtime = content[\"_mtime\"]\n                        lines.append(\n                            f\"{item_prefix}\ud83d\udcc1 {name} ({format_timestamp(folder_mtime)})\"\n                        )\n                    else:\n                        lines.append(f\"{item_prefix}\ud83d\udcc1 {name}\")\n                    if content.get(\"_max_depth_reached\"):\n                        next_prefix = prefix + (\"    \" if is_last_item else \"\u2502   \")\n                        lines.append(f\"{next_prefix}\u2514\u2500\u2500 \u22ef (max depth reached)\")\n                    else:\n                        next_prefix = prefix + (\"    \" if is_last_item else \"\u2502   \")\n                        sublines = _build_txt_tree(content, next_prefix, next_path)\n                        lines.extend(sublines)\n                else:\n                    lines.append(f\"{item_prefix}\ud83d\udcc1 {name}\")\n        return lines\n\n    root_label = f\"\ud83d\udcc2 {self.root_name}\"\n    if (\n        self.sort_by_loc\n        and self.sort_by_size\n        and self.sort_by_mtime\n        and \"_loc\" in self.structure\n        and \"_size\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        root_label = f\"\ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\"\n    elif (\n        self.sort_by_loc\n        and self.sort_by_size\n        and \"_loc\" in self.structure\n        and \"_size\" in self.structure\n    ):\n        root_label = f\"\ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_size(self.structure['_size'])})\"\n    elif (\n        self.sort_by_loc\n        and self.sort_by_mtime\n        and \"_loc\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        root_label = f\"\ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines, {format_timestamp(self.structure['_mtime'])})\"\n    elif (\n        self.sort_by_size\n        and self.sort_by_mtime\n        and \"_size\" in self.structure\n        and \"_mtime\" in self.structure\n    ):\n        root_label = f\"\ud83d\udcc2 {self.root_name} ({format_size(self.structure['_size'])}, {format_timestamp(self.structure['_mtime'])})\"\n    elif self.sort_by_loc and \"_loc\" in self.structure:\n        root_label = f\"\ud83d\udcc2 {self.root_name} ({self.structure['_loc']} lines)\"\n    elif self.sort_by_size and \"_size\" in self.structure:\n        root_label = f\"\ud83d\udcc2 {self.root_name} ({format_size(self.structure['_size'])})\"\n    elif self.sort_by_mtime and \"_mtime\" in self.structure:\n        root_label = (\n            f\"\ud83d\udcc2 {self.root_name} ({format_timestamp(self.structure['_mtime'])})\"\n        )\n    tree_lines = [root_label]\n    tree_lines.extend(\n        _build_txt_tree(\n            self.structure, \"\", self.root_name if self.show_full_path else \"\"\n        )\n    )\n    try:\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(\"\\n\".join(tree_lines))\n    except Exception as e:\n        logger.error(f\"Error exporting to TXT: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api-reference/#recursivist.exports.sort_files_by_type","title":"<code>sort_files_by_type(files, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Sort files by extension and then by name, or by LOC/size/mtime if requested.</p> Source code in <code>recursivist/exports.py</code> <pre><code>def sort_files_by_type(\n    files: Sequence[\n        Union[\n            str,\n            Tuple[str, str],\n            Tuple[str, str, int],\n            Tuple[str, str, int, int],\n            Tuple[str, str, int, int, float],\n        ]\n    ],\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; List[\n    Union[\n        str,\n        Tuple[str, str],\n        Tuple[str, str, int],\n        Tuple[str, str, int, int],\n        Tuple[str, str, int, int, float],\n    ]\n]:\n    \"\"\"Sort files by extension and then by name, or by LOC/size/mtime if requested.\"\"\"\n    if not files:\n        return []\n    has_loc = any(isinstance(item, tuple) and len(item) &gt; 2 for item in files)\n    has_size = any(isinstance(item, tuple) and len(item) &gt; 3 for item in files)\n    has_mtime = any(isinstance(item, tuple) and len(item) &gt; 4 for item in files)\n    has_simple_size = sort_by_size and not sort_by_loc and has_loc\n    has_simple_mtime = (\n        sort_by_mtime and not sort_by_loc and not sort_by_size and (has_loc or has_size)\n    )\n\n    def get_size(item):\n        if not isinstance(item, tuple):\n            return 0\n        if len(item) &gt; 3:\n            if sort_by_loc and sort_by_size:\n                return item[3]\n            elif sort_by_size and not sort_by_loc:\n                return item[2]\n        elif len(item) == 3 and sort_by_size:\n            return item[2]\n        return 0\n\n    def get_loc(item):\n        if not isinstance(item, tuple) or len(item) &lt;= 2:\n            return 0\n        return item[2] if sort_by_loc else 0\n\n    def get_mtime(item):\n        if not isinstance(item, tuple):\n            return 0\n        if len(item) &gt; 4 and sort_by_loc and sort_by_size and sort_by_mtime:\n            return item[4]\n        elif len(item) &gt; 3 and (\n            (sort_by_loc and sort_by_mtime and not sort_by_size)\n            or (sort_by_size and sort_by_mtime and not sort_by_loc)\n        ):\n            return item[3]\n        elif len(item) &gt; 2 and sort_by_mtime and not sort_by_loc and not sort_by_size:\n            return item[2]\n        return 0\n\n    if sort_by_loc and sort_by_size and sort_by_mtime and has_mtime:\n        return sorted(files, key=lambda f: (-get_loc(f), -get_size(f), -get_mtime(f)))\n    elif sort_by_loc and sort_by_size and (has_size or has_simple_size) and has_loc:\n        return sorted(files, key=lambda f: (-get_loc(f), -get_size(f)))\n    elif sort_by_loc and sort_by_mtime and has_mtime:\n        return sorted(files, key=lambda f: (-get_loc(f), -get_mtime(f)))\n    elif sort_by_size and sort_by_mtime and has_mtime:\n        return sorted(files, key=lambda f: (-get_size(f), -get_mtime(f)))\n    elif sort_by_loc and has_loc:\n        return sorted(files, key=lambda f: (-get_loc(f)))\n    elif sort_by_size and (has_size or has_simple_size):\n        return sorted(files, key=lambda f: (-get_size(f)))\n    elif sort_by_mtime and (has_mtime or has_simple_mtime):\n        return sorted(files, key=lambda f: (-get_mtime(f)))\n    all_tuples = all(isinstance(item, tuple) for item in files)\n    all_strings = all(isinstance(item, str) for item in files)\n    if all_strings:\n        files_as_strings = cast(List[str], files)\n        return cast(\n            List[\n                Union[\n                    str,\n                    Tuple[str, str],\n                    Tuple[str, str, int],\n                    Tuple[str, str, int, int],\n                    Tuple[str, str, int, int, float],\n                ]\n            ],\n            sorted(\n                files_as_strings,\n                key=lambda f: (os.path.splitext(f)[1].lower(), f.lower()),\n            ),\n        )\n    elif all_tuples:\n        return sorted(\n            files,\n            key=lambda t: (os.path.splitext(t[0])[1].lower(), t[0].lower()),\n        )\n    else:\n        str_items: List[str] = []\n        tuple_items: List[\n            Union[\n                Tuple[str, str],\n                Tuple[str, str, int],\n                Tuple[str, str, int, int],\n                Tuple[str, str, int, int, float],\n            ]\n        ] = []\n        for item in files:\n            if isinstance(item, tuple):\n                tuple_items.append(item)\n            else:\n                str_items.append(cast(str, item))\n        sorted_strings = sorted(\n            str_items, key=lambda f: (os.path.splitext(f)[1].lower(), f.lower())\n        )\n        sorted_tuples = sorted(\n            tuple_items, key=lambda t: (os.path.splitext(t[0])[1].lower(), t[0].lower())\n        )\n        result: List[\n            Union[\n                str,\n                Tuple[str, str],\n                Tuple[str, str, int],\n                Tuple[str, str, int, int],\n                Tuple[str, str, int, int, float],\n            ]\n        ] = []\n        result.extend(sorted_strings)\n        result.extend(sorted_tuples)\n        return result\n</code></pre>"},{"location":"reference/api-reference/#compare-module","title":"Compare Module","text":""},{"location":"reference/api-reference/#recursivist.compare","title":"<code>recursivist.compare</code>","text":"<p>Comparison functionality for the Recursivist directory visualization tool.</p> <p>This module implements side-by-side directory structure comparison with visual highlighting of differences. It provides terminal output with colored indicators and HTML export for sharing and documentation.</p> <p>Key features: - Visual highlighting of items unique to each directory - Consistent color coding for file extensions - Support for all the same filtering options as visualization - Export to HTML with interactive features - Optional display of statistics (LOC, size, modification times) - Legend explaining the highlighting scheme</p>"},{"location":"reference/api-reference/#recursivist.compare._export_comparison_to_html","title":"<code>_export_comparison_to_html(comparison_data, output_path)</code>","text":"<p>Export comparison to HTML format.</p> <p>Internal helper function that generates an HTML file from comparison data. Creates a responsive, styled HTML document with side-by-side directory trees and highlighted differences. Supports displaying LOC counts, file sizes, and modification times when enabled.</p> <p>Parameters:</p> Name Type Description Default <code>comparison_data</code> <code>Dict[str, Any]</code> <p>Dictionary containing comparison structures and metadata</p> required <code>output_path</code> <code>str</code> <p>Path where the HTML file will be saved</p> required Source code in <code>recursivist/compare.py</code> <pre><code>def _export_comparison_to_html(\n    comparison_data: Dict[str, Any], output_path: str\n) -&gt; None:\n    \"\"\"Export comparison to HTML format.\n\n    Internal helper function that generates an HTML file from comparison data. Creates a responsive, styled HTML document with side-by-side directory trees and highlighted differences. Supports displaying LOC counts, file sizes, and modification times when enabled.\n\n    Args:\n        comparison_data: Dictionary containing comparison structures and metadata\n        output_path: Path where the HTML file will be saved\n    \"\"\"\n\n    def _build_html_tree(\n        structure: Dict[str, Any],\n        other_structure: Dict[str, Any],\n        is_left_tree: bool = True,\n    ) -&gt; str:\n        \"\"\"Export comparison to HTML format.\n\n        Internal helper function that builds the HTML tree representation for each directory.\n        Highlights items that only exist in one directory structure.\n\n        Args:\n            structure: Dictionary containing directory structure\n            other_structure: Dictionary containing comparison directory structure\n            is_left_tree: Whether this is the left tree in the comparison view\n\n        Returns:\n            HTML string representing the directory tree\n        \"\"\"\n\n        html_content = [\"&lt;ul&gt;\"]\n        show_full_path = comparison_data.get(\"metadata\", {}).get(\n            \"show_full_path\", False\n        )\n        sort_by_loc = comparison_data.get(\"metadata\", {}).get(\"sort_by_loc\", False)\n        sort_by_size = comparison_data.get(\"metadata\", {}).get(\"sort_by_size\", False)\n        sort_by_mtime = comparison_data.get(\"metadata\", {}).get(\"sort_by_mtime\", False)\n        files_in_this = structure.get(\"_files\", [])\n        if \"_files\" in structure:\n            files_in_other = (\n                other_structure.get(\"_files\", []) if other_structure else []\n            )\n            files_in_other_names = []\n            for item in files_in_other:\n                if isinstance(item, tuple):\n                    files_in_other_names.append(item[0])\n                else:\n                    files_in_other_names.append(cast(str, item))\n            sorted_files = sort_files_by_type(\n                files_in_this, sort_by_loc, sort_by_size, sort_by_mtime\n            )\n            for file_item in sorted_files:\n                display_text = \"\"\n                file_name = \"\"\n                if (\n                    sort_by_loc\n                    and sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 4\n                ):\n                    file_name, display_path, loc, size, mtime = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\"\n                elif (\n                    sort_by_loc\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, _, mtime = file_item\n                    else:\n                        file_name, display_path, loc, mtime = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = (\n                        f\"{display_text} ({loc} lines, {format_timestamp(mtime)})\"\n                    )\n                elif (\n                    sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, size, mtime = file_item\n                    else:\n                        file_name, display_path, size, mtime = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({format_size(size)}, {format_timestamp(mtime)})\"\n                elif (\n                    sort_by_loc\n                    and sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, size, _ = file_item\n                    else:\n                        file_name, display_path, loc, size = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({loc} lines, {format_size(size)})\"\n                elif (\n                    sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, _, mtime = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, _, mtime = file_item\n                    else:\n                        file_name, display_path, mtime = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({format_timestamp(mtime)})\"\n                elif (\n                    sort_by_size and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, size, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, _, size = file_item\n                    else:\n                        file_name, display_path, size = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({format_size(size)})\"\n                elif (\n                    sort_by_loc and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, loc, _ = file_item\n                    else:\n                        file_name, display_path, loc = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({loc} lines)\"\n                elif isinstance(file_item, tuple):\n                    if len(file_item) &gt; 4:\n                        file_name, full_path, _, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, full_path, _, _ = file_item\n                    elif len(file_item) &gt; 2:\n                        file_name, full_path, _ = file_item\n                    else:\n                        file_name, full_path = file_item\n                    display_text = html.escape(full_path)\n                else:\n                    file_name = cast(str, file_item)\n                    display_text = html.escape(file_name)\n                if file_name not in files_in_other_names:\n                    file_class = (\n                        ' class=\"file-unique-left\"'\n                        if is_left_tree\n                        else ' class=\"file-unique-right\"'\n                    )\n                else:\n                    file_class = \"\"\n                html_content.append(\n                    f'&lt;li{file_class}&gt;&lt;span class=\"file\"&gt;\ud83d\udcc4 {display_text}&lt;/span&gt;&lt;/li&gt;'\n                )\n        for name, content in sorted(structure.items()):\n            if (\n                name == \"_files\"\n                or name == \"_max_depth_reached\"\n                or name == \"_loc\"\n                or name == \"_size\"\n                or name == \"_mtime\"\n            ):\n                continue\n            if name not in other_structure:\n                dir_class = (\n                    ' class=\"directory-unique-left\"'\n                    if is_left_tree\n                    else ' class=\"directory-unique-right\"'\n                )\n            else:\n                dir_class = \"\"\n            if (\n                sort_by_loc\n                and sort_by_size\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                size_count = content[\"_size\"]\n                mtime_count = content[\"_mtime\"]\n                html_content.append(\n                    f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({loc_count} lines, {format_size(size_count)}, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                )\n            elif (\n                sort_by_loc\n                and sort_by_size\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                size_count = content[\"_size\"]\n                html_content.append(\n                    f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({loc_count} lines, {format_size(size_count)})&lt;/span&gt;'\n                )\n            elif (\n                sort_by_loc\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_mtime\" in content\n            ):\n                loc_count = content[\"_loc\"]\n                mtime_count = content[\"_mtime\"]\n                html_content.append(\n                    f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({loc_count} lines, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                )\n            elif (\n                sort_by_size\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                size_count = content[\"_size\"]\n                mtime_count = content[\"_mtime\"]\n                html_content.append(\n                    f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({format_size(size_count)}, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                )\n            elif sort_by_loc and isinstance(content, dict) and \"_loc\" in content:\n                loc_count = content[\"_loc\"]\n                html_content.append(\n                    f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({loc_count} lines)&lt;/span&gt;'\n                )\n            elif sort_by_size and isinstance(content, dict) and \"_size\" in content:\n                size_count = content[\"_size\"]\n                html_content.append(\n                    f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({format_size(size_count)})&lt;/span&gt;'\n                )\n            elif sort_by_mtime and isinstance(content, dict) and \"_mtime\" in content:\n                mtime_count = content[\"_mtime\"]\n                html_content.append(\n                    f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({format_timestamp(mtime_count)})&lt;/span&gt;'\n                )\n            else:\n                html_content.append(\n                    f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)}&lt;/span&gt;'\n                )\n            if isinstance(content, dict) and content.get(\"_max_depth_reached\"):\n                html_content.append(\n                    '&lt;ul&gt;&lt;li class=\"max-depth\"&gt;\u22ef (max depth reached)&lt;/li&gt;&lt;/ul&gt;'\n                )\n            else:\n                other_content = other_structure.get(name, {}) if other_structure else {}\n                html_content.append(\n                    _build_html_tree(content, other_content, is_left_tree)\n                )\n            html_content.append(\"&lt;/li&gt;\")\n        if other_structure and \"_files\" in other_structure:\n            files_in_this_names = []\n            for item in files_in_this:\n                if isinstance(item, tuple):\n                    files_in_this_names.append(item[0])\n                else:\n                    files_in_this_names.append(cast(str, item))\n            sorted_other_files = sort_files_by_type(\n                other_structure[\"_files\"], sort_by_loc, sort_by_size, sort_by_mtime\n            )\n            for file_item in sorted_other_files:\n                display_text = \"\"\n                file_name = \"\"\n                if (\n                    sort_by_loc\n                    and sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 4\n                ):\n                    file_name, display_path, loc, size, mtime = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\"\n                elif (\n                    sort_by_loc\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, _, mtime = file_item\n                    else:\n                        file_name, display_path, loc, mtime = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = (\n                        f\"{display_text} ({loc} lines, {format_timestamp(mtime)})\"\n                    )\n                elif (\n                    sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, size, mtime = file_item\n                    else:\n                        file_name, display_path, size, mtime = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({format_size(size)}, {format_timestamp(mtime)})\"\n                elif (\n                    sort_by_loc\n                    and sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, size, _ = file_item\n                    else:\n                        file_name, display_path, loc, size = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({loc} lines, {format_size(size)})\"\n                elif (\n                    sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, _, mtime = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, _, mtime = file_item\n                    else:\n                        file_name, display_path, mtime = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({format_timestamp(mtime)})\"\n                elif (\n                    sort_by_size and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, size, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, _, size = file_item\n                    else:\n                        file_name, display_path, size = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({format_size(size)})\"\n                elif (\n                    sort_by_loc and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, loc, _ = file_item\n                    else:\n                        file_name, display_path, loc = file_item\n                    display_text = html.escape(\n                        display_path if show_full_path else file_name\n                    )\n                    display_text = f\"{display_text} ({loc} lines)\"\n                elif isinstance(file_item, tuple):\n                    if len(file_item) &gt; 4:\n                        file_name, full_path, _, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, full_path, _, _ = file_item\n                    elif len(file_item) &gt; 2:\n                        file_name, full_path, _ = file_item\n                    else:\n                        file_name, full_path = file_item\n                    display_text = html.escape(full_path)\n                else:\n                    file_name = cast(str, file_item)\n                    display_text = html.escape(file_name)\n                if file_name not in files_in_this_names:\n                    file_class = (\n                        ' class=\"file-unique-right\"'\n                        if is_left_tree\n                        else ' class=\"file-unique-left\"'\n                    )\n                    html_content.append(\n                        f'&lt;li{file_class}&gt;&lt;span class=\"file\"&gt;\ud83d\udcc4 {display_text}&lt;/span&gt;&lt;/li&gt;'\n                    )\n        if other_structure:\n            for name, content in sorted(other_structure.items()):\n                if (\n                    name == \"_files\"\n                    or name == \"_max_depth_reached\"\n                    or name == \"_loc\"\n                    or name == \"_size\"\n                    or name == \"_mtime\"\n                    or name in structure\n                ):\n                    continue\n                dir_class = (\n                    ' class=\"directory-unique-right\"'\n                    if is_left_tree\n                    else ' class=\"directory-unique-left\"'\n                )\n                if (\n                    sort_by_loc\n                    and sort_by_size\n                    and sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_size\" in content\n                    and \"_mtime\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    size_count = content[\"_size\"]\n                    mtime_count = content[\"_mtime\"]\n                    html_content.append(\n                        f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({loc_count} lines, {format_size(size_count)}, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    sort_by_loc\n                    and sort_by_size\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_size\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    size_count = content[\"_size\"]\n                    html_content.append(\n                        f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({loc_count} lines, {format_size(size_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    sort_by_loc\n                    and sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_loc\" in content\n                    and \"_mtime\" in content\n                ):\n                    loc_count = content[\"_loc\"]\n                    mtime_count = content[\"_mtime\"]\n                    html_content.append(\n                        f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({loc_count} lines, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    sort_by_size\n                    and sort_by_mtime\n                    and isinstance(content, dict)\n                    and \"_size\" in content\n                    and \"_mtime\" in content\n                ):\n                    size_count = content[\"_size\"]\n                    mtime_count = content[\"_mtime\"]\n                    html_content.append(\n                        f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({format_size(size_count)}, {format_timestamp(mtime_count)})&lt;/span&gt;'\n                    )\n                elif sort_by_loc and isinstance(content, dict) and \"_loc\" in content:\n                    loc_count = content[\"_loc\"]\n                    html_content.append(\n                        f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({loc_count} lines)&lt;/span&gt;'\n                    )\n                elif sort_by_size and isinstance(content, dict) and \"_size\" in content:\n                    size_count = content[\"_size\"]\n                    html_content.append(\n                        f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({format_size(size_count)})&lt;/span&gt;'\n                    )\n                elif (\n                    sort_by_mtime and isinstance(content, dict) and \"_mtime\" in content\n                ):\n                    mtime_count = content[\"_mtime\"]\n                    html_content.append(\n                        f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)} ({format_timestamp(mtime_count)})&lt;/span&gt;'\n                    )\n                else:\n                    html_content.append(\n                        f'&lt;li{dir_class}&gt;&lt;span class=\"directory\"&gt;\ud83d\udcc1 {html.escape(name)}&lt;/span&gt;'\n                    )\n                if isinstance(content, dict) and content.get(\"_max_depth_reached\"):\n                    html_content.append(\n                        '&lt;ul&gt;&lt;li class=\"max-depth\"&gt;\u22ef (max depth reached)&lt;/li&gt;&lt;/ul&gt;'\n                    )\n                else:\n                    html_content.append(_build_html_tree({}, content, is_left_tree))\n                html_content.append(\"&lt;/li&gt;\")\n        html_content.append(\"&lt;/ul&gt;\")\n        return \"\\n\".join(html_content)\n\n    def format_timestamp_js():\n        \"\"\"Returns JavaScript function to format timestamps in HTML.\"\"\"\n        return \"\"\"\n        function formatTimestamp(timestamp) {\n            const dt = new Date(timestamp * 1000);\n            const now = new Date();\n            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n            const yesterday = new Date(today);\n            yesterday.setDate(yesterday.getDate() - 1);\n            if (dt &gt;= today) {\n                return `Today ${dt.getHours().toString().padStart(2, '0')}:${dt.getMinutes().toString().padStart(2, '0')}`;\n            }\n            else if (dt &gt;= yesterday) {\n                return `Yesterday ${dt.getHours().toString().padStart(2, '0')}:${dt.getMinutes().toString().padStart(2, '0')}`;\n            }\n            else if ((today - dt) / (1000 * 60 * 60 * 24) &lt; 7) {\n                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n                return `${days[dt.getDay()]} ${dt.getHours().toString().padStart(2, '0')}:${dt.getMinutes().toString().padStart(2, '0')}`;\n            }\n            else if (dt.getFullYear() === now.getFullYear()) {\n                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n                return `${months[dt.getMonth()]} ${dt.getDate()}`;\n            }\n            else {\n                return `${dt.getFullYear()}-${(dt.getMonth() + 1).toString().padStart(2, '0')}-${dt.getDate().toString().padStart(2, '0')}`;\n            }\n        }\n        \"\"\"\n\n    dir1_name = html.escape(comparison_data[\"dir1\"][\"name\"])\n    dir2_name = html.escape(comparison_data[\"dir2\"][\"name\"])\n    dir1_path = html.escape(comparison_data[\"dir1\"][\"path\"])\n    dir2_path = html.escape(comparison_data[\"dir2\"][\"path\"])\n    dir1_structure = comparison_data[\"dir1\"][\"structure\"]\n    dir2_structure = comparison_data[\"dir2\"][\"structure\"]\n    metadata = comparison_data.get(\"metadata\", {})\n    max_depth_info = \"\"\n    if metadata.get(\"max_depth\", 0) &gt; 0:\n        max_depth_info = f'&lt;div class=\"info-block\"&gt;&lt;span class=\"info-label\"&gt;Max Depth:&lt;/span&gt; {metadata[\"max_depth\"]} levels&lt;/div&gt;'\n    path_info = \"\"\n    if metadata.get(\"show_full_path\"):\n        path_info = '&lt;div class=\"info-block\"&gt;&lt;span class=\"info-label\"&gt;Path Display:&lt;/span&gt; Full paths shown&lt;/div&gt;'\n    loc_info = \"\"\n    if metadata.get(\"sort_by_loc\"):\n        loc_info = '&lt;div class=\"info-block\"&gt;&lt;span class=\"info-label\"&gt;Lines of Code:&lt;/span&gt; Files sorted by LOC, counts displayed&lt;/div&gt;'\n    size_info = \"\"\n    if metadata.get(\"sort_by_size\"):\n        size_info = '&lt;div class=\"info-block\"&gt;&lt;span class=\"info-label\"&gt;File Sizes:&lt;/span&gt; Files sorted by size, sizes displayed&lt;/div&gt;'\n    mtime_info = \"\"\n    if metadata.get(\"sort_by_mtime\"):\n        mtime_info = '&lt;div class=\"info-block\"&gt;&lt;span class=\"info-label\"&gt;Modification Times:&lt;/span&gt; Files sorted by newest first, timestamps displayed&lt;/div&gt;'\n    pattern_info_html = \"\"\n    if metadata.get(\"exclude_patterns\") or metadata.get(\"include_patterns\"):\n        pattern_type = metadata.get(\"pattern_type\", \"glob\").capitalize()\n        pattern_items = []\n        if metadata.get(\"exclude_patterns\"):\n            patterns = [html.escape(p) for p in metadata.get(\"exclude_patterns\", [])]\n            pattern_items.append(\n                f\"&lt;dt&gt;Exclude {pattern_type} Patterns:&lt;/dt&gt;&lt;dd&gt;{', '.join(patterns)}&lt;/dd&gt;\"\n            )\n        if metadata.get(\"include_patterns\"):\n            patterns = [html.escape(p) for p in metadata.get(\"include_patterns\", [])]\n            pattern_items.append(\n                f\"&lt;dt&gt;Include {pattern_type} Patterns:&lt;/dt&gt;&lt;dd&gt;{', '.join(patterns)}&lt;/dd&gt;\"\n            )\n        if pattern_items:\n            pattern_info_html = f\"\"\"\n            &lt;div class=\"pattern-info\"&gt;\n                &lt;h3&gt;Applied Patterns&lt;/h3&gt;\n                &lt;dl&gt;\n                    {''.join(pattern_items)}\n                &lt;/dl&gt;\n            &lt;/div&gt;\n            \"\"\"\n\n    dir1_title = dir1_name\n    dir2_title = dir2_name\n    if (\n        metadata.get(\"sort_by_loc\")\n        and metadata.get(\"sort_by_size\")\n        and metadata.get(\"sort_by_mtime\")\n    ):\n        if (\n            \"_loc\" in dir1_structure\n            and \"_size\" in dir1_structure\n            and \"_mtime\" in dir1_structure\n        ):\n            dir1_title = f\"{dir1_name} ({dir1_structure['_loc']} lines, {format_size(dir1_structure['_size'])}, {format_timestamp(dir1_structure['_mtime'])})\"\n        if (\n            \"_loc\" in dir2_structure\n            and \"_size\" in dir2_structure\n            and \"_mtime\" in dir2_structure\n        ):\n            dir2_title = f\"{dir2_name} ({dir2_structure['_loc']} lines, {format_size(dir2_structure['_size'])}, {format_timestamp(dir2_structure['_mtime'])})\"\n    elif metadata.get(\"sort_by_loc\") and metadata.get(\"sort_by_size\"):\n        if \"_loc\" in dir1_structure and \"_size\" in dir1_structure:\n            dir1_title = f\"{dir1_name} ({dir1_structure['_loc']} lines, {format_size(dir1_structure['_size'])})\"\n        if \"_loc\" in dir2_structure and \"_size\" in dir2_structure:\n            dir2_title = f\"{dir2_name} ({dir2_structure['_loc']} lines, {format_size(dir2_structure['_size'])})\"\n    elif metadata.get(\"sort_by_loc\") and metadata.get(\"sort_by_mtime\"):\n        if \"_loc\" in dir1_structure and \"_mtime\" in dir1_structure:\n            dir1_title = f\"{dir1_name} ({dir1_structure['_loc']} lines, {format_timestamp(dir1_structure['_mtime'])})\"\n        if \"_loc\" in dir2_structure and \"_mtime\" in dir2_structure:\n            dir2_title = f\"{dir2_name} ({dir2_structure['_loc']} lines, {format_timestamp(dir2_structure['_mtime'])})\"\n    elif metadata.get(\"sort_by_size\") and metadata.get(\"sort_by_mtime\"):\n        if \"_size\" in dir1_structure and \"_mtime\" in dir1_structure:\n            dir1_title = f\"{dir1_name} ({format_size(dir1_structure['_size'])}, {format_timestamp(dir1_structure['_mtime'])})\"\n        if \"_size\" in dir2_structure and \"_mtime\" in dir2_structure:\n            dir2_title = f\"{dir2_name} ({format_size(dir2_structure['_size'])}, {format_timestamp(dir2_structure['_mtime'])})\"\n    elif metadata.get(\"sort_by_loc\"):\n        if \"_loc\" in dir1_structure:\n            dir1_title = f\"{dir1_name} ({dir1_structure['_loc']} lines)\"\n        if \"_loc\" in dir2_structure:\n            dir2_title = f\"{dir2_name} ({dir2_structure['_loc']} lines)\"\n    elif metadata.get(\"sort_by_size\"):\n        if \"_size\" in dir1_structure:\n            dir1_title = f\"{dir1_name} ({format_size(dir1_structure['_size'])})\"\n        if \"_size\" in dir2_structure:\n            dir2_title = f\"{dir2_name} ({format_size(dir2_structure['_size'])})\"\n    elif metadata.get(\"sort_by_mtime\"):\n        if \"_mtime\" in dir1_structure:\n            dir1_title = f\"{dir1_name} ({format_timestamp(dir1_structure['_mtime'])})\"\n        if \"_mtime\" in dir2_structure:\n            dir2_title = f\"{dir2_name} ({format_timestamp(dir2_structure['_mtime'])})\"\n    js_format_timestamp = \"\"\n    if metadata.get(\"sort_by_mtime\"):\n        js_format_timestamp = format_timestamp_js()\n    html_template = f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"utf-8\"&gt;\n        &lt;title&gt;Directory Comparison - {dir1_name} vs {dir2_name}&lt;/title&gt;\n        &lt;style&gt;\n            body {{\n                font-family: Arial, sans-serif;\n                margin: 0;\n                padding: 20px;\n            }}\n            .comparison-container {{\n                display: flex;\n                border: 1px solid #ccc;\n            }}\n            .directory-tree {{\n                flex: 1;\n                padding: 15px;\n                overflow: auto;\n                border-right: 1px solid #ccc;\n            }}\n            .directory-tree:last-child {{\n                border-right: none;\n            }}\n            h1, h2 {{\n                text-align: center;\n            }}\n            h3 {{\n                margin-top: 0;\n                padding: 10px;\n                background-color: #f0f0f0;\n                border-bottom: 1px solid #ccc;\n            }}\n            ul {{\n                list-style-type: none;\n                padding-left: 20px;\n            }}\n            .directory {{\n                color: #2c3e50;\n                font-weight: bold;\n            }}\n            .file {{\n                color: #34495e;\n            }}\n            .file-unique-left, .directory-unique-left {{\n                background-color: #d4edda;\n            }}\n            .file-unique-right, .directory-unique-right {{\n                background-color: #f8d7da;\n            }}\n            .max-depth {{\n                color: #999;\n                font-style: italic;\n            }}\n            .legend {{\n                margin-bottom: 20px;\n                padding: 10px;\n                background-color: #f8f9fa;\n                border: 1px solid #ddd;\n                border-radius: 4px;\n            }}\n            .legend-item {{\n                display: inline-block;\n                margin-right: 20px;\n            }}\n            .legend-color {{\n                display: inline-block;\n                width: 15px;\n                height: 15px;\n                margin-right: 5px;\n                vertical-align: middle;\n            }}\n            .legend-left {{\n                background-color: #d4edda;\n            }}\n            .legend-right {{\n                background-color: #f8d7da;\n            }}\n            .pattern-info {{\n                margin-bottom: 20px;\n                padding: 10px;\n                background-color: #f0f8ff;\n                border: 1px solid #add8e6;\n                border-radius: 4px;\n            }}\n            .info-block {{\n                margin-bottom: 10px;\n                color: #333;\n            }}\n            .info-label {{\n                font-weight: bold;\n            }}\n            dt {{\n                font-weight: bold;\n                margin-top: 10px;\n            }}\n            dd {{\n                margin-left: 20px;\n                margin-bottom: 10px;\n            }}\n            .timestamp {{\n                color: #6c757d;\n                font-size: 0.9em;\n            }}\n        &lt;/style&gt;\n        &lt;script&gt;\n            {js_format_timestamp}\n        &lt;/script&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Directory Comparison&lt;/h1&gt;\n        {max_depth_info}\n        {path_info}\n        {loc_info}\n        {size_info}\n        {mtime_info}\n        {pattern_info_html}\n        &lt;div class=\"legend\"&gt;\n            &lt;div class=\"legend-item\"&gt;\n                &lt;span class=\"legend-color legend-left\"&gt;&lt;/span&gt;\n                &lt;span&gt;In this directory&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div class=\"legend-item\"&gt;\n                &lt;span class=\"legend-color legend-right\"&gt;&lt;/span&gt;\n                &lt;span&gt;In the other directory&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div class=\"comparison-container\"&gt;\n            &lt;div class=\"directory-tree\"&gt;\n                &lt;h3&gt;\ud83d\udcc2 {dir1_title}&lt;/h3&gt;\n                &lt;p&gt;&lt;em&gt;Path: {dir1_path}&lt;/em&gt;&lt;/p&gt;\n                {_build_html_tree(dir1_structure, dir2_structure, True)}\n            &lt;/div&gt;\n            &lt;div class=\"directory-tree\"&gt;\n                &lt;h3&gt;\ud83d\udcc2 {dir2_title}&lt;/h3&gt;\n                &lt;p&gt;&lt;em&gt;Path: {dir2_path}&lt;/em&gt;&lt;/p&gt;\n                {_build_html_tree(dir2_structure, dir1_structure, False)}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    with open(output_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(html_template)\n</code></pre>"},{"location":"reference/api-reference/#recursivist.compare.build_comparison_tree","title":"<code>build_comparison_tree(structure, other_structure, tree, color_map, parent_name='Root', show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Build a tree structure with highlighted differences.</p> <p>Recursively builds a Rich tree with visual indicators for: - Items that exist in both structures (normal display) - Items unique to the current structure (green background) - Items unique to the comparison structure (red background)</p> <p>When sort_by_loc is True, also displays lines of code counts. When sort_by_size is True, also displays file sizes. When sort_by_mtime is True, also displays file modification times.</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Dict</code> <p>Dictionary representation of the current directory structure</p> required <code>other_structure</code> <code>Dict</code> <p>Dictionary representation of the comparison directory structure</p> required <code>tree</code> <code>Tree</code> <p>Rich Tree object to build upon</p> required <code>color_map</code> <code>Dict[str, str]</code> <p>Mapping of file extensions to colors</p> required <code>parent_name</code> <code>str</code> <p>Name of the parent directory</p> <code>'Root'</code> <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to display lines of code counts</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to display file sizes</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to display file modification times</p> <code>False</code> Source code in <code>recursivist/compare.py</code> <pre><code>def build_comparison_tree(\n    structure: Dict,\n    other_structure: Dict,\n    tree: Tree,\n    color_map: Dict[str, str],\n    parent_name: str = \"Root\",\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; None:\n    \"\"\"\n    Build a tree structure with highlighted differences.\n\n    Recursively builds a Rich tree with visual indicators for:\n    - Items that exist in both structures (normal display)\n    - Items unique to the current structure (green background)\n    - Items unique to the comparison structure (red background)\n\n    When sort_by_loc is True, also displays lines of code counts.\n    When sort_by_size is True, also displays file sizes.\n    When sort_by_mtime is True, also displays file modification times.\n\n    Args:\n        structure: Dictionary representation of the current directory structure\n        other_structure: Dictionary representation of the comparison directory structure\n        tree: Rich Tree object to build upon\n        color_map: Mapping of file extensions to colors\n        parent_name: Name of the parent directory\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to display lines of code counts\n        sort_by_size: Whether to display file sizes\n        sort_by_mtime: Whether to display file modification times\n    \"\"\"\n\n    if \"_files\" in structure:\n        files_in_other = other_structure.get(\"_files\", []) if other_structure else []\n        files_in_other_names = []\n        for item in files_in_other:\n            if isinstance(item, tuple):\n                files_in_other_names.append(item[0])\n            else:\n                files_in_other_names.append(cast(str, item))\n        for file_item in sort_files_by_type(\n            structure[\"_files\"], sort_by_loc, sort_by_size, sort_by_mtime\n        ):\n            if (\n                sort_by_loc\n                and sort_by_size\n                and sort_by_mtime\n                and isinstance(file_item, tuple)\n                and len(file_item) &gt; 4\n            ):\n                file_name, full_path, loc, size, mtime = file_item\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\",\n                        style=f\"{color} on green\",\n                    )\n                else:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\",\n                        style=color,\n                    )\n                tree.add(colored_text)\n            elif (\n                sort_by_loc\n                and sort_by_mtime\n                and isinstance(file_item, tuple)\n                and len(file_item) &gt; 3\n            ):\n                if len(file_item) &gt; 4:\n                    file_name, full_path, loc, _, mtime = file_item\n                else:\n                    file_name, full_path, loc, mtime = file_item\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines, {format_timestamp(mtime)})\",\n                        style=f\"{color} on green\",\n                    )\n                else:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines, {format_timestamp(mtime)})\",\n                        style=color,\n                    )\n                tree.add(colored_text)\n            elif (\n                sort_by_size\n                and sort_by_mtime\n                and isinstance(file_item, tuple)\n                and len(file_item) &gt; 3\n            ):\n                if len(file_item) &gt; 4:\n                    file_name, full_path, _, size, mtime = file_item\n                else:\n                    file_name, full_path, size, mtime = file_item\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({format_size(size)}, {format_timestamp(mtime)})\",\n                        style=f\"{color} on green\",\n                    )\n                else:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({format_size(size)}, {format_timestamp(mtime)})\",\n                        style=color,\n                    )\n                tree.add(colored_text)\n            elif (\n                sort_by_loc\n                and sort_by_size\n                and isinstance(file_item, tuple)\n                and len(file_item) &gt; 3\n            ):\n                if len(file_item) &gt; 4:\n                    file_name, full_path, loc, size, _ = file_item\n                else:\n                    file_name, full_path, loc, size = file_item\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines, {format_size(size)})\",\n                        style=f\"{color} on green\",\n                    )\n                else:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines, {format_size(size)})\",\n                        style=color,\n                    )\n                tree.add(colored_text)\n            elif sort_by_mtime and isinstance(file_item, tuple) and len(file_item) &gt; 2:\n                if len(file_item) &gt; 4:\n                    file_name, full_path, _, _, mtime = file_item\n                elif len(file_item) &gt; 3:\n                    file_name, full_path, _, mtime = file_item\n                else:\n                    file_name, full_path, mtime = file_item\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({format_timestamp(mtime)})\",\n                        style=f\"{color} on green\",\n                    )\n                else:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({format_timestamp(mtime)})\",\n                        style=color,\n                    )\n                tree.add(colored_text)\n            elif sort_by_size and isinstance(file_item, tuple) and len(file_item) &gt; 2:\n                if len(file_item) &gt; 3:\n                    if len(file_item) &gt; 4:\n                        file_name, full_path, _, size, _ = file_item\n                    else:\n                        file_name, full_path, _, size = file_item\n                else:\n                    file_name, full_path, size = file_item\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({format_size(size)})\",\n                        style=f\"{color} on green\",\n                    )\n                else:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({format_size(size)})\",\n                        style=color,\n                    )\n                tree.add(colored_text)\n            elif sort_by_loc and isinstance(file_item, tuple) and len(file_item) &gt; 2:\n                if len(file_item) &gt; 3:\n                    if len(file_item) &gt; 4:\n                        file_name, full_path, loc, _, _ = file_item\n                    else:\n                        file_name, full_path, loc, _ = file_item\n                else:\n                    file_name, full_path, loc = file_item\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines)\",\n                        style=f\"{color} on green\",\n                    )\n                else:\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines)\",\n                        style=color,\n                    )\n                tree.add(colored_text)\n            elif isinstance(file_item, tuple):\n                if len(file_item) &gt; 4:\n                    file_name, full_path, _, _, _ = file_item\n                elif len(file_item) &gt; 3:\n                    file_name, full_path, _, _ = file_item\n                elif len(file_item) &gt; 2:\n                    file_name, full_path, _ = file_item\n                else:\n                    file_name, full_path = file_item\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(f\"\ud83d\udcc4 {full_path}\", style=f\"{color} on green\")\n                else:\n                    colored_text = Text(f\"\ud83d\udcc4 {full_path}\", style=color)\n                tree.add(colored_text)\n            else:\n                file_name = cast(str, file_item)\n                ext = os.path.splitext(file_name)[1].lower()\n                color = color_map.get(ext, \"#FFFFFF\")\n                if file_name not in files_in_other_names:\n                    colored_text = Text(f\"\ud83d\udcc4 {file_name}\", style=f\"{color} on green\")\n                else:\n                    colored_text = Text(f\"\ud83d\udcc4 {file_name}\", style=color)\n                tree.add(colored_text)\n    for folder, content in sorted(structure.items()):\n        if (\n            folder == \"_files\"\n            or folder == \"_max_depth_reached\"\n            or folder == \"_loc\"\n            or folder == \"_size\"\n            or folder == \"_mtime\"\n        ):\n            continue\n        other_content = other_structure.get(folder, {}) if other_structure else {}\n        if folder not in (other_structure or {}):\n            if (\n                sort_by_loc\n                and sort_by_size\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                folder_loc = content[\"_loc\"]\n                folder_size = content[\"_size\"]\n                folder_mtime = content[\"_mtime\"]\n                subtree = tree.add(\n                    Text(\n                        f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_size(folder_size)}, {format_timestamp(folder_mtime)})\",\n                        style=\"green\",\n                    )\n                )\n            elif (\n                sort_by_loc\n                and sort_by_size\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n            ):\n                folder_loc = content[\"_loc\"]\n                folder_size = content[\"_size\"]\n                subtree = tree.add(\n                    Text(\n                        f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_size(folder_size)})\",\n                        style=\"green\",\n                    )\n                )\n            elif (\n                sort_by_loc\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_mtime\" in content\n            ):\n                folder_loc = content[\"_loc\"]\n                folder_mtime = content[\"_mtime\"]\n                subtree = tree.add(\n                    Text(\n                        f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_timestamp(folder_mtime)})\",\n                        style=\"green\",\n                    )\n                )\n            elif (\n                sort_by_size\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                folder_size = content[\"_size\"]\n                folder_mtime = content[\"_mtime\"]\n                subtree = tree.add(\n                    Text(\n                        f\"\ud83d\udcc1 {folder} ({format_size(folder_size)}, {format_timestamp(folder_mtime)})\",\n                        style=\"green\",\n                    )\n                )\n            elif sort_by_loc and isinstance(content, dict) and \"_loc\" in content:\n                folder_loc = content[\"_loc\"]\n                subtree = tree.add(\n                    Text(f\"\ud83d\udcc1 {folder} ({folder_loc} lines)\", style=\"green\")\n                )\n            elif sort_by_size and isinstance(content, dict) and \"_size\" in content:\n                folder_size = content[\"_size\"]\n                subtree = tree.add(\n                    Text(f\"\ud83d\udcc1 {folder} ({format_size(folder_size)})\", style=\"green\")\n                )\n            elif sort_by_mtime and isinstance(content, dict) and \"_mtime\" in content:\n                folder_mtime = content[\"_mtime\"]\n                subtree = tree.add(\n                    Text(\n                        f\"\ud83d\udcc1 {folder} ({format_timestamp(folder_mtime)})\", style=\"green\"\n                    )\n                )\n            else:\n                subtree = tree.add(Text(f\"\ud83d\udcc1 {folder}\", style=\"green\"))\n        else:\n            if (\n                sort_by_loc\n                and sort_by_size\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                folder_loc = content[\"_loc\"]\n                folder_size = content[\"_size\"]\n                folder_mtime = content[\"_mtime\"]\n                subtree = tree.add(\n                    f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_size(folder_size)}, {format_timestamp(folder_mtime)})\"\n                )\n            elif (\n                sort_by_loc\n                and sort_by_size\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_size\" in content\n            ):\n                folder_loc = content[\"_loc\"]\n                folder_size = content[\"_size\"]\n                subtree = tree.add(\n                    f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_size(folder_size)})\"\n                )\n            elif (\n                sort_by_loc\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_loc\" in content\n                and \"_mtime\" in content\n            ):\n                folder_loc = content[\"_loc\"]\n                folder_mtime = content[\"_mtime\"]\n                subtree = tree.add(\n                    f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_timestamp(folder_mtime)})\"\n                )\n            elif (\n                sort_by_size\n                and sort_by_mtime\n                and isinstance(content, dict)\n                and \"_size\" in content\n                and \"_mtime\" in content\n            ):\n                folder_size = content[\"_size\"]\n                folder_mtime = content[\"_mtime\"]\n                subtree = tree.add(\n                    f\"\ud83d\udcc1 {folder} ({format_size(folder_size)}, {format_timestamp(folder_mtime)})\"\n                )\n            elif sort_by_loc and isinstance(content, dict) and \"_loc\" in content:\n                folder_loc = content[\"_loc\"]\n                subtree = tree.add(f\"\ud83d\udcc1 {folder} ({folder_loc} lines)\")\n            elif sort_by_size and isinstance(content, dict) and \"_size\" in content:\n                folder_size = content[\"_size\"]\n                subtree = tree.add(f\"\ud83d\udcc1 {folder} ({format_size(folder_size)})\")\n            elif sort_by_mtime and isinstance(content, dict) and \"_mtime\" in content:\n                folder_mtime = content[\"_mtime\"]\n                subtree = tree.add(f\"\ud83d\udcc1 {folder} ({format_timestamp(folder_mtime)})\")\n            else:\n                subtree = tree.add(f\"\ud83d\udcc1 {folder}\")\n        if isinstance(content, dict) and content.get(\"_max_depth_reached\"):\n            subtree.add(Text(\"\u22ef (max depth reached)\", style=\"dim\"))\n        else:\n            build_comparison_tree(\n                content,\n                other_content,\n                subtree,\n                color_map,\n                folder,\n                show_full_path,\n                sort_by_loc,\n                sort_by_size,\n                sort_by_mtime,\n            )\n    if other_structure and \"_files\" in other_structure:\n        files_in_this_names = []\n        files_in_this = structure.get(\"_files\", [])\n        for item in files_in_this:\n            if isinstance(item, tuple):\n                files_in_this_names.append(item[0])\n            else:\n                files_in_this_names.append(cast(str, item))\n        for file_item in sort_files_by_type(\n            other_structure[\"_files\"], sort_by_loc, sort_by_size, sort_by_mtime\n        ):\n            file_name = \"\"\n            if isinstance(file_item, tuple):\n                file_name = file_item[0]\n            else:\n                file_name = cast(str, file_item)\n            if file_name not in files_in_this_names:\n                if (\n                    sort_by_loc\n                    and sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 4\n                ):\n                    _, display_path, loc, size, mtime = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({loc} lines, {format_size(size)}, {format_timestamp(mtime)})\",\n                        style=f\"{color} on red\",\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_loc\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, loc, _, mtime = file_item\n                    else:\n                        _, display_path, loc, mtime = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({loc} lines, {format_timestamp(mtime)})\",\n                        style=f\"{color} on red\",\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, _, size, mtime = file_item\n                    else:\n                        _, display_path, size, mtime = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({format_size(size)}, {format_timestamp(mtime)})\",\n                        style=f\"{color} on red\",\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_loc\n                    and sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        _, display_path, loc, size, _ = file_item\n                    else:\n                        _, display_path, loc, size = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {display_path} ({loc} lines, {format_size(size)})\",\n                        style=f\"{color} on red\",\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        _, full_path, _, _, mtime = file_item\n                    elif len(file_item) &gt; 3:\n                        _, full_path, _, mtime = file_item\n                    else:\n                        _, full_path, mtime = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({format_timestamp(mtime)})\",\n                        style=f\"{color} on red\",\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_size and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 3:\n                        if len(file_item) &gt; 4:\n                            _, full_path, _, size, _ = file_item\n                        else:\n                            _, full_path, _, size = file_item\n                    else:\n                        _, full_path, size = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({format_size(size)})\",\n                        style=f\"{color} on red\",\n                    )\n                    tree.add(colored_text)\n                elif (\n                    sort_by_loc and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 3:\n                        if len(file_item) &gt; 4:\n                            _, full_path, loc, _, _ = file_item\n                        else:\n                            _, full_path, loc, _ = file_item\n                    else:\n                        _, full_path, loc = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(\n                        f\"\ud83d\udcc4 {full_path} ({loc} lines)\",\n                        style=f\"{color} on red\",\n                    )\n                    tree.add(colored_text)\n                elif isinstance(file_item, tuple):\n                    if len(file_item) &gt; 4:\n                        _, full_path, _, _, _ = file_item\n                    elif len(file_item) &gt; 3:\n                        _, full_path, _, _ = file_item\n                    elif len(file_item) &gt; 2:\n                        _, full_path, _ = file_item\n                    else:\n                        _, full_path = file_item\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(f\"\ud83d\udcc4 {full_path}\", style=f\"{color} on red\")\n                    tree.add(colored_text)\n                else:\n                    ext = os.path.splitext(file_name)[1].lower()\n                    color = color_map.get(ext, \"#FFFFFF\")\n                    colored_text = Text(f\"\ud83d\udcc4 {file_name}\", style=f\"{color} on red\")\n                    tree.add(colored_text)\n    if other_structure:\n        for folder in sorted(other_structure.keys()):\n            if (\n                folder != \"_files\"\n                and folder != \"_max_depth_reached\"\n                and folder != \"_loc\"\n                and folder != \"_size\"\n                and folder != \"_mtime\"\n                and folder not in structure\n            ):\n                other_content = other_structure[folder]\n                if (\n                    sort_by_loc\n                    and sort_by_size\n                    and sort_by_mtime\n                    and isinstance(other_content, dict)\n                    and \"_loc\" in other_content\n                    and \"_size\" in other_content\n                    and \"_mtime\" in other_content\n                ):\n                    folder_loc = other_content[\"_loc\"]\n                    folder_size = other_content[\"_size\"]\n                    folder_mtime = other_content[\"_mtime\"]\n                    subtree = tree.add(\n                        Text(\n                            f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_size(folder_size)}, {format_timestamp(folder_mtime)})\",\n                            style=\"red\",\n                        )\n                    )\n                elif (\n                    sort_by_loc\n                    and sort_by_size\n                    and isinstance(other_content, dict)\n                    and \"_loc\" in other_content\n                    and \"_size\" in other_content\n                ):\n                    folder_loc = other_content[\"_loc\"]\n                    folder_size = other_content[\"_size\"]\n                    subtree = tree.add(\n                        Text(\n                            f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_size(folder_size)})\",\n                            style=\"red\",\n                        )\n                    )\n                elif (\n                    sort_by_loc\n                    and sort_by_mtime\n                    and isinstance(other_content, dict)\n                    and \"_loc\" in other_content\n                    and \"_mtime\" in other_content\n                ):\n                    folder_loc = other_content[\"_loc\"]\n                    folder_mtime = other_content[\"_mtime\"]\n                    subtree = tree.add(\n                        Text(\n                            f\"\ud83d\udcc1 {folder} ({folder_loc} lines, {format_timestamp(folder_mtime)})\",\n                            style=\"red\",\n                        )\n                    )\n                elif (\n                    sort_by_size\n                    and sort_by_mtime\n                    and isinstance(other_content, dict)\n                    and \"_size\" in other_content\n                    and \"_mtime\" in other_content\n                ):\n                    folder_size = other_content[\"_size\"]\n                    folder_mtime = other_content[\"_mtime\"]\n                    subtree = tree.add(\n                        Text(\n                            f\"\ud83d\udcc1 {folder} ({format_size(folder_size)}, {format_timestamp(folder_mtime)})\",\n                            style=\"red\",\n                        )\n                    )\n                elif (\n                    sort_by_loc\n                    and isinstance(other_content, dict)\n                    and \"_loc\" in other_content\n                ):\n                    folder_loc = other_content[\"_loc\"]\n                    subtree = tree.add(\n                        Text(f\"\ud83d\udcc1 {folder} ({folder_loc} lines)\", style=\"red\")\n                    )\n                elif (\n                    sort_by_size\n                    and isinstance(other_content, dict)\n                    and \"_size\" in other_content\n                ):\n                    folder_size = other_content[\"_size\"]\n                    subtree = tree.add(\n                        Text(f\"\ud83d\udcc1 {folder} ({format_size(folder_size)})\", style=\"red\")\n                    )\n                elif (\n                    sort_by_mtime\n                    and isinstance(other_content, dict)\n                    and \"_mtime\" in other_content\n                ):\n                    folder_mtime = other_content[\"_mtime\"]\n                    subtree = tree.add(\n                        Text(\n                            f\"\ud83d\udcc1 {folder} ({format_timestamp(folder_mtime)})\",\n                            style=\"red\",\n                        )\n                    )\n                else:\n                    subtree = tree.add(Text(f\"\ud83d\udcc1 {folder}\", style=\"red\"))\n                if isinstance(other_content, dict) and other_content.get(\n                    \"_max_depth_reached\"\n                ):\n                    subtree.add(Text(\"\u22ef (max depth reached)\", style=\"dim\"))\n                else:\n                    build_comparison_tree(\n                        {},\n                        other_content,\n                        subtree,\n                        color_map,\n                        folder,\n                        show_full_path,\n                        sort_by_loc,\n                        sort_by_size,\n                        sort_by_mtime,\n                    )\n</code></pre>"},{"location":"reference/api-reference/#recursivist.compare.compare_directory_structures","title":"<code>compare_directory_structures(dir1, dir2, exclude_dirs=None, ignore_file=None, exclude_extensions=None, exclude_patterns=None, include_patterns=None, max_depth=0, show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Compare two directory structures and return both structures with a combined set of extensions.</p> <p>Retrieves the directory structures for both directories using the same filtering options, then combines their file extensions for consistent color mapping in visualizations.</p> <p>Parameters:</p> Name Type Description Default <code>dir1</code> <code>str</code> <p>Path to the first directory</p> required <code>dir2</code> <code>str</code> <p>Path to the second directory</p> required <code>exclude_dirs</code> <code>Optional[Sequence[str]]</code> <p>List of directory names to exclude</p> <code>None</code> <code>ignore_file</code> <code>Optional[str]</code> <p>Name of ignore file (like .gitignore)</p> <code>None</code> <code>exclude_extensions</code> <code>Optional[Set[str]]</code> <p>Set of file extensions to exclude</p> <code>None</code> <code>exclude_patterns</code> <code>Optional[Sequence[Union[str, Pattern]]]</code> <p>List of patterns to exclude</p> <code>None</code> <code>include_patterns</code> <code>Optional[Sequence[Union[str, Pattern]]]</code> <p>List of patterns to include (overrides exclusions)</p> <code>None</code> <code>max_depth</code> <code>int</code> <p>Maximum depth to display (0 for unlimited)</p> <code>0</code> <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to calculate and display lines of code counts</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to calculate and display file sizes</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to calculate and display file modification times</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[Dict, Dict, Set[str]]</code> <p>Tuple of (structure1, structure2, combined_extensions)</p> Source code in <code>recursivist/compare.py</code> <pre><code>def compare_directory_structures(\n    dir1: str,\n    dir2: str,\n    exclude_dirs: Optional[Sequence[str]] = None,\n    ignore_file: Optional[str] = None,\n    exclude_extensions: Optional[Set[str]] = None,\n    exclude_patterns: Optional[Sequence[Union[str, Pattern]]] = None,\n    include_patterns: Optional[Sequence[Union[str, Pattern]]] = None,\n    max_depth: int = 0,\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; Tuple[Dict, Dict, Set[str]]:\n    \"\"\"Compare two directory structures and return both structures with a combined set of extensions.\n\n    Retrieves the directory structures for both directories using the same filtering options, then combines their file extensions for consistent color mapping in visualizations.\n\n    Args:\n        dir1: Path to the first directory\n        dir2: Path to the second directory\n        exclude_dirs: List of directory names to exclude\n        ignore_file: Name of ignore file (like .gitignore)\n        exclude_extensions: Set of file extensions to exclude\n        exclude_patterns: List of patterns to exclude\n        include_patterns: List of patterns to include (overrides exclusions)\n        max_depth: Maximum depth to display (0 for unlimited)\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to calculate and display lines of code counts\n        sort_by_size: Whether to calculate and display file sizes\n        sort_by_mtime: Whether to calculate and display file modification times\n\n    Returns:\n        Tuple of (structure1, structure2, combined_extensions)\n    \"\"\"\n\n    structure1, extensions1 = get_directory_structure(\n        dir1,\n        exclude_dirs,\n        ignore_file,\n        exclude_extensions,\n        exclude_patterns=exclude_patterns,\n        include_patterns=include_patterns,\n        max_depth=max_depth,\n        show_full_path=show_full_path,\n        sort_by_loc=sort_by_loc,\n        sort_by_size=sort_by_size,\n        sort_by_mtime=sort_by_mtime,\n    )\n    structure2, extensions2 = get_directory_structure(\n        dir2,\n        exclude_dirs,\n        ignore_file,\n        exclude_extensions,\n        exclude_patterns=exclude_patterns,\n        include_patterns=include_patterns,\n        max_depth=max_depth,\n        show_full_path=show_full_path,\n        sort_by_loc=sort_by_loc,\n        sort_by_size=sort_by_size,\n        sort_by_mtime=sort_by_mtime,\n    )\n    combined_extensions = extensions1.union(extensions2)\n    return structure1, structure2, combined_extensions\n</code></pre>"},{"location":"reference/api-reference/#recursivist.compare.display_comparison","title":"<code>display_comparison(dir1, dir2, exclude_dirs=None, ignore_file=None, exclude_extensions=None, exclude_patterns=None, include_patterns=None, use_regex=False, max_depth=0, show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Display two directory trees side by side with highlighted differences.</p> <p>Creates a side-by-side terminal visualization with: - Two panel layout with labeled directory trees - Color-coded highlighting for unique items (green/red background) - Informative legend explaining the highlighting - Support for all standard filtering options - Optional statistics display (LOC, size, modification time)</p> <p>Parameters:</p> Name Type Description Default <code>dir1</code> <code>str</code> <p>Path to the first directory</p> required <code>dir2</code> <code>str</code> <p>Path to the second directory</p> required <code>exclude_dirs</code> <code>Optional[List[str]]</code> <p>List of directory names to exclude</p> <code>None</code> <code>ignore_file</code> <code>Optional[str]</code> <p>Name of ignore file (like .gitignore)</p> <code>None</code> <code>exclude_extensions</code> <code>Optional[Set[str]]</code> <p>Set of file extensions to exclude</p> <code>None</code> <code>exclude_patterns</code> <code>Optional[List[str]]</code> <p>List of patterns to exclude</p> <code>None</code> <code>include_patterns</code> <code>Optional[List[str]]</code> <p>List of patterns to include (overrides exclusions)</p> <code>None</code> <code>use_regex</code> <code>bool</code> <p>Whether to treat patterns as regex instead of glob patterns</p> <code>False</code> <code>max_depth</code> <code>int</code> <p>Maximum depth to display (0 for unlimited)</p> <code>0</code> <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to show and sort by lines of code</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to show and sort by file size</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to show and sort by modification time</p> <code>False</code> Source code in <code>recursivist/compare.py</code> <pre><code>def display_comparison(\n    dir1: str,\n    dir2: str,\n    exclude_dirs: Optional[List[str]] = None,\n    ignore_file: Optional[str] = None,\n    exclude_extensions: Optional[Set[str]] = None,\n    exclude_patterns: Optional[List[str]] = None,\n    include_patterns: Optional[List[str]] = None,\n    use_regex: bool = False,\n    max_depth: int = 0,\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; None:\n    \"\"\"Display two directory trees side by side with highlighted differences.\n\n    Creates a side-by-side terminal visualization with:\n    - Two panel layout with labeled directory trees\n    - Color-coded highlighting for unique items (green/red background)\n    - Informative legend explaining the highlighting\n    - Support for all standard filtering options\n    - Optional statistics display (LOC, size, modification time)\n\n    Args:\n        dir1: Path to the first directory\n        dir2: Path to the second directory\n        exclude_dirs: List of directory names to exclude\n        ignore_file: Name of ignore file (like .gitignore)\n        exclude_extensions: Set of file extensions to exclude\n        exclude_patterns: List of patterns to exclude\n        include_patterns: List of patterns to include (overrides exclusions)\n        use_regex: Whether to treat patterns as regex instead of glob patterns\n        max_depth: Maximum depth to display (0 for unlimited)\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to show and sort by lines of code\n        sort_by_size: Whether to show and sort by file size\n        sort_by_mtime: Whether to show and sort by modification time\n    \"\"\"\n\n    if exclude_dirs is None:\n        exclude_dirs = []\n    if exclude_extensions is None:\n        exclude_extensions = set()\n    if exclude_patterns is None:\n        exclude_patterns = []\n    if include_patterns is None:\n        include_patterns = []\n    exclude_extensions = {\n        ext.lower() if ext.startswith(\".\") else f\".{ext.lower()}\"\n        for ext in exclude_extensions\n    }\n    compiled_exclude = compile_regex_patterns(exclude_patterns, use_regex)\n    compiled_include = compile_regex_patterns(include_patterns, use_regex)\n    structure1, structure2, extensions = compare_directory_structures(\n        dir1,\n        dir2,\n        exclude_dirs,\n        ignore_file,\n        exclude_extensions,\n        exclude_patterns=compiled_exclude,\n        include_patterns=compiled_include,\n        max_depth=max_depth,\n        show_full_path=show_full_path,\n        sort_by_loc=sort_by_loc,\n        sort_by_size=sort_by_size,\n        sort_by_mtime=sort_by_mtime,\n    )\n    color_map = {ext: generate_color_for_extension(ext) for ext in extensions}\n    console = Console()\n    if (\n        sort_by_loc\n        and sort_by_size\n        and sort_by_mtime\n        and \"_loc\" in structure1\n        and \"_size\" in structure1\n        and \"_mtime\" in structure1\n    ):\n        tree1 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir1)} ({structure1['_loc']} lines, {format_size(structure1['_size'])}, {format_timestamp(structure1['_mtime'])})\",\n                style=\"bold\",\n            )\n        )\n    elif (\n        sort_by_loc and sort_by_size and \"_loc\" in structure1 and \"_size\" in structure1\n    ):\n        tree1 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir1)} ({structure1['_loc']} lines, {format_size(structure1['_size'])})\",\n                style=\"bold\",\n            )\n        )\n    elif (\n        sort_by_loc\n        and sort_by_mtime\n        and \"_loc\" in structure1\n        and \"_mtime\" in structure1\n    ):\n        tree1 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir1)} ({structure1['_loc']} lines, {format_timestamp(structure1['_mtime'])})\",\n                style=\"bold\",\n            )\n        )\n    elif (\n        sort_by_size\n        and sort_by_mtime\n        and \"_size\" in structure1\n        and \"_mtime\" in structure1\n    ):\n        tree1 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir1)} ({format_size(structure1['_size'])}, {format_timestamp(structure1['_mtime'])})\",\n                style=\"bold\",\n            )\n        )\n    elif sort_by_loc and \"_loc\" in structure1:\n        tree1 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir1)} ({structure1['_loc']} lines)\",\n                style=\"bold\",\n            )\n        )\n    elif sort_by_size and \"_size\" in structure1:\n        tree1 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir1)} ({format_size(structure1['_size'])})\",\n                style=\"bold\",\n            )\n        )\n    elif sort_by_mtime and \"_mtime\" in structure1:\n        tree1 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir1)} ({format_timestamp(structure1['_mtime'])})\",\n                style=\"bold\",\n            )\n        )\n    else:\n        tree1 = Tree(Text(f\"\ud83d\udcc2 {os.path.basename(dir1)}\", style=\"bold\"))\n    if (\n        sort_by_loc\n        and sort_by_size\n        and sort_by_mtime\n        and \"_loc\" in structure2\n        and \"_size\" in structure2\n        and \"_mtime\" in structure2\n    ):\n        tree2 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir2)} ({structure2['_loc']} lines, {format_size(structure2['_size'])}, {format_timestamp(structure2['_mtime'])})\",\n                style=\"bold\",\n            )\n        )\n    elif (\n        sort_by_loc and sort_by_size and \"_loc\" in structure2 and \"_size\" in structure2\n    ):\n        tree2 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir2)} ({structure2['_loc']} lines, {format_size(structure2['_size'])})\",\n                style=\"bold\",\n            )\n        )\n    elif (\n        sort_by_loc\n        and sort_by_mtime\n        and \"_loc\" in structure2\n        and \"_mtime\" in structure2\n    ):\n        tree2 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir2)} ({structure2['_loc']} lines, {format_timestamp(structure2['_mtime'])})\",\n                style=\"bold\",\n            )\n        )\n    elif (\n        sort_by_size\n        and sort_by_mtime\n        and \"_size\" in structure2\n        and \"_mtime\" in structure2\n    ):\n        tree2 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir2)} ({format_size(structure2['_size'])}, {format_timestamp(structure2['_mtime'])})\",\n                style=\"bold\",\n            )\n        )\n    elif sort_by_loc and \"_loc\" in structure2:\n        tree2 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir2)} ({structure2['_loc']} lines)\",\n                style=\"bold\",\n            )\n        )\n    elif sort_by_size and \"_size\" in structure2:\n        tree2 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir2)} ({format_size(structure2['_size'])})\",\n                style=\"bold\",\n            )\n        )\n    elif sort_by_mtime and \"_mtime\" in structure2:\n        tree2 = Tree(\n            Text(\n                f\"\ud83d\udcc2 {os.path.basename(dir2)} ({format_timestamp(structure2['_mtime'])})\",\n                style=\"bold\",\n            )\n        )\n    else:\n        tree2 = Tree(Text(f\"\ud83d\udcc2 {os.path.basename(dir2)}\", style=\"bold\"))\n    build_comparison_tree(\n        structure1,\n        structure2,\n        tree1,\n        color_map,\n        show_full_path=show_full_path,\n        sort_by_loc=sort_by_loc,\n        sort_by_size=sort_by_size,\n        sort_by_mtime=sort_by_mtime,\n    )\n    build_comparison_tree(\n        structure2,\n        structure1,\n        tree2,\n        color_map,\n        show_full_path=show_full_path,\n        sort_by_loc=sort_by_loc,\n        sort_by_size=sort_by_size,\n        sort_by_mtime=sort_by_mtime,\n    )\n    legend_text = Text()\n    legend_text.append(\"Legend: \", style=\"bold\")\n    legend_text.append(\"Green background \", style=\"on green\")\n    legend_text.append(\"= In this directory, \")\n    legend_text.append(\"Red background \", style=\"on red\")\n    legend_text.append(\"= In the other directory\")\n    if sort_by_loc:\n        legend_text.append(\"\\n\")\n        legend_text.append(\n            \"LOC counts shown in parentheses, files sorted by line count\"\n        )\n    if sort_by_size:\n        legend_text.append(\"\\n\")\n        legend_text.append(\"File sizes shown in parentheses, files sorted by size\")\n    if sort_by_mtime:\n        legend_text.append(\"\\n\")\n        legend_text.append(\n            \"Modification times shown in parentheses, files sorted by newest first\"\n        )\n    if max_depth &gt; 0:\n        legend_text.append(\"\\n\")\n        legend_text.append(\"\u22ef (max depth reached) \", style=\"dim\")\n        legend_text.append(f\"= Directory tree is limited to {max_depth} levels\")\n    if show_full_path:\n        legend_text.append(\"\\n\")\n        legend_text.append(\"Full file paths are shown instead of just filenames\")\n    if exclude_patterns or include_patterns:\n        pattern_info = []\n        if exclude_patterns:\n            pattern_type = \"Regex\" if use_regex else \"Glob\"\n            pattern_info.append(\n                f\"{pattern_type} exclusion patterns: {', '.join(str(p) for p in exclude_patterns)}\"\n            )\n        if include_patterns:\n            pattern_type = \"Regex\" if use_regex else \"Glob\"\n            pattern_info.append(\n                f\"{pattern_type} inclusion patterns: {', '.join(str(p) for p in include_patterns)}\"\n            )\n        if pattern_info:\n            pattern_panel = Panel(\n                \"\\n\".join(pattern_info), title=\"Applied Patterns\", border_style=\"blue\"\n            )\n            console.print(pattern_panel)\n    legend_panel = Panel(legend_text, border_style=\"dim\")\n    console.print(legend_panel)\n    console.print(\n        Columns(\n            [\n                Panel(\n                    tree1,\n                    title=f\"Directory 1: {os.path.basename(dir1)}\",\n                    border_style=\"blue\",\n                ),\n                Panel(\n                    tree2,\n                    title=f\"Directory 2: {os.path.basename(dir2)}\",\n                    border_style=\"green\",\n                ),\n            ],\n            equal=True,\n            expand=True,\n        )\n    )\n</code></pre>"},{"location":"reference/api-reference/#recursivist.compare.export_comparison","title":"<code>export_comparison(dir1, dir2, format_type, output_path, exclude_dirs=None, ignore_file=None, exclude_extensions=None, exclude_patterns=None, include_patterns=None, use_regex=False, max_depth=0, show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Export directory comparison to HTML format.</p> <p>Creates an HTML file containing the side-by-side comparison with: - Highlighted differences between directories - Interactive, responsive layout - Detailed metadata about the comparison settings - Visual legend explaining the highlighting - Optional statistics display</p> <p>Currently only supports HTML export format.</p> <p>Parameters:</p> Name Type Description Default <code>dir1</code> <code>str</code> <p>Path to the first directory</p> required <code>dir2</code> <code>str</code> <p>Path to the second directory</p> required <code>format_type</code> <code>str</code> <p>Export format (only 'html' is supported)</p> required <code>output_path</code> <code>str</code> <p>Path where the export file will be saved</p> required <code>exclude_dirs</code> <code>Optional[List[str]]</code> <p>List of directory names to exclude</p> <code>None</code> <code>ignore_file</code> <code>Optional[str]</code> <p>Name of ignore file (like .gitignore)</p> <code>None</code> <code>exclude_extensions</code> <code>Optional[Set[str]]</code> <p>Set of file extensions to exclude</p> <code>None</code> <code>exclude_patterns</code> <code>Optional[List[str]]</code> <p>List of patterns to exclude</p> <code>None</code> <code>include_patterns</code> <code>Optional[List[str]]</code> <p>List of patterns to include (overrides exclusions)</p> <code>None</code> <code>use_regex</code> <code>bool</code> <p>Whether to treat patterns as regex instead of glob patterns</p> <code>False</code> <code>max_depth</code> <code>int</code> <p>Maximum depth to display (0 for unlimited)</p> <code>0</code> <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to show and sort by lines of code</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to show and sort by file size</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to show and sort by modification time</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the format_type is not supported</p> Source code in <code>recursivist/compare.py</code> <pre><code>def export_comparison(\n    dir1: str,\n    dir2: str,\n    format_type: str,\n    output_path: str,\n    exclude_dirs: Optional[List[str]] = None,\n    ignore_file: Optional[str] = None,\n    exclude_extensions: Optional[Set[str]] = None,\n    exclude_patterns: Optional[List[str]] = None,\n    include_patterns: Optional[List[str]] = None,\n    use_regex: bool = False,\n    max_depth: int = 0,\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; None:\n    \"\"\"Export directory comparison to HTML format.\n\n    Creates an HTML file containing the side-by-side comparison with:\n    - Highlighted differences between directories\n    - Interactive, responsive layout\n    - Detailed metadata about the comparison settings\n    - Visual legend explaining the highlighting\n    - Optional statistics display\n\n    Currently only supports HTML export format.\n\n    Args:\n        dir1: Path to the first directory\n        dir2: Path to the second directory\n        format_type: Export format (only 'html' is supported)\n        output_path: Path where the export file will be saved\n        exclude_dirs: List of directory names to exclude\n        ignore_file: Name of ignore file (like .gitignore)\n        exclude_extensions: Set of file extensions to exclude\n        exclude_patterns: List of patterns to exclude\n        include_patterns: List of patterns to include (overrides exclusions)\n        use_regex: Whether to treat patterns as regex instead of glob patterns\n        max_depth: Maximum depth to display (0 for unlimited)\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to show and sort by lines of code\n        sort_by_size: Whether to show and sort by file size\n        sort_by_mtime: Whether to show and sort by modification time\n\n    Raises:\n        ValueError: If the format_type is not supported\n    \"\"\"\n\n    if exclude_dirs is None:\n        exclude_dirs = []\n    if exclude_extensions is None:\n        exclude_extensions = set()\n    if exclude_patterns is None:\n        exclude_patterns = []\n    if include_patterns is None:\n        include_patterns = []\n    exclude_extensions = {\n        ext.lower() if ext.startswith(\".\") else f\".{ext.lower()}\"\n        for ext in exclude_extensions\n    }\n    compiled_exclude = compile_regex_patterns(exclude_patterns, use_regex)\n    compiled_include = compile_regex_patterns(include_patterns, use_regex)\n    structure1, structure2, _ = compare_directory_structures(\n        dir1,\n        dir2,\n        exclude_dirs,\n        ignore_file,\n        exclude_extensions,\n        exclude_patterns=compiled_exclude,\n        include_patterns=compiled_include,\n        max_depth=max_depth,\n        show_full_path=show_full_path,\n        sort_by_loc=sort_by_loc,\n        sort_by_size=sort_by_size,\n        sort_by_mtime=sort_by_mtime,\n    )\n    comparison_data = {\n        \"dir1\": {\"path\": dir1, \"name\": os.path.basename(dir1), \"structure\": structure1},\n        \"dir2\": {\"path\": dir2, \"name\": os.path.basename(dir2), \"structure\": structure2},\n        \"metadata\": {\n            \"exclude_patterns\": [str(p) for p in exclude_patterns],\n            \"include_patterns\": [str(p) for p in include_patterns],\n            \"pattern_type\": \"regex\" if use_regex else \"glob\",\n            \"max_depth\": max_depth,\n            \"show_full_path\": show_full_path,\n            \"sort_by_loc\": sort_by_loc,\n            \"sort_by_size\": sort_by_size,\n            \"sort_by_mtime\": sort_by_mtime,\n        },\n    }\n    if format_type == \"html\":\n        _export_comparison_to_html(comparison_data, output_path)\n    else:\n        raise ValueError(\"Only HTML format is supported for comparison export\")\n</code></pre>"},{"location":"reference/api-reference/#jsx-export-module","title":"JSX Export Module","text":""},{"location":"reference/api-reference/#recursivist.jsx_export","title":"<code>recursivist.jsx_export</code>","text":"<p>React component export functionality for the Recursivist directory visualization tool.</p> <p>This module generates a JSX file containing a sophisticated, interactive directory viewer React component with advanced features:</p> <ul> <li>Folder expansion/collapse functionality</li> <li>Breadcrumb navigation</li> <li>Search with highlighted matches</li> <li>Dark mode toggle</li> <li>Optional file statistics display</li> <li>Sorting by different metrics</li> <li>Path copying</li> <li>Mobile-responsive design</li> </ul> <p>The generated component is standalone and can be integrated into React applications with minimal dependencies.</p>"},{"location":"reference/api-reference/#recursivist.jsx_export.generate_jsx_component","title":"<code>generate_jsx_component(structure, root_name, output_path, show_full_path=False, sort_by_loc=False, sort_by_size=False, sort_by_mtime=False)</code>","text":"<p>Generate a React component file for directory structure visualization.</p> <p>Creates a standalone JSX file containing a sophisticated directory viewer component with: - Reliable folder expand/collapse functionality - Breadcrumbs navigation - Search functionality with highlighted matches - Dark mode toggle - Path copying - Expand/collapse all buttons - Optional statistics display (LOC, size, modification times) - Mobile-responsive design</p> <p>Parameters:</p> Name Type Description Default <code>structure</code> <code>Dict[str, Any]</code> <p>Directory structure dictionary</p> required <code>root_name</code> <code>str</code> <p>Root directory name</p> required <code>output_path</code> <code>str</code> <p>Path where the React component file will be saved</p> required <code>show_full_path</code> <code>bool</code> <p>Whether to show full paths instead of just filenames</p> <code>False</code> <code>sort_by_loc</code> <code>bool</code> <p>Whether to show lines of code counts and sort by them</p> <code>False</code> <code>sort_by_size</code> <code>bool</code> <p>Whether to show file sizes and sort by them</p> <code>False</code> <code>sort_by_mtime</code> <code>bool</code> <p>Whether to show file modification times and sort by them</p> <code>False</code> Source code in <code>recursivist/jsx_export.py</code> <pre><code>def generate_jsx_component(\n    structure: Dict[str, Any],\n    root_name: str,\n    output_path: str,\n    show_full_path: bool = False,\n    sort_by_loc: bool = False,\n    sort_by_size: bool = False,\n    sort_by_mtime: bool = False,\n) -&gt; None:\n    \"\"\"Generate a React component file for directory structure visualization.\n\n    Creates a standalone JSX file containing a sophisticated directory viewer component with:\n    - Reliable folder expand/collapse functionality\n    - Breadcrumbs navigation\n    - Search functionality with highlighted matches\n    - Dark mode toggle\n    - Path copying\n    - Expand/collapse all buttons\n    - Optional statistics display (LOC, size, modification times)\n    - Mobile-responsive design\n\n    Args:\n        structure: Directory structure dictionary\n        root_name: Root directory name\n        output_path: Path where the React component file will be saved\n        show_full_path: Whether to show full paths instead of just filenames\n        sort_by_loc: Whether to show lines of code counts and sort by them\n        sort_by_size: Whether to show file sizes and sort by them\n        sort_by_mtime: Whether to show file modification times and sort by them\n    \"\"\"\n\n    def _build_structure_jsx(\n        structure: Dict[str, Any], level: int = 0, path_prefix: str = \"\"\n    ) -&gt; str:\n        jsx_content = []\n        for name, content in sorted(\n            [\n                (k, v)\n                for k, v in structure.items()\n                if k != \"_files\"\n                and k != \"_max_depth_reached\"\n                and k != \"_loc\"\n                and k != \"_size\"\n                and k != \"_mtime\"\n            ],\n            key=lambda x: x[0].lower(),\n        ):\n            current_path = f\"{path_prefix}/{name}\" if path_prefix else name\n            path_parts = current_path.split(\"/\") if current_path else [name]\n            if path_parts[0] == root_name and len(path_parts) &gt; 1:\n                path_parts = [root_name] + [p for p in path_parts[1:] if p]\n            else:\n                path_parts = [p for p in path_parts if p]\n                if not path_parts or path_parts[0] != root_name:\n                    path_parts = [root_name] + path_parts\n            path_json = \",\".join([f'\"{html.escape(part)}\"' for part in path_parts])\n            loc_prop = \"\"\n            size_prop = \"\"\n            mtime_prop = \"\"\n            if sort_by_loc and isinstance(content, dict) and \"_loc\" in content:\n                loc_prop = f' locCount={{{content[\"_loc\"]}}}'\n            if sort_by_size and isinstance(content, dict) and \"_size\" in content:\n                size_prop = f' sizeCount={{{content[\"_size\"]}}}'\n            if sort_by_mtime and isinstance(content, dict) and \"_mtime\" in content:\n                mtime_prop = f' mtimeCount={{{content[\"_mtime\"]}}}'\n            jsx_content.append(\n                f\"&lt;DirectoryItem \"\n                f'name=\"{html.escape(name)}\" '\n                f\"level={{{level}}} \"\n                f\"path={{[{path_json}]}} \"\n                f'type=\"directory\"{loc_prop}{size_prop}{mtime_prop}&gt;'\n            )\n            next_path = current_path\n            if isinstance(content, dict):\n                if content.get(\"_max_depth_reached\"):\n                    jsx_content.append(\n                        '&lt;div className=\"p-3 bg-gray-50 rounded-lg border border-gray-100 ml-4 my-1\"&gt;'\n                    )\n                    jsx_content.append(\n                        '&lt;p className=\"text-gray-500\"&gt;\u22ef (max depth reached)&lt;/p&gt;'\n                    )\n                    jsx_content.append(\"&lt;/div&gt;\")\n                else:\n                    jsx_content.append(\n                        _build_structure_jsx(content, level + 1, next_path)\n                    )\n            jsx_content.append(\"&lt;/DirectoryItem&gt;\")\n        if \"_files\" in structure:\n            files = structure[\"_files\"]\n            if sort_by_loc and sort_by_size and sort_by_mtime:\n                sorted_files = sorted(\n                    files,\n                    key=lambda f: (\n                        -(f[2] if isinstance(f, tuple) and len(f) &gt; 2 else 0),\n                        -(f[3] if isinstance(f, tuple) and len(f) &gt; 3 else 0),\n                        -(f[4] if isinstance(f, tuple) and len(f) &gt; 4 else 0),\n                        f[0].lower() if isinstance(f, tuple) else f.lower(),\n                    ),\n                )\n            elif sort_by_loc and sort_by_size:\n                sorted_files = sorted(\n                    files,\n                    key=lambda f: (\n                        -(f[2] if isinstance(f, tuple) and len(f) &gt; 2 else 0),\n                        -(f[3] if isinstance(f, tuple) and len(f) &gt; 3 else 0),\n                        f[0].lower() if isinstance(f, tuple) else f.lower(),\n                    ),\n                )\n            elif sort_by_loc and sort_by_mtime:\n                sorted_files = sorted(\n                    files,\n                    key=lambda f: (\n                        -(f[2] if isinstance(f, tuple) and len(f) &gt; 2 else 0),\n                        -(\n                            f[4]\n                            if isinstance(f, tuple) and len(f) &gt; 4\n                            else (f[3] if isinstance(f, tuple) and len(f) &gt; 3 else 0)\n                        ),\n                        f[0].lower() if isinstance(f, tuple) else f.lower(),\n                    ),\n                )\n            elif sort_by_size and sort_by_mtime:\n                sorted_files = sorted(\n                    files,\n                    key=lambda f: (\n                        -(\n                            f[3]\n                            if isinstance(f, tuple) and len(f) &gt; 3\n                            else (f[2] if isinstance(f, tuple) and len(f) &gt; 2 else 0)\n                        ),\n                        -(\n                            f[4]\n                            if isinstance(f, tuple) and len(f) &gt; 4\n                            else (f[3] if isinstance(f, tuple) and len(f) &gt; 3 else 0)\n                        ),\n                        f[0].lower() if isinstance(f, tuple) else f.lower(),\n                    ),\n                )\n            elif sort_by_mtime:\n                sorted_files = sorted(\n                    files,\n                    key=lambda f: (\n                        -(\n                            f[4]\n                            if isinstance(f, tuple) and len(f) &gt; 4\n                            else (\n                                f[3]\n                                if isinstance(f, tuple) and len(f) &gt; 3\n                                else (\n                                    f[2] if isinstance(f, tuple) and len(f) &gt; 2 else 0\n                                )\n                            )\n                        ),\n                        f[0].lower() if isinstance(f, tuple) else f.lower(),\n                    ),\n                )\n            elif sort_by_size:\n                sorted_files = sorted(\n                    files,\n                    key=lambda f: (\n                        -(\n                            f[3]\n                            if isinstance(f, tuple) and len(f) &gt; 3\n                            else (f[2] if isinstance(f, tuple) and len(f) &gt; 2 else 0)\n                        ),\n                        f[0].lower() if isinstance(f, tuple) else f.lower(),\n                    ),\n                )\n            elif sort_by_loc:\n                sorted_files = sorted(\n                    files,\n                    key=lambda f: (\n                        -(f[2] if isinstance(f, tuple) and len(f) &gt; 2 else 0),\n                        f[0].lower() if isinstance(f, tuple) else f.lower(),\n                    ),\n                )\n            else:\n                sorted_files = sorted(\n                    files,\n                    key=lambda f: f[0].lower() if isinstance(f, tuple) else f.lower(),\n                )\n            for file_item in sorted_files:\n                if (\n                    sort_by_loc\n                    and sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 4\n                ):\n                    file_name, display_path, loc, size, mtime = file_item\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{html.escape(display_path)}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} \"\n                        f\"locCount={{{loc}}} \"\n                        f\"sizeCount={{{size}}} \"\n                        f\"mtimeCount={{{mtime}}} \"\n                        f'mtimeFormatted=\"{format_timestamp(mtime)}\" '\n                        f'sizeFormatted=\"{format_size(size)}\" /&gt;'\n                    )\n                elif (\n                    sort_by_loc\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    file_name, display_path, loc, mtime = file_item\n                    if len(file_item) &gt; 4:\n                        _, _, _, _, mtime = file_item\n\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{html.escape(display_path)}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} \"\n                        f\"locCount={{{loc}}} \"\n                        f\"mtimeCount={{{mtime}}} \"\n                        f'mtimeFormatted=\"{format_timestamp(mtime)}\" /&gt;'\n                    )\n                elif (\n                    sort_by_size\n                    and sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, size, mtime = file_item\n                    else:\n                        file_name, display_path, size, mtime = file_item\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{html.escape(display_path)}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} \"\n                        f\"sizeCount={{{size}}} \"\n                        f\"mtimeCount={{{mtime}}} \"\n                        f'mtimeFormatted=\"{format_timestamp(mtime)}\" '\n                        f'sizeFormatted=\"{format_size(size)}\" /&gt;'\n                    )\n                elif (\n                    sort_by_loc\n                    and sort_by_size\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 3\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, loc, size, _ = file_item\n                    else:\n                        file_name, display_path, loc, size = file_item\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{html.escape(display_path)}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} \"\n                        f\"locCount={{{loc}}} \"\n                        f\"sizeCount={{{size}}} \"\n                        f'sizeFormatted=\"{format_size(size)}\" /&gt;'\n                    )\n                elif (\n                    sort_by_mtime\n                    and isinstance(file_item, tuple)\n                    and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 4:\n                        file_name, display_path, _, _, mtime = file_item\n                    elif len(file_item) &gt; 3:\n                        file_name, display_path, _, mtime = file_item\n                    else:\n                        file_name, display_path, mtime = file_item\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{html.escape(display_path)}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} \"\n                        f\"mtimeCount={{{mtime}}} \"\n                        f'mtimeFormatted=\"{format_timestamp(mtime)}\" /&gt;'\n                    )\n                elif (\n                    sort_by_size and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 3:\n                        file_name, display_path, _, size = file_item\n                    else:\n                        file_name, display_path, size = file_item\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{html.escape(display_path)}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} \"\n                        f\"sizeCount={{{size}}} \"\n                        f'sizeFormatted=\"{format_size(size)}\" /&gt;'\n                    )\n                elif (\n                    sort_by_loc and isinstance(file_item, tuple) and len(file_item) &gt; 2\n                ):\n                    if len(file_item) &gt; 3:\n                        file_name, display_path, loc, _ = file_item\n                    else:\n                        file_name, display_path, loc = file_item\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{html.escape(display_path)}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} \"\n                        f\"locCount={{{loc}}} /&gt;\"\n                    )\n                elif isinstance(file_item, tuple):\n                    file_name, display_path = file_item\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{html.escape(display_path)}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} /&gt;\"\n                    )\n                else:\n                    file_name = file_item\n                    display_path = html.escape(file_name)\n                    if path_prefix:\n                        path_parts = path_prefix.split(\"/\")\n                        if path_parts and path_parts[0] == root_name:\n                            path_parts = [root_name] + [p for p in path_parts[1:] if p]\n                        else:\n                            path_parts = [p for p in path_parts if p]\n                            if not path_parts or path_parts[0] != root_name:\n                                path_parts = [root_name] + path_parts\n                    else:\n                        path_parts = [root_name]\n                    path_parts.append(file_name)\n                    path_json = \",\".join(\n                        [f'\"{html.escape(part)}\"' for part in path_parts if part]\n                    )\n                    jsx_content.append(\n                        f\"&lt;FileItem \"\n                        f'name=\"{html.escape(file_name)}\" '\n                        f'displayPath=\"{display_path}\" '\n                        f\"path={{[{path_json}]}} \"\n                        f\"level={{{level}}} /&gt;\"\n                    )\n        return \"\\n\".join(jsx_content)\n\n    combined_imports = \"\"\n    if sort_by_loc and sort_by_size and sort_by_mtime:\n        combined_imports = (\n            \"\"\"import { BarChart2, Database, Clock } from 'lucide-react';\"\"\"\n        )\n    elif sort_by_loc and sort_by_size:\n        combined_imports = \"\"\"import { BarChart2, Database } from 'lucide-react';\"\"\"\n    elif sort_by_loc and sort_by_mtime:\n        combined_imports = \"\"\"import { BarChart2, Clock } from 'lucide-react';\"\"\"\n    elif sort_by_size and sort_by_mtime:\n        combined_imports = \"\"\"import { Database, Clock } from 'lucide-react';\"\"\"\n    elif sort_by_loc:\n        combined_imports = \"\"\"import { BarChart2 } from 'lucide-react';\"\"\"\n    elif sort_by_size:\n        combined_imports = \"\"\"import { Database } from 'lucide-react';\"\"\"\n    elif sort_by_mtime:\n        combined_imports = \"\"\"import { Clock } from 'lucide-react';\"\"\"\n    loc_state = (\n        \"\"\"const showLoc = true;\"\"\" if sort_by_loc else \"\"\"const showLoc = false;\"\"\"\n    )\n    size_state = (\n        \"\"\"const showSize = true;\"\"\" if sort_by_size else \"\"\"const showSize = false;\"\"\"\n    )\n    mtime_state = (\n        \"\"\"const showMtime = true;\"\"\"\n        if sort_by_mtime\n        else \"\"\"const showMtime = false;\"\"\"\n    )\n    loc_sort_state = (\n        \"\"\"const sortByLoc = true;\"\"\" if sort_by_loc else \"\"\"const sortByLoc = false;\"\"\"\n    )\n    size_sort_state = (\n        \"\"\"const sortBySize = true;\"\"\"\n        if sort_by_size\n        else \"\"\"const sortBySize = false;\"\"\"\n    )\n    mtime_sort_state = (\n        \"\"\"const sortByMtime = true;\"\"\"\n        if sort_by_mtime\n        else \"\"\"const sortByMtime = false;\"\"\"\n    )\n    loc_toggle_function = \"\"\n    size_toggle_function = \"\"\n    mtime_toggle_function = \"\"\n    loc_toggle_button = \"\"\n    size_toggle_button = \"\"\n    mtime_toggle_button = \"\"\n    root_loc_prop = \"\"\n    root_size_prop = \"\"\n    root_mtime_prop = \"\"\n    if sort_by_loc and \"_loc\" in structure:\n        root_loc_prop = f\" locCount={{{structure['_loc']}}}\"\n    if sort_by_size and \"_size\" in structure:\n        root_size_prop = f\" sizeCount={{{structure['_size']}}}\"\n    if sort_by_mtime and \"_mtime\" in structure:\n        root_mtime_prop = f\" mtimeCount={{{structure['_mtime']}}}\"\n    format_size_function = \"\"\n    if sort_by_size:\n        format_size_function = \"\"\"\n  const format_size = (size_in_bytes) =&gt; {\n    if (size_in_bytes &lt; 1024) {\n      return `${size_in_bytes} B`;\n    } else if (size_in_bytes &lt; 1024 * 1024) {\n      return `${(size_in_bytes / 1024).toFixed(1)} KB`;\n    } else if (size_in_bytes &lt; 1024 * 1024 * 1024) {\n      return `${(size_in_bytes / (1024 * 1024)).toFixed(1)} MB`;\n    } else {\n      return `${(size_in_bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;\n    }\n  };\"\"\"\n    format_timestamp_function = \"\"\n    if sort_by_mtime:\n        format_timestamp_function = \"\"\"\n  const format_timestamp = (timestamp) =&gt; {\n    const dt = new Date(timestamp * 1000);\n    const now = new Date();\n    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n    const yesterday = new Date(today);\n    yesterday.setDate(yesterday.getDate() - 1);\n    if (dt &gt;= today) {\n      return `Today ${dt.getHours().toString().padStart(2, '0')}:${dt.getMinutes().toString().padStart(2, '0')}`;\n    }\n    else if (dt &gt;= yesterday) {\n      return `Yesterday ${dt.getHours().toString().padStart(2, '0')}:${dt.getMinutes().toString().padStart(2, '0')}`;\n    }\n    else if ((today - dt) / (1000 * 60 * 60 * 24) &lt; 7) {\n      const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n      return `${days[dt.getDay()]} ${dt.getHours().toString().padStart(2, '0')}:${dt.getMinutes().toString().padStart(2, '0')}`;\n    }\n    else if (dt.getFullYear() === now.getFullYear()) {\n      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n      return `${months[dt.getMonth()]} ${dt.getDate()}`;\n    }\n    else {\n      return `${dt.getFullYear()}-${(dt.getMonth() + 1).toString().padStart(2, '0')}-${dt.getDate().toString().padStart(2, '0')}`;\n    }\n  };\"\"\"\n    component_template = f\"\"\"import React, {{ useState, useEffect, useRef }} from 'react';\n    import PropTypes from 'prop-types';\n    import {{ ChevronDown, ChevronUp, Folder, FolderOpen, File, Maximize2, Minimize2, Search, X, Info, Home, ChevronRight, Copy, Check }} from 'lucide-react';\n    {combined_imports}\n    const AppContext = React.createContext();\n    const highlightMatch = (text, searchTerm) =&gt; {{\n      if (!searchTerm) return text;\n      const parts = text.split(new RegExp(`(${{searchTerm}})`, 'gi'));\n      return (\n        &lt;&gt;\n          {{parts.map((part, i) =&gt;\n            part.toLowerCase() === searchTerm.toLowerCase()\n              ? &lt;mark key={{i}} className=\"bg-yellow-200 px-1 rounded\"&gt;{{part}}&lt;/mark&gt;\n              : part\n          )}}\n        &lt;/&gt;\n      );\n    }};\n    const Breadcrumbs = () =&gt; {{\n      const {{\n        currentPath,\n        setCurrentPath,\n        selectedItem,\n        darkMode\n      }} = React.useContext(AppContext);\n      const [copied, setCopied] = useState(false);\n      const breadcrumbRef = useRef(null);\n      const copyPath = () =&gt; {{\n        let path = currentPath.join('/');\n        if (selectedItem) {{\n          path = [...currentPath, selectedItem.name].join('/');\n        }}\n        navigator.clipboard.writeText(path).then(() =&gt; {{\n          setCopied(true);\n          setTimeout(() =&gt; setCopied(false), 2000);\n        }});\n      }};\n      const navigateTo = (index) =&gt; {{\n        setCurrentPath(currentPath.slice(0, index + 1));\n      }};\n      useEffect(() =&gt; {{\n        if (breadcrumbRef.current) {{\n          breadcrumbRef.current.scrollLeft = breadcrumbRef.current.scrollWidth;\n        }}\n      }}, [currentPath, selectedItem]);\n      return (\n        &lt;div className={{`sticky top-0 left-0 right-0 ${{darkMode ? 'bg-gray-800 text-white' : 'bg-white text-gray-800'}} p-3 shadow-md z-50 overflow-visible`}}&gt;\n          &lt;div className=\"container mx-auto max-w-5xl flex items-center justify-between\"&gt;\n            &lt;div\n              ref={{breadcrumbRef}}\n              className=\"overflow-x-auto whitespace-nowrap flex items-center flex-grow mr-2\"\n              style={{{{ overflowX: 'auto' }}}}\n            &gt;\n              &lt;button\n                onClick={{() =&gt; navigateTo(0)}}\n                className={{`${{darkMode ? 'text-blue-400 hover:text-blue-300' : 'text-blue-600 hover:text-blue-800'}} flex items-center mr-1 flex-shrink-0`}}\n                title=\"Home directory\"\n              &gt;\n                &lt;Home className=\"w-4 h-4 mr-1\" /&gt;\n                &lt;span className=\"font-medium\"&gt;{{currentPath[0]}}&lt;/span&gt;\n              &lt;/button&gt;\n              {{currentPath.length &gt; 1 &amp;&amp; currentPath.slice(1).map((segment, index) =&gt; (\n                &lt;React.Fragment key={{index}}&gt;\n                  &lt;ChevronRight className={{`w-4 h-4 mx-1 ${{darkMode ? 'text-gray-500' : 'text-gray-400'}} flex-shrink-0`}} /&gt;\n                  &lt;button\n                    onClick={{() =&gt; navigateTo(index + 1)}}\n                    className={{`${{\n                      index === currentPath.length - 2 &amp;&amp; !selectedItem ?\n                        (darkMode ? 'text-yellow-300 font-medium' : 'text-blue-700 font-medium') :\n                        (darkMode ? 'text-blue-400 hover:text-blue-300' : 'text-blue-600 hover:text-blue-800')\n                    }} flex-shrink-0`}}\n                  &gt;\n                    {{segment}}\n                  &lt;/button&gt;\n                &lt;/React.Fragment&gt;\n              ))}}\n              {{selectedItem &amp;&amp; (\n                &lt;&gt;\n                  &lt;ChevronRight className={{`w-4 h-4 mx-1 ${{darkMode ? 'text-gray-500' : 'text-gray-400'}} flex-shrink-0`}} /&gt;\n                  &lt;span className={{`${{darkMode ? 'text-yellow-300 font-medium' : 'text-blue-700 font-medium'}} flex-shrink-0`}}&gt;\n                    {{selectedItem.name}}\n                  &lt;/span&gt;\n                &lt;/&gt;\n              )}}\n            &lt;/div&gt;\n            &lt;div className=\"flex items-center space-x-2 flex-shrink-0\"&gt;\n              {{copied ? (\n                &lt;span className={{`text-xs px-2 py-1 rounded ${{darkMode ? 'bg-green-800 text-green-200' : 'bg-green-100 text-green-800'}}`}}&gt;\n                  &lt;Check className=\"w-3 h-3 inline mr-1\" /&gt;\n                  Copied\n                &lt;/span&gt;\n              ) : (\n                &lt;button\n                  onClick={{copyPath}}\n                  className={{`p-1 rounded ${{darkMode ? 'hover:bg-gray-700' : 'hover:bg-gray-100'}}`}}\n                  title=\"Copy path\"\n                &gt;\n                  &lt;Copy className=\"w-4 h-4\" /&gt;\n                &lt;/button&gt;\n              )}}\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      );\n    }};\n    const DirectoryItem = (props) =&gt; {{\n      const {{\n        openFolders,\n        setOpenFolders,\n        searchTerm,\n        darkMode,\n        expandAll,\n        collapseAll,\n        setCurrentPath,\n        currentPath,\n        setSelectedItem,\n        showLoc,\n        showSize,\n        showMtime,\n        format_size,\n        format_timestamp\n      }} = React.useContext(AppContext);\n      const {{ name, children, level = 0, path = [] }} = props;\n      const folderId = path.join('/');\n      const isOpen = openFolders.has(folderId);\n      const isCurrentPath = currentPath.length === path.length &amp;&amp;\n        path.every((segment, index) =&gt; segment === currentPath[index]);\n      const isInCurrentPath = currentPath.length &gt; path.length &amp;&amp;\n        path.every((segment, index) =&gt; segment === currentPath[index]);\n      const matchesSearch = searchTerm &amp;&amp; name.toLowerCase().includes(searchTerm.toLowerCase());\n      const toggleFolder = (e) =&gt; {{\n        e.stopPropagation();\n        const newOpenFolders = new Set(openFolders);\n        if (isOpen) {{\n          newOpenFolders.delete(folderId);\n        }} else {{\n          newOpenFolders.add(folderId);\n        }}\n        setOpenFolders(newOpenFolders);\n      }};\n      const navigateToFolder = (e) =&gt; {{\n        e.stopPropagation();\n        setCurrentPath(path);\n        setSelectedItem(null);\n      }};\n      useEffect(() =&gt; {{\n        if (expandAll) {{\n          setOpenFolders(prev =&gt; new Set([...prev, folderId]));\n        }}\n      }}, [expandAll, folderId, setOpenFolders]);\n      useEffect(() =&gt; {{\n        if (collapseAll &amp;&amp; folderId !== '{html.escape(root_name)}') {{\n          setOpenFolders(prev =&gt; {{\n            const newFolders = new Set(prev);\n            newFolders.delete(folderId);\n            return newFolders;\n          }});\n        }}\n      }}, [collapseAll, folderId, setOpenFolders]);\n      useEffect(() =&gt; {{\n        if (searchTerm &amp;&amp; matchesSearch) {{\n          setOpenFolders(prev =&gt; new Set([...prev, folderId]));\n        }}\n      }}, [searchTerm, matchesSearch, folderId, setOpenFolders]);\n      useEffect(() =&gt; {{\n        if (isCurrentPath || isInCurrentPath) {{\n          setOpenFolders(prev =&gt; new Set([...prev, folderId]));\n        }}\n      }}, [isCurrentPath, isInCurrentPath, folderId, setOpenFolders]);\n      const indentClass = level === 0 ? '' : 'ml-4';\n      const currentPathClass = isCurrentPath\n        ? darkMode\n          ? 'bg-blue-900 hover:bg-blue-800'\n          : 'bg-blue-100 hover:bg-blue-200'\n        : isInCurrentPath\n          ? darkMode\n            ? 'bg-blue-800/50 hover:bg-blue-800'\n            : 'bg-blue-50 hover:bg-blue-100'\n          : darkMode\n            ? 'bg-gray-800 hover:bg-gray-700'\n            : 'bg-gray-50 hover:bg-gray-100';\n      const searchMatchClass = matchesSearch\n        ? darkMode\n          ? 'ring-1 ring-yellow-500'\n          : 'ring-1 ring-yellow-300'\n        : '';\n      return (\n        &lt;div className={{`w-full ${{indentClass}}`}} data-folder={{folderId}}&gt;\n          &lt;div className={{`flex items-center justify-between p-2 mb-1 rounded-lg ${{currentPathClass}} ${{searchMatchClass}}`}}&gt;\n            &lt;div className=\"flex items-center flex-grow cursor-pointer\" onClick={{navigateToFolder}}&gt;\n              {{isOpen\n                ? &lt;FolderOpen className={{`w-5 h-5 mr-2 ${{isCurrentPath ? (darkMode ? 'text-yellow-300' : 'text-blue-600') : darkMode ? 'text-blue-400' : 'text-blue-500'}}`}} /&gt;\n                : &lt;Folder className={{`w-5 h-5 mr-2 ${{isCurrentPath ? (darkMode ? 'text-yellow-300' : 'text-blue-600') : darkMode ? 'text-blue-400' : 'text-blue-500'}}`}} /&gt;\n              }}\n              &lt;span className={{`font-medium truncate ${{isCurrentPath ? (darkMode ? 'text-yellow-300' : 'text-blue-700') : ''}}`}}&gt;\n                {{searchTerm ? highlightMatch(name, searchTerm) : name}}\n              &lt;/span&gt;\n              {{props.locCount !== undefined &amp;&amp; showLoc &amp;&amp; (\n                &lt;span className={{`ml-2 text-xs px-1.5 py-0.5 rounded-full ${{isCurrentPath ?\n                  (darkMode ? 'bg-blue-800 text-blue-200' : 'bg-blue-200 text-blue-700') :\n                  (darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700')}}`}}&gt;\n                  {{props.locCount}} lines\n                &lt;/span&gt;\n              )}}\n              {{props.sizeCount !== undefined &amp;&amp; showSize &amp;&amp; (\n                &lt;span className={{`ml-2 text-xs px-1.5 py-0.5 rounded-full ${{isCurrentPath ?\n                  (darkMode ? 'bg-teal-800 text-teal-200' : 'bg-teal-200 text-teal-700') :\n                  (darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700')}}`}}&gt;\n                  {{format_size(props.sizeCount)}}\n                &lt;/span&gt;\n              )}}\n              {{props.mtimeCount !== undefined &amp;&amp; showMtime &amp;&amp; (\n                &lt;span className={{`ml-2 text-xs px-1.5 py-0.5 rounded-full ${{isCurrentPath ?\n                  (darkMode ? 'bg-purple-800 text-purple-200' : 'bg-purple-200 text-purple-700') :\n                  (darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700')}}`}}&gt;\n                  {{format_timestamp(props.mtimeCount)}}\n                &lt;/span&gt;\n              )}}\n            &lt;/div&gt;\n            &lt;button\n              className={{`p-1 rounded-full ${{darkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-200'}}`}}\n              onClick={{toggleFolder}}\n              data-testid=\"folder-toggle\"\n            &gt;\n              {{isOpen ? (\n                &lt;ChevronUp className=\"w-4 h-4\" /&gt;\n              ) : (\n                &lt;ChevronDown className=\"w-4 h-4\" /&gt;\n              )}}\n            &lt;/button&gt;\n          &lt;/div&gt;\n          {{isOpen &amp;&amp; (\n            &lt;div className=\"py-1\"&gt;\n              {{children}}\n            &lt;/div&gt;\n          )}}\n        &lt;/div&gt;\n      );\n    }};\n    const FileItem = (props) =&gt; {{\n      const {{\n        searchTerm,\n        darkMode,\n        currentPath,\n        setCurrentPath,\n        selectedItem,\n        setSelectedItem,\n        showLoc,\n        showSize,\n        showMtime\n      }} = React.useContext(AppContext);\n      const {{ name, displayPath, path = [] }} = props;\n      useEffect(() =&gt; {{\n      }}, [currentPath, path]);\n      const matchesSearch = searchTerm &amp;&amp; name.toLowerCase().includes(searchTerm.toLowerCase());\n      const isSelected = selectedItem &amp;&amp;\n        selectedItem.path &amp;&amp;\n        selectedItem.path.length === path.length &amp;&amp;\n        selectedItem.path.every((segment, index) =&gt; segment === path[index]);\n      const handleFileSelect = () =&gt; {{\n        setCurrentPath(path.slice(0, -1));\n        setSelectedItem({{\n          type: 'file',\n          name,\n          displayPath,\n          path\n        }});\n      }};\n      const indentClass = 'ml-4';\n      const selectedClass = isSelected\n        ? darkMode\n          ? 'bg-blue-900 hover:bg-blue-800'\n          : 'bg-blue-100 hover:bg-blue-200'\n        : darkMode\n          ? 'bg-gray-800 hover:bg-gray-700'\n          : 'bg-white hover:bg-gray-50';\n      const searchMatchClass = matchesSearch\n        ? darkMode\n          ? 'ring-1 ring-yellow-500'\n          : 'ring-1 ring-yellow-300'\n        : '';\n      return (\n        &lt;div className={{`w-full ${{indentClass}}`}}&gt;\n          &lt;div\n            className={{`flex items-center p-2 rounded-lg border cursor-pointer ${{selectedClass}} ${{searchMatchClass}} ${{darkMode ? 'border-gray-700' : 'border-gray-100'}} my-1`}}\n            onClick={{handleFileSelect}}\n          &gt;\n            &lt;File className={{`w-5 h-5 mr-2 ${{isSelected ? (darkMode ? 'text-yellow-300' : 'text-blue-600') : darkMode ? 'text-blue-400/70' : 'text-blue-400'}}`}} /&gt;\n            &lt;div className=\"min-w-0 overflow-hidden\"&gt;\n              &lt;span className={{`truncate block ${{isSelected ? (darkMode ? 'text-yellow-300 font-medium' : 'text-blue-700 font-medium') : ''}}`}}&gt;\n                {{searchTerm ? highlightMatch(displayPath, searchTerm) : displayPath}}\n              &lt;/span&gt;\n              {{props.locCount !== undefined &amp;&amp; showLoc &amp;&amp; (\n                &lt;span className={{`ml-2 text-xs px-1.5 py-0.5 rounded-full ${{isSelected ?\n                  (darkMode ? 'bg-blue-800 text-blue-200' : 'bg-blue-200 text-blue-700') :\n                  (darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700')}}`}}&gt;\n                  {{props.locCount}} lines\n                &lt;/span&gt;\n              )}}\n              {{props.sizeCount !== undefined &amp;&amp; showSize &amp;&amp; (\n                &lt;span className={{`ml-2 text-xs px-1.5 py-0.5 rounded-full ${{isSelected ?\n                  (darkMode ? 'bg-teal-800 text-teal-200' : 'bg-teal-200 text-teal-700') :\n                  (darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700')}}`}}&gt;\n                  {{props.sizeFormatted}}\n                &lt;/span&gt;\n              )}}\n              {{props.mtimeCount !== undefined &amp;&amp; showMtime &amp;&amp; (\n                &lt;span className={{`ml-2 text-xs px-1.5 py-0.5 rounded-full ${{isSelected ?\n                  (darkMode ? 'bg-purple-800 text-purple-200' : 'bg-purple-200 text-purple-700') :\n                  (darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-200 text-gray-700')}}`}}&gt;\n                  {{props.mtimeFormatted}}\n                &lt;/span&gt;\n              )}}\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      );\n    }};\n    const SearchBar = () =&gt; {{\n      const {{ searchTerm, setSearchTerm, darkMode }} = React.useContext(AppContext);\n      return (\n        &lt;div className=\"relative mb-4\"&gt;\n          &lt;div className={{`flex items-center border rounded-lg overflow-hidden ${{\n            darkMode ? 'bg-gray-700 border-gray-600' : 'bg-white border-gray-300'\n          }}`}}&gt;\n            &lt;div className=\"p-2\"&gt;\n              &lt;Search className={{`w-5 h-5 ${{darkMode ? 'text-gray-400' : 'text-gray-500'}}`}} /&gt;\n            &lt;/div&gt;\n            &lt;input\n              type=\"text\"\n              value={{searchTerm}}\n              onChange={{(e) =&gt; setSearchTerm(e.target.value)}}\n              placeholder=\"Search files and folders...\"\n              className={{`flex-grow p-2 outline-none ${{\n                darkMode ? 'bg-gray-700 text-white placeholder-gray-400' : 'bg-white text-gray-800 placeholder-gray-400'\n              }}`}}\n            /&gt;\n            {{searchTerm &amp;&amp; (\n              &lt;button\n                onClick={{() =&gt; setSearchTerm('')}}\n                className={{`p-2 ${{darkMode ? 'hover:bg-gray-600' : 'hover:bg-gray-100'}}`}}\n              &gt;\n                &lt;X className={{`w-4 h-4 ${{darkMode ? 'text-gray-400' : 'text-gray-500'}}`}} /&gt;\n              &lt;/button&gt;\n            )}}\n          &lt;/div&gt;\n        &lt;/div&gt;\n      );\n    }};\n    const DirectoryViewer = () =&gt; {{\n      const [openFolders, setOpenFolders] = useState(new Set(['{html.escape(root_name)}']));\n      const [searchTerm, setSearchTerm] = useState('');\n      const [darkMode, setDarkMode] = useState(false);\n      const [currentPath, setCurrentPath] = useState(['{html.escape(root_name)}']);\n      const [selectedItem, setSelectedItem] = useState(null);\n      const [expandAll, setExpandAll] = useState(false);\n      const [collapseAll, setCollapseAll] = useState(false);\n      {loc_state}\n      {loc_sort_state}\n      {size_state}\n      {size_sort_state}\n      {mtime_state}\n      {mtime_sort_state}\n      const handleExpandAll = () =&gt; {{\n        setExpandAll(true);\n        setTimeout(() =&gt; setExpandAll(false), 100);\n      }};\n      const handleCollapseAll = () =&gt; {{\n        setCollapseAll(true);\n        setTimeout(() =&gt; setCollapseAll(false), 100);\n      }};\n      const toggleDarkMode = () =&gt; {{\n        setDarkMode(!darkMode);\n      }};\n      {loc_toggle_function}\n      {size_toggle_function}\n      {mtime_toggle_function}\n      {format_size_function if format_size_function else '''\n  const format_size = () =&gt; {\n    return '0 B';\n  };'''}\n\n      {format_timestamp_function if format_timestamp_function else '''\n  const format_timestamp = () =&gt; {\n    return '';\n  };'''}\n\n      useEffect(() =&gt; {{\n        if (darkMode) {{\n          document.body.classList.add('dark-mode');\n        }} else {{\n          document.body.classList.remove('dark-mode');\n        }}\n      }}, [darkMode]);\n      return (\n        &lt;AppContext.Provider value={{{{\n          openFolders,\n          setOpenFolders,\n          searchTerm,\n          setSearchTerm,\n          darkMode,\n          expandAll,\n          collapseAll,\n          currentPath,\n          setCurrentPath,\n          selectedItem,\n          setSelectedItem,\n          showLoc,\n          sortByLoc,\n          showSize,\n          sortBySize,\n          showMtime,\n          sortByMtime,\n          format_size,\n          format_timestamp\n        }}}}&gt;\n          &lt;div className={{`min-h-screen ${{darkMode ? 'bg-gray-900 text-gray-100' : 'bg-gray-50 text-gray-900'}}`}}&gt;\n            &lt;style&gt;{{`\n              body.dark-mode {{\n                background-color: rgb(17, 24, 39);\n                color: rgb(243, 244, 246);\n              }}\n              .overflow-x-auto {{\n                overflow-x: auto;\n                white-space: nowrap;\n              }}\n            `}}&lt;/style&gt;\n            &lt;Breadcrumbs /&gt;\n            &lt;div className=\"container mx-auto max-w-5xl p-4\"&gt;\n              &lt;div className=\"flex flex-col sm:flex-row sm:justify-between sm:items-center mb-6\"&gt;\n                &lt;div&gt;\n                  &lt;h1 className=\"text-xl font-bold flex items-center\"&gt;\n                    &lt;FolderOpen className={{`w-6 h-6 mr-2 ${{darkMode ? 'text-blue-400' : 'text-blue-500'}}`}} /&gt;\n                    Directory Structure: {html.escape(root_name)}\n                  &lt;/h1&gt;\n                  &lt;p className={{`mt-1 text-sm ${{darkMode ? 'text-gray-400' : 'text-gray-500'}}`}}&gt;\n                    Explore and navigate through the directory structure\n                  &lt;/p&gt;\n                &lt;/div&gt;\n                &lt;div className=\"flex mt-4 sm:mt-0 space-x-2\"&gt;\n                  &lt;button\n                    onClick={{handleExpandAll}}\n                    className={{`flex items-center px-3 py-1.5 text-sm rounded-md ${{\n                      darkMode ? 'bg-gray-800 hover:bg-gray-700 text-blue-400' : 'bg-blue-100 hover:bg-blue-200 text-blue-700'\n                    }}`}}\n                  &gt;\n                    &lt;Maximize2 className=\"w-4 h-4 mr-1\" /&gt;\n                    &lt;span className=\"hidden sm:inline\"&gt;Expand All&lt;/span&gt;\n                  &lt;/button&gt;\n                  &lt;button\n                    onClick={{handleCollapseAll}}\n                    className={{`flex items-center px-3 py-1.5 text-sm rounded-md ${{\n                      darkMode ? 'bg-gray-800 hover:bg-gray-700' : 'bg-gray-200 hover:bg-gray-300'\n                    }}`}}\n                  &gt;\n                    &lt;Minimize2 className=\"w-4 h-4 mr-1\" /&gt;\n                    &lt;span className=\"hidden sm:inline\"&gt;Collapse All&lt;/span&gt;\n                  &lt;/button&gt;{loc_toggle_button}{size_toggle_button}{mtime_toggle_button}\n                  &lt;button\n                    onClick={{toggleDarkMode}}\n                    className={{`px-3 py-1.5 text-sm rounded-md ${{\n                      darkMode ? 'bg-gray-800 hover:bg-gray-700' : 'bg-gray-200 hover:bg-gray-300'\n                    }}`}}\n                  &gt;\n                    {{darkMode ? 'Light' : 'Dark'}}\n                  &lt;/button&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n              &lt;SearchBar /&gt;\n              &lt;div className={{`p-4 rounded-lg shadow ${{darkMode ? 'bg-gray-800' : 'bg-white'}}`}}&gt;\n                &lt;DirectoryItem\n                  name=\"{html.escape(root_name)}\"\n                  level={{0}}\n                  path={{[\"{html.escape(root_name)}\"]}}{root_loc_prop}{root_size_prop}{root_mtime_prop}\n                &gt;\n    {_build_structure_jsx(structure, 1, root_name if show_full_path else \"\")}\n                &lt;/DirectoryItem&gt;\n                {{/* Empty state for search */}}\n                {{searchTerm &amp;&amp; openFolders.size &lt;= 1 &amp;&amp; (\n                  &lt;div className=\"py-8 text-center\"&gt;\n                    &lt;Info className={{`w-12 h-12 mx-auto mb-3 ${{darkMode ? 'text-gray-600' : 'text-gray-300'}}`}} /&gt;\n                    &lt;h3 className=\"text-lg font-medium\"&gt;No matching files or folders&lt;/h3&gt;\n                    &lt;p className={{`mt-1 text-sm ${{darkMode ? 'text-gray-400' : 'text-gray-500'}}`}}&gt;\n                      Try a different search term or check spelling\n                    &lt;/p&gt;\n                  &lt;/div&gt;\n                )}}\n              &lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n        &lt;/AppContext.Provider&gt;\n      );\n    }};\n    DirectoryItem.propTypes = {{\n      name: PropTypes.string.isRequired,\n      children: PropTypes.node,\n      level: PropTypes.number,\n      path: PropTypes.arrayOf(PropTypes.string),\n      locCount: PropTypes.number,\n      sizeCount: PropTypes.number,\n      mtimeCount: PropTypes.number\n    }};\n    FileItem.propTypes = {{\n      name: PropTypes.string.isRequired,\n      displayPath: PropTypes.string.isRequired,\n      path: PropTypes.arrayOf(PropTypes.string),\n      level: PropTypes.number,\n      locCount: PropTypes.number,\n      sizeCount: PropTypes.number,\n      sizeFormatted: PropTypes.string,\n      mtimeCount: PropTypes.number,\n      mtimeFormatted: PropTypes.string\n    }};\n    export default DirectoryViewer;\n    \"\"\"\n    try:\n        with open(output_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(component_template)\n    except Exception as e:\n        logger.error(f\"Error exporting to React component: {e}\")\n        raise\n</code></pre>"},{"location":"reference/api-reference/#using-the-python-api-in-custom-scripts","title":"Using the Python API in Custom Scripts","text":"<p>Here's an example of how to use the Python API to create a custom directory analysis script:</p> <pre><code>import sys\nfrom recursivist.core import get_directory_structure\nfrom recursivist.core import export_structure\n\ndef analyze_directory(directory_path):\n    # Get directory structure with line counts and file sizes\n    structure, extensions = get_directory_structure(\n        directory_path,\n        exclude_dirs=[\"node_modules\", \".git\", \"venv\"],\n        exclude_extensions={\".pyc\", \".log\", \".tmp\"},\n        sort_by_loc=True,\n        sort_by_size=True\n    )\n\n    # Export to multiple formats\n    export_structure(structure, directory_path, \"md\", \"analysis.md\", sort_by_loc=True, sort_by_size=True)\n    export_structure(structure, directory_path, \"json\", \"analysis.json\", sort_by_loc=True, sort_by_size=True)\n\n    # Calculate some statistics\n    total_loc = structure.get(\"_loc\", 0)\n    total_size = structure.get(\"_size\", 0)\n\n    print(f\"Directory: {directory_path}\")\n    print(f\"Total lines of code: {total_loc}\")\n    print(f\"Total size: {total_size} bytes\")\n\n    # Find the files with the most lines of code\n    def collect_files(structure, path=\"\"):\n        files = []\n        for name, content in structure.items():\n            if name == \"_files\":\n                for file_item in content:\n                    if isinstance(file_item, tuple) and len(file_item) &gt; 2:\n                        file_name, full_path, loc = file_item[0], file_item[1], file_item[2]\n                        files.append((file_name, full_path, loc))\n            elif isinstance(content, dict) and name not in [\"_max_depth_reached\", \"_loc\", \"_size\", \"_mtime\"]:\n                files.extend(collect_files(content, f\"{path}/{name}\"))\n        return files\n\n    files = collect_files(structure)\n    files.sort(key=lambda x: x[2], reverse=True)\n\n    print(\"\\nTop 5 files by lines of code:\")\n    for i, (name, path, loc) in enumerate(files[:5], 1):\n        print(f\"{i}. {path} ({loc} lines)\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) &gt; 1:\n        analyze_directory(sys.argv[1])\n    else:\n        analyze_directory(\".\")\n</code></pre>"},{"location":"reference/api-reference/#api-extension-points","title":"API Extension Points","text":"<p>If you're looking to extend Recursivist's functionality, these are the main extension points:</p> <ol> <li>Custom Pattern Matching: Extend the <code>should_exclude</code> function in <code>core.py</code></li> <li>New Export Format: Add a new method to the <code>DirectoryExporter</code> class in <code>exports.py</code></li> <li>Custom Visualization: Modify the <code>build_tree</code> and <code>display_tree</code> functions in <code>core.py</code></li> <li>Custom Statistics: Add new statistics collection to the <code>get_directory_structure</code> function</li> </ol> <p>The API is designed to be modular, making it possible to reuse individual components for custom functionality while maintaining consistent behavior across the library.</p>"},{"location":"reference/cli-reference/","title":"CLI Reference","text":"<p>This page provides a complete reference for all Recursivist commands and options.</p>"},{"location":"reference/cli-reference/#command-overview","title":"Command Overview","text":"<p>Recursivist provides several commands for visualizing and exporting directory structures:</p> Command Description <code>visualize</code> Display directory structures in the terminal <code>export</code> Export directory structures to various formats <code>compare</code> Compare two directory structures side by side <code>completion</code> Generate shell completion scripts <code>version</code> Show the current version"},{"location":"reference/cli-reference/#global-options","title":"Global Options","text":"<p>The following options apply to most Recursivist commands:</p> Option Short Description <code>--exclude</code> <code>-e</code> Directories to exclude (space-separated or multiple flags) <code>--exclude-ext</code> <code>-x</code> File extensions to exclude (space-separated or multiple flags) <code>--exclude-pattern</code> <code>-p</code> Patterns to exclude (glob by default, regex with --regex flag) <code>--include-pattern</code> <code>-i</code> Patterns to include (overrides exclusions) <code>--regex</code> <code>-r</code> Treat patterns as regex instead of glob patterns <code>--ignore-file</code> <code>-g</code> Ignore file to use (e.g., .gitignore) <code>--depth</code> <code>-d</code> Maximum depth to display (0 for unlimited) <code>--full-path</code> <code>-l</code> Show full paths instead of just filenames <code>--sort-by-loc</code> <code>-s</code> Sort files by lines of code and display LOC counts <code>--sort-by-size</code> <code>-z</code> Sort files by size and display file sizes <code>--sort-by-mtime</code> <code>-m</code> Sort files by modification time and display timestamps <code>--verbose</code> <code>-v</code> Enable verbose output"},{"location":"reference/cli-reference/#visualize-command","title":"<code>visualize</code> Command","text":"<p>The <code>visualize</code> command displays a directory structure in the terminal.</p>"},{"location":"reference/cli-reference/#usage","title":"Usage","text":"<pre><code>recursivist visualize [OPTIONS] [DIRECTORY]\n</code></pre>"},{"location":"reference/cli-reference/#arguments","title":"Arguments","text":"Argument Description <code>DIRECTORY</code> Directory path to visualize (defaults to current directory)"},{"location":"reference/cli-reference/#options","title":"Options","text":"Option Short Description <code>--exclude</code> <code>-e</code> Directories to exclude (space-separated or multiple flags) <code>--exclude-ext</code> <code>-x</code> File extensions to exclude (space-separated or multiple flags) <code>--exclude-pattern</code> <code>-p</code> Patterns to exclude (glob by default, regex with --regex flag) <code>--include-pattern</code> <code>-i</code> Patterns to include (overrides exclusions) <code>--regex</code> <code>-r</code> Treat patterns as regex instead of glob patterns <code>--ignore-file</code> <code>-g</code> Ignore file to use (e.g., .gitignore) <code>--depth</code> <code>-d</code> Maximum depth to display (0 for unlimited) <code>--full-path</code> <code>-l</code> Show full paths instead of just filenames <code>--sort-by-loc</code> <code>-s</code> Sort files by lines of code and display LOC counts <code>--sort-by-size</code> <code>-z</code> Sort files by size and display file sizes <code>--sort-by-mtime</code> <code>-m</code> Sort files by modification time and display timestamps <code>--verbose</code> <code>-v</code> Enable verbose output"},{"location":"reference/cli-reference/#examples","title":"Examples","text":"<pre><code># Visualize current directory\nrecursivist visualize\n\n# Visualize specific directory\nrecursivist visualize /path/to/directory\n\n# Exclude directories\nrecursivist visualize --exclude \"node_modules .git venv\"\n\n# Exclude file extensions\nrecursivist visualize --exclude-ext \".pyc .log .cache\"\n\n# Use a gitignore-style file\nrecursivist visualize --ignore-file .gitignore\n\n# Use glob patterns\nrecursivist visualize --exclude-pattern \"*.test.js\" \"*.spec.js\"\n\n# Use regex patterns\nrecursivist visualize --exclude-pattern \"^test_.*\\.py$\" \".*_test\\.js$\" --regex\n\n# Include only specific patterns\nrecursivist visualize --include-pattern \"src/*\" \"*.md\"\n\n# Limit directory depth\nrecursivist visualize --depth 3\n\n# Show full file paths\nrecursivist visualize --full-path\n\n# Show lines of code\nrecursivist visualize --sort-by-loc\n\n# Show file sizes\nrecursivist visualize --sort-by-size\n\n# Show modification times\nrecursivist visualize --sort-by-mtime\n\n# Combine statistics\nrecursivist visualize --sort-by-loc --sort-by-size\n</code></pre>"},{"location":"reference/cli-reference/#export-command","title":"<code>export</code> Command","text":"<p>The <code>export</code> command exports a directory structure to various formats.</p>"},{"location":"reference/cli-reference/#usage_1","title":"Usage","text":"<pre><code>recursivist export [OPTIONS] [DIRECTORY]\n</code></pre>"},{"location":"reference/cli-reference/#arguments_1","title":"Arguments","text":"Argument Description <code>DIRECTORY</code> Directory path to export (defaults to current directory)"},{"location":"reference/cli-reference/#options_1","title":"Options","text":"Option Short Description <code>--format</code> <code>-f</code> Export formats: txt, json, html, md, jsx <code>--output-dir</code> <code>-o</code> Output directory for exports <code>--prefix</code> <code>-n</code> Prefix for exported filenames <code>--exclude</code> <code>-e</code> Directories to exclude (space-separated or multiple flags) <code>--exclude-ext</code> <code>-x</code> File extensions to exclude (space-separated or multiple flags) <code>--exclude-pattern</code> <code>-p</code> Patterns to exclude (glob by default, regex with --regex flag) <code>--include-pattern</code> <code>-i</code> Patterns to include (overrides exclusions) <code>--regex</code> <code>-r</code> Treat patterns as regex instead of glob patterns <code>--ignore-file</code> <code>-g</code> Ignore file to use (e.g., .gitignore) <code>--depth</code> <code>-d</code> Maximum depth to display (0 for unlimited) <code>--full-path</code> <code>-l</code> Show full paths instead of just filenames <code>--sort-by-loc</code> <code>-s</code> Sort files by lines of code and display LOC counts <code>--sort-by-size</code> <code>-z</code> Sort files by size and display file sizes <code>--sort-by-mtime</code> <code>-m</code> Sort files by modification time and display timestamps <code>--verbose</code> <code>-v</code> Enable verbose output"},{"location":"reference/cli-reference/#examples_1","title":"Examples","text":"<pre><code># Export to Markdown format\nrecursivist export --format md\n\n# Export to multiple formats\nrecursivist export --format \"json html md\"\n\n# Export to a specific directory\nrecursivist export --format txt --output-dir ./exports\n\n# Custom filename prefix\nrecursivist export --format json --prefix my-project\n\n# Export with exclusions\nrecursivist export --exclude node_modules --exclude-ext .pyc\n\n# Export with file statistics\nrecursivist export --format html --sort-by-loc --sort-by-size\n</code></pre>"},{"location":"reference/cli-reference/#compare-command","title":"<code>compare</code> Command","text":"<p>The <code>compare</code> command compares two directory structures side by side.</p>"},{"location":"reference/cli-reference/#usage_2","title":"Usage","text":"<pre><code>recursivist compare [OPTIONS] DIR1 DIR2\n</code></pre>"},{"location":"reference/cli-reference/#arguments_2","title":"Arguments","text":"Argument Description <code>DIR1</code> First directory path to compare <code>DIR2</code> Second directory path to compare"},{"location":"reference/cli-reference/#options_2","title":"Options","text":"Option Short Description <code>--exclude</code> <code>-e</code> Directories to exclude (space-separated or multiple flags) <code>--exclude-ext</code> <code>-x</code> File extensions to exclude (space-separated or multiple flags) <code>--exclude-pattern</code> <code>-p</code> Patterns to exclude (glob by default, regex with --regex flag) <code>--include-pattern</code> <code>-i</code> Patterns to include (overrides exclusions) <code>--regex</code> <code>-r</code> Treat patterns as regex instead of glob patterns <code>--ignore-file</code> <code>-g</code> Ignore file to use (e.g., .gitignore) <code>--depth</code> <code>-d</code> Maximum depth to display (0 for unlimited) <code>--full-path</code> <code>-l</code> Show full paths instead of just filenames <code>--save</code> <code>-f</code> Save comparison result to HTML file <code>--output-dir</code> <code>-o</code> Output directory for exports <code>--prefix</code> <code>-n</code> Prefix for exported filenames <code>--sort-by-loc</code> <code>-s</code> Sort files by lines of code and display LOC counts <code>--sort-by-size</code> <code>-z</code> Sort files by size and display file sizes <code>--sort-by-mtime</code> <code>-m</code> Sort files by modification time and display timestamps <code>--verbose</code> <code>-v</code> Enable verbose output"},{"location":"reference/cli-reference/#examples_2","title":"Examples","text":"<pre><code># Compare two directories\nrecursivist compare dir1 dir2\n\n# Compare with exclusions\nrecursivist compare dir1 dir2 --exclude \"node_modules .git\"\n\n# Compare with depth limit\nrecursivist compare dir1 dir2 --depth 2\n\n# Export comparison to HTML\nrecursivist compare dir1 dir2 --save --output-dir ./reports\n\n# Compare with file statistics\nrecursivist compare dir1 dir2 --sort-by-loc --sort-by-size\n</code></pre>"},{"location":"reference/cli-reference/#completion-command","title":"<code>completion</code> Command","text":"<p>The <code>completion</code> command generates shell completion scripts for different shells.</p>"},{"location":"reference/cli-reference/#usage_3","title":"Usage","text":"<pre><code>recursivist completion [SHELL]\n</code></pre>"},{"location":"reference/cli-reference/#arguments_3","title":"Arguments","text":"Argument Description <code>SHELL</code> Shell type (bash, zsh, fish, powershell)"},{"location":"reference/cli-reference/#examples_3","title":"Examples","text":"<pre><code># Generate Bash completion\nrecursivist completion bash &gt; ~/.bash_completion.d/recursivist\n\n# Generate Zsh completion\nrecursivist completion zsh &gt; ~/.zsh/completion/_recursivist\n\n# Generate Fish completion\nrecursivist completion fish &gt; ~/.config/fish/completions/recursivist.fish\n\n# Generate PowerShell completion\nrecursivist completion powershell &gt; recursivist.ps1\n</code></pre>"},{"location":"reference/cli-reference/#version-command","title":"<code>version</code> Command","text":"<p>The <code>version</code> command displays the current version of Recursivist.</p>"},{"location":"reference/cli-reference/#usage_4","title":"Usage","text":"<pre><code>recursivist version\n</code></pre>"},{"location":"reference/export-formats/","title":"Export Formats","text":"<p>Recursivist can export directory structures to several different formats to suit different needs. This page explains each format and provides examples.</p>"},{"location":"reference/export-formats/#available-formats","title":"Available Formats","text":"Format Extension Description Best For Text <code>.txt</code> Simple ASCII tree representation Quick reference, text-only environments JSON <code>.json</code> Structured data format for programmatic use Data processing, integration with tools HTML <code>.html</code> Interactive web-based visualization Sharing, documentation, web presentation Markdown <code>.md</code> GitHub-compatible Markdown representation Project documentation, README files React <code>.jsx</code> Interactive React component Web applications, interactive interfaces"},{"location":"reference/export-formats/#basic-export-command","title":"Basic Export Command","text":"<p>To export the current directory structure:</p> <pre><code>recursivist export --format FORMAT\n</code></pre> <p>Replace <code>FORMAT</code> with one of: <code>txt</code>, <code>json</code>, <code>html</code>, <code>md</code>, or <code>jsx</code>.</p>"},{"location":"reference/export-formats/#exporting-to-multiple-formats","title":"Exporting to Multiple Formats","text":"<p>You can export to multiple formats in a single command:</p> <pre><code>recursivist export --format \"txt json html md jsx\"\n</code></pre>"},{"location":"reference/export-formats/#specifying-output-directory","title":"Specifying Output Directory","text":"<p>By default, exports are saved to the current directory. You can specify a different output directory:</p> <pre><code>recursivist export --format md --output-dir ./exports\n</code></pre>"},{"location":"reference/export-formats/#customizing-filename-prefix","title":"Customizing Filename Prefix","text":"<p>By default, all exports use the prefix <code>structure</code>. You can specify a different prefix:</p> <pre><code>recursivist export --format json --prefix my-project\n</code></pre> <p>This will create a file named <code>my-project.json</code>.</p>"},{"location":"reference/export-formats/#including-file-statistics","title":"Including File Statistics","text":"<p>All export formats support including file statistics:</p> <pre><code># Include lines of code\nrecursivist export --format html --sort-by-loc\n\n# Include file sizes\nrecursivist export --format json --sort-by-size\n\n# Include modification times\nrecursivist export --format md --sort-by-mtime\n\n# Combine multiple statistics\nrecursivist export --format txt --sort-by-loc --sort-by-size\n</code></pre>"},{"location":"reference/export-formats/#format-details","title":"Format Details","text":""},{"location":"reference/export-formats/#text-format-txt","title":"Text Format (TXT)","text":"<p>The text format provides a simple ASCII tree representation that can be viewed in any text editor:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py\n\u251c\u2500\u2500 \ud83d\udcc4 README.md\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py\n</code></pre> <p>With file statistics:</p> <pre><code>\ud83d\udcc2 my-project (4328 lines)\n\u251c\u2500\u2500 \ud83d\udcc1 src (3851 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (245 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (157 lines)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests (653 lines)\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py (412 lines)\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py (241 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md (124 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt (18 lines)\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py (65 lines)\n</code></pre> <p>Export to text format with:</p> <pre><code>recursivist export --format txt\n</code></pre>"},{"location":"reference/export-formats/#json-format","title":"JSON Format","text":"<p>The JSON format provides a structured representation that can be easily parsed by other tools or scripts:</p> <pre><code>{\n  \"root\": \"my-project\",\n  \"structure\": {\n    \"_files\": [\"README.md\", \"requirements.txt\", \"setup.py\"],\n    \"src\": {\n      \"_files\": [\"main.py\", \"utils.py\"],\n      \"tests\": {\n        \"_files\": [\"test_main.py\", \"test_utils.py\"]\n      }\n    }\n  }\n}\n</code></pre> <p>With file statistics:</p> <pre><code>{\n  \"root\": \"my-project\",\n  \"structure\": {\n    \"_loc\": 4328,\n    \"_files\": [\n      { \"name\": \"README.md\", \"path\": \"README.md\", \"loc\": 124 },\n      { \"name\": \"requirements.txt\", \"path\": \"requirements.txt\", \"loc\": 18 },\n      { \"name\": \"setup.py\", \"path\": \"setup.py\", \"loc\": 65 }\n    ],\n    \"src\": {\n      \"_loc\": 3851,\n      \"_files\": [\n        { \"name\": \"main.py\", \"path\": \"main.py\", \"loc\": 245 },\n        { \"name\": \"utils.py\", \"path\": \"utils.py\", \"loc\": 157 }\n      ],\n      \"tests\": {\n        \"_loc\": 653,\n        \"_files\": [\n          { \"name\": \"test_main.py\", \"path\": \"test_main.py\", \"loc\": 412 },\n          { \"name\": \"test_utils.py\", \"path\": \"test_utils.py\", \"loc\": 241 }\n        ]\n      }\n    }\n  },\n  \"show_loc\": true,\n  \"show_size\": false,\n  \"show_mtime\": false\n}\n</code></pre> <p>Export to JSON format with:</p> <pre><code>recursivist export --format json\n</code></pre>"},{"location":"reference/export-formats/#html-format","title":"HTML Format","text":"<p>The HTML format provides an interactive web-based visualization that includes:</p> <ul> <li>Proper styling for directories and files</li> <li>Color-coding based on file extensions</li> <li>File statistics display when enabled</li> <li>Mobile-friendly responsive design</li> <li>Clean, modern styling</li> </ul> <p>Export to HTML format with:</p> <pre><code>recursivist export --format html\n</code></pre> <p>The generated HTML file can be opened in any web browser and includes appropriate styling and formatting.</p>"},{"location":"reference/export-formats/#markdown-format-md","title":"Markdown Format (MD)","text":"<p>The Markdown format creates a representation that renders nicely on platforms like GitHub:</p> <pre><code># \ud83d\udcc2 my-project\n\n- \ud83d\udcc1 **src**\n  - \ud83d\udcc4 `main.py`\n  - \ud83d\udcc4 `utils.py`\n  - \ud83d\udcc1 **tests**\n    - \ud83d\udcc4 `test_main.py`\n    - \ud83d\udcc4 `test_utils.py`\n- \ud83d\udcc4 `README.md`\n- \ud83d\udcc4 `requirements.txt`\n- \ud83d\udcc4 `setup.py`\n</code></pre> <p>With file statistics:</p> <pre><code># \ud83d\udcc2 my-project (4328 lines)\n\n- \ud83d\udcc1 **src** (3851 lines)\n  - \ud83d\udcc4 `main.py` (245 lines)\n  - \ud83d\udcc4 `utils.py` (157 lines)\n  - \ud83d\udcc1 **tests** (653 lines)\n    - \ud83d\udcc4 `test_main.py` (412 lines)\n    - \ud83d\udcc4 `test_utils.py` (241 lines)\n- \ud83d\udcc4 `README.md` (124 lines)\n- \ud83d\udcc4 `requirements.txt` (18 lines)\n- \ud83d\udcc4 `setup.py` (65 lines)\n</code></pre> <p>Export to Markdown format with:</p> <pre><code>recursivist export --format md\n</code></pre>"},{"location":"reference/export-formats/#react-component-jsx","title":"React Component (JSX)","text":"<p>The JSX format creates a self-contained React component with an interactive directory tree viewer:</p> <p>Features include:</p> <ul> <li>Collapsible folder structure</li> <li>Breadcrumb navigation</li> <li>File and path search functionality</li> <li>Path copying</li> <li>Dark/light mode toggle</li> <li>Tree navigation with keyboard shortcuts</li> <li>File statistics display when enabled</li> <li>Expand/collapse all buttons</li> <li>Mobile-responsive design</li> <li>Smooth animations and transitions</li> </ul> <p>Export to React component format with:</p> <pre><code>recursivist export --format jsx\n</code></pre>"},{"location":"reference/export-formats/#using-the-react-component","title":"Using the React Component","text":"<p>To use the exported React component in your project:</p> <ol> <li>Copy the generated <code>.jsx</code> file to your React project's components directory</li> <li>Install the required dependencies:    <pre><code>npm install lucide-react prop-types\n</code></pre></li> <li>Import and use the component in your application:</li> </ol> <pre><code>import DirectoryViewer from \"./components/structure.jsx\";\n\nfunction App() {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;DirectoryViewer /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>The component is designed to be used with Tailwind CSS. If your project doesn't use Tailwind, you may need to adapt the component to use your preferred styling solution.</p>"},{"location":"reference/export-formats/#export-with-filtering","title":"Export with Filtering","text":"<p>All of the filtering options available for the <code>visualize</code> command also work with the <code>export</code> command:</p> <pre><code>recursivist export \\\n--format md \\\n--exclude \"node_modules .git\" \\\n--exclude-ext .pyc \\\n--depth 3\n</code></pre> <p>This exports a Markdown representation of the directory structure, excluding <code>node_modules</code> and <code>.git</code> directories, as well as <code>.pyc</code> files, and limiting the depth to 3 levels.</p>"},{"location":"reference/export-formats/#exporting-full-paths","title":"Exporting Full Paths","text":"<p>By default, exports show only filenames. You can include full paths with the <code>--full-path</code> option:</p> <pre><code>recursivist export --format json --full-path\n</code></pre> <p>This is particularly useful for JSON exports that might be processed by other tools.</p>"},{"location":"reference/export-formats/#comparison-of-export-formats","title":"Comparison of Export Formats","text":"Feature TXT JSON HTML MD JSX Human-readable \u2705 \u26a0\ufe0f \u2705 \u2705 \u26a0\ufe0f Machine-readable \u26a0\ufe0f \u2705 \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f Interactive \u274c \u274c \u2705 \u274c \u2705 Search functionality \u274c \u274c \u274c \u274c \u2705 File statistics support \u2705 \u2705 \u2705 \u2705 \u2705 Color-coding \u2705 \u274c \u2705 \u26a0\ufe0f \u2705 Collapsible structure \u274c \u274c \u274c \u274c \u2705 Requires external libraries \u274c \u274c \u274c \u274c \u2705 <p>Legend:</p> <ul> <li>\u2705 Fully supported</li> <li>\u26a0\ufe0f Partially supported</li> <li>\u274c Not supported</li> </ul>"},{"location":"reference/pattern-matching/","title":"Pattern Matching","text":"<p>This reference guide explains the pattern matching capabilities in Recursivist, covering both glob patterns and regular expressions.</p>"},{"location":"reference/pattern-matching/#pattern-types","title":"Pattern Types","text":"<p>Recursivist supports two types of patterns:</p> <ol> <li>Glob patterns (default): Simple wildcard-based patterns familiar to shell users</li> <li>Regular expressions: More powerful pattern matching syntax for complex cases</li> </ol>"},{"location":"reference/pattern-matching/#glob-patterns","title":"Glob Patterns","text":"<p>By default, Recursivist uses glob patterns for matching files and directories.</p>"},{"location":"reference/pattern-matching/#glob-syntax","title":"Glob Syntax","text":"Pattern Meaning <code>*</code> Matches any number of characters (except <code>/</code>) <code>?</code> Matches a single character (except <code>/</code>) <code>[abc]</code> Matches one character in the brackets <code>[!abc]</code> Matches one character not in the brackets <code>**</code> Matches any number of directories (recursive)"},{"location":"reference/pattern-matching/#glob-examples","title":"Glob Examples","text":"Pattern Matches Does Not Match <code>*.js</code> <code>app.js</code>, <code>utils.js</code> <code>app.jsx</code>, <code>utils.ts</code> <code>*.test.js</code> <code>app.test.js</code>, <code>utils.test.js</code> <code>app.js</code>, <code>test.js</code> <code>src/*</code> <code>src/app.js</code>, <code>src/utils.js</code> <code>src/components/button.js</code> <code>src/**/*.js</code> <code>src/app.js</code>, <code>src/components/button.js</code> <code>app.js</code>, <code>src/app.ts</code> <code>test?.js</code> <code>test1.js</code>, <code>testA.js</code> <code>test.js</code>, <code>test10.js</code> <code>[abc]*.js</code> <code>a.js</code>, <code>b123.js</code>, <code>capp.js</code> <code>d.js</code>, <code>xyz.js</code> <code>[!abc]*.js</code> <code>d.js</code>, <code>xyz.js</code> <code>a.js</code>, <code>b123.js</code>"},{"location":"reference/pattern-matching/#using-glob-patterns","title":"Using Glob Patterns","text":"<p>Glob patterns are used with the <code>--exclude-pattern</code> and <code>--include-pattern</code> options:</p> <pre><code>recursivist visualize --exclude-pattern \"*.test.js\" \"*.spec.js\"\nrecursivist visualize --include-pattern \"src/**/*.js\" \"docs/*.md\"\n</code></pre>"},{"location":"reference/pattern-matching/#regular-expressions","title":"Regular Expressions","text":"<p>For more complex pattern matching, you can use regular expressions by adding the <code>--regex</code> flag.</p>"},{"location":"reference/pattern-matching/#regex-syntax","title":"Regex Syntax","text":"<p>Regular expressions in Recursivist follow Python's regex syntax. Some common elements:</p> Pattern Meaning <code>.</code> Matches any character except newline <code>^</code> Matches the start of a string <code>$</code> Matches the end of a string <code>*</code> Matches 0 or more repetitions <code>+</code> Matches 1 or more repetitions <code>?</code> Matches 0 or 1 repetition <code>\\d</code> Matches a digit <code>\\w</code> Matches a word character <code>\\s</code> Matches a whitespace character <code>[abc]</code> Matches any character in the brackets <code>[^abc]</code> Matches any character not in the brackets <code>a\\|b</code> Matches either a or b <code>(...)</code> Capture group <code>(?:...)</code> Non-capturing group <p>Special characters need to be escaped with a backslash, e.g., <code>\\.</code> to match a literal period.</p>"},{"location":"reference/pattern-matching/#regex-examples","title":"Regex Examples","text":"Pattern Matches Does Not Match <code>^test_.*\\.py$</code> <code>test_app.py</code>, <code>test_utils.py</code> <code>app_test.py</code>, <code>test.py</code> <code>.*\\.(spec\\|test)\\.(js\\|ts)$</code> <code>app.test.js</code>, <code>utils.spec.ts</code> <code>app.js</code>, <code>test.js</code> <code>^src/.*\\.jsx?$</code> <code>src/app.js</code>, <code>src/utils.jsx</code> <code>src/app.ts</code>, <code>lib/app.js</code> <code>^(?!.*test).*\\.py$</code> <code>app.py</code>, <code>utils.py</code> <code>app_test.py</code>, <code>test_utils.py</code> <code>\\d+_.*\\.log$</code> <code>123_server.log</code>, <code>2_app.log</code> <code>server.log</code>, <code>app_123.log</code>"},{"location":"reference/pattern-matching/#using-regex-patterns","title":"Using Regex Patterns","text":"<p>To use regular expressions, add the <code>--regex</code> flag:</p> <pre><code>recursivist visualize \\\n--exclude-pattern \"^test_.*\\.py$\" \".*_test\\.js$\" \\\n--regex\n\nrecursivist visualize \\\n--include-pattern \"^src/.*\\.(jsx?|tsx?)$\" \\\n--regex\n</code></pre>"},{"location":"reference/pattern-matching/#pattern-precedence","title":"Pattern Precedence","text":"<p>When multiple patterns are specified, Recursivist applies them in the following order:</p> <ol> <li>Include patterns (if specified, only matching files will be considered)</li> <li>Exclude patterns (matching files are excluded)</li> <li>Excluded extensions (files with matching extensions are excluded)</li> <li>Excluded directories (directories matching these names are excluded)</li> <li>Gitignore patterns (if specified, patterns from the ignore file are applied)</li> </ol> <p>This means that include patterns have the highest precedence and can override all other exclusions.</p>"},{"location":"reference/pattern-matching/#combining-include-and-exclude-patterns","title":"Combining Include and Exclude Patterns","text":"<p>You can use both include and exclude patterns together:</p> <pre><code>recursivist visualize \\\n--include-pattern \"src/**/*.js\" \"docs/*.md\" \\\n--exclude-pattern \"**/node_modules/*\" \"**/*.min.js\"\n</code></pre> <p>In this case, only files that match at least one include pattern will be considered, and among those, files matching any exclude pattern will be excluded.</p>"},{"location":"reference/pattern-matching/#pattern-matching-in-different-commands","title":"Pattern Matching in Different Commands","text":"<p>Pattern matching works the same way across all Recursivist commands:</p> <ul> <li><code>visualize</code>: Control what files and directories are displayed</li> <li><code>export</code>: Control what's included in the exported file</li> <li><code>compare</code>: Control what's considered when comparing directories</li> </ul>"},{"location":"reference/pattern-matching/#advanced-pattern-examples","title":"Advanced Pattern Examples","text":""},{"location":"reference/pattern-matching/#show-only-source-code","title":"Show Only Source Code","text":"<pre><code># Glob pattern\nrecursivist visualize \\\n--include-pattern \"src/**/*\"\n\n# Regex pattern\nrecursivist visualize \\\n--include-pattern \"^src/\" \\\n--regex\n</code></pre>"},{"location":"reference/pattern-matching/#exclude-all-test-files","title":"Exclude All Test Files","text":"<pre><code># Glob pattern\nrecursivist visualize \\\n--exclude-pattern \"**/*.test.js\" \"**/*.spec.js\" \"test/**/*\"\n\n# Regex pattern\nrecursivist visualize \\\n--exclude-pattern \".*\\.(test|spec)\\.[jt]sx?$\" \"^test/\" \\\n--regex\n</code></pre>"},{"location":"reference/pattern-matching/#show-only-specific-file-types","title":"Show Only Specific File Types","text":"<pre><code># Glob pattern\nrecursivist visualize \\\n--include-pattern \"**/*.{js,jsx,ts,tsx}\"\n\n# Regex pattern\nrecursivist visualize \\\n--include-pattern \".*\\.[jt]sx?$\" \\\n--regex\n</code></pre>"},{"location":"reference/pattern-matching/#complex-filtering-with-regex","title":"Complex Filtering with Regex","text":"<pre><code># Include JavaScript modules, exclude test files and minified files\nrecursivist visualize \\\n--include-pattern \"^src/.*\\.js$\" \\\n--exclude-pattern \".*\\.(test|spec)\\.js$\" \".*\\.min\\.js$\" \\\n--regex\n</code></pre>"},{"location":"reference/pattern-matching/#pattern-matching-with-file-statistics","title":"Pattern Matching with File Statistics","text":"<p>To focus on important code metrics, combine pattern matching with file statistics:</p> <pre><code># Find large source files\nrecursivist visualize \\\n--include-pattern \"src/**/*.js\" \\\n--sort-by-size\n\n# Identify complex modules\nrecursivist visualize \\\n--include-pattern \"src/**/*.py\" \\\n--exclude-pattern \"**/*test*.py\" \\\n--sort-by-loc\n\n# See recent changes to specific areas\nrecursivist visualize \\\n--include-pattern \"src/components/**/*.jsx\" \\\n--sort-by-mtime\n</code></pre>"},{"location":"reference/pattern-matching/#filter-based-on-file-contents-gitignore-style","title":"Filter Based on File Contents (Gitignore Style)","text":"<p>When using a gitignore-style file with the <code>--ignore-file</code> option, you can use patterns that work similarly to <code>.gitignore</code> files:</p> <pre><code># .recursivist-ignore\n*.log\nnode_modules/\n**/dist/\n*~\n</code></pre> <p>Then use it with:</p> <pre><code>recursivist visualize \\\n--ignore-file .recursivist-ignore\n</code></pre>"},{"location":"reference/pattern-matching/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Glob patterns are generally faster than regex patterns</li> <li>Complex regex patterns can be slower on large directory structures</li> <li>Include patterns can improve performance by reducing the number of files to process</li> </ul>"},{"location":"reference/pattern-matching/#common-use-cases","title":"Common Use Cases","text":""},{"location":"reference/pattern-matching/#development-project","title":"Development Project","text":"<pre><code>recursivist visualize \\\n--exclude \"node_modules .git build dist\" \\\n--exclude-ext \".min.js .map\"\n</code></pre>"},{"location":"reference/pattern-matching/#documentation-project","title":"Documentation Project","text":"<pre><code>recursivist visualize \\\n--include-pattern \"**/*.md\" \"**/*.rst\" \"**/*.txt\" \"docs/**/*\"\n</code></pre>"},{"location":"reference/pattern-matching/#source-code-analysis","title":"Source Code Analysis","text":"<pre><code>recursivist visualize \\\n--include-pattern \"src/**/*\" \\\n--exclude-pattern \"**/*.test.js\" \"**/*.spec.js\"\n</code></pre>"},{"location":"reference/pattern-matching/#backend-development","title":"Backend Development","text":"<pre><code>recursivist visualize \\\n--include-pattern \"**/*.py\" \"**/*.go\" \"**/*.java\" \\\n--exclude-pattern \"**/*_test.py\" \"**/*_test.go\" \"**/*Test.java\"\n</code></pre>"},{"location":"reference/pattern-matching/#troubleshooting-pattern-matching","title":"Troubleshooting Pattern Matching","text":"<p>If your patterns aren't working as expected:</p> <ol> <li>Use verbose mode: Run with <code>--verbose</code> to see detailed logging about pattern matching</li> <li>Test simpler patterns first: Start with basic patterns and build up complexity</li> <li>Check pattern syntax: Ensure you're using the correct syntax for glob or regex</li> <li>Remember path conventions: Patterns match against relative paths from the root directory</li> <li>Check precedence: Remember that include patterns override exclude patterns</li> </ol> <p>For debugging complex regex patterns, consider testing them in a regex tool like regex101.com before using them in Recursivist.</p>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>Recursivist is designed to be intuitive and easy to use while offering powerful capabilities. This guide covers the basic concepts and usage patterns.</p>"},{"location":"user-guide/basic-usage/#command-structure","title":"Command Structure","text":"<p>All Recursivist commands follow a consistent structure:</p> <pre><code>recursivist [command] [options] [arguments]\n</code></pre> <p>Where:</p> <ul> <li><code>command</code> is one of: <code>visualize</code>, <code>export</code>, <code>compare</code>, <code>completion</code>, or <code>version</code></li> <li><code>options</code> are optional flags that modify the command's behavior</li> <li><code>arguments</code> are typically directory paths or other positional arguments</li> </ul>"},{"location":"user-guide/basic-usage/#basic-commands","title":"Basic Commands","text":""},{"location":"user-guide/basic-usage/#checking-version","title":"Checking Version","text":"<p>To check which version of Recursivist you have installed:</p> <pre><code>recursivist version\n</code></pre>"},{"location":"user-guide/basic-usage/#visualizing-the-current-directory","title":"Visualizing the Current Directory","text":"<p>To display a tree representation of the current directory:</p> <pre><code>recursivist visualize\n</code></pre> <p>This will show a colorful tree of all files and directories, with each file type color-coded for easy identification.</p>"},{"location":"user-guide/basic-usage/#visualizing-a-specific-directory","title":"Visualizing a Specific Directory","text":"<p>To visualize a different directory:</p> <pre><code>recursivist visualize /path/to/directory\n</code></pre>"},{"location":"user-guide/basic-usage/#visualizing-with-file-statistics","title":"Visualizing with File Statistics","text":"<p>Recursivist can display and sort by various file statistics:</p> <pre><code># Show lines of code\nrecursivist visualize --sort-by-loc\n\n# Show file sizes\nrecursivist visualize --sort-by-size\n\n# Show modification times\nrecursivist visualize --sort-by-mtime\n\n# Combine multiple statistics\nrecursivist visualize --sort-by-loc --sort-by-size\n</code></pre>"},{"location":"user-guide/basic-usage/#getting-help","title":"Getting Help","text":"<p>To see all available commands:</p> <pre><code>recursivist --help\n</code></pre> <p>To get help for a specific command:</p> <pre><code>recursivist visualize --help\nrecursivist export --help\nrecursivist compare --help\n</code></pre>"},{"location":"user-guide/basic-usage/#default-behavior","title":"Default Behavior","text":"<p>By default, Recursivist:</p> <ul> <li>Shows all files and directories in the specified location</li> <li>Doesn't limit the depth of the directory tree</li> <li>Displays only filenames (not full paths)</li> <li>Colors files based on their extensions</li> <li>Uses Unicode characters for the tree structure</li> </ul> <p>You can modify this behavior using the various options described in the following sections.</p>"},{"location":"user-guide/basic-usage/#common-options","title":"Common Options","text":"<p>These options work with most Recursivist commands:</p>"},{"location":"user-guide/basic-usage/#excluding-directories","title":"Excluding Directories","text":"<p>To exclude specific directories:</p> <pre><code>recursivist visualize --exclude \"node_modules .git\"\n</code></pre>"},{"location":"user-guide/basic-usage/#excluding-file-extensions","title":"Excluding File Extensions","text":"<p>To exclude files with specific extensions:</p> <pre><code>recursivist visualize --exclude-ext \".pyc .log\"\n</code></pre>"},{"location":"user-guide/basic-usage/#limiting-depth","title":"Limiting Depth","text":"<p>To limit how deep the directory tree goes:</p> <pre><code>recursivist visualize --depth 3\n</code></pre>"},{"location":"user-guide/basic-usage/#showing-full-paths","title":"Showing Full Paths","text":"<p>To show full file paths instead of just names:</p> <pre><code>recursivist visualize --full-path\n</code></pre>"},{"location":"user-guide/basic-usage/#using-verbose-mode","title":"Using Verbose Mode","text":"<p>For more detailed output and logging:</p> <pre><code>recursivist visualize --verbose\n</code></pre>"},{"location":"user-guide/basic-usage/#pattern-filtering","title":"Pattern Filtering","text":"<p>Recursivist offers powerful pattern-based filtering options:</p>"},{"location":"user-guide/basic-usage/#glob-patterns-default","title":"Glob Patterns (Default)","text":"<pre><code># Exclude test files\nrecursivist visualize --exclude-pattern \"*.test.js\" \"*.spec.js\"\n</code></pre>"},{"location":"user-guide/basic-usage/#regular-expressions","title":"Regular Expressions","text":"<pre><code># Exclude test files using regex\nrecursivist visualize --exclude-pattern \"^test_.*\\.py$\" --regex\n</code></pre>"},{"location":"user-guide/basic-usage/#include-patterns-override-exclusions","title":"Include Patterns (Override Exclusions)","text":"<pre><code># Only include specific files/directories\nrecursivist visualize --include-pattern \"src/**/*.js\" \"*.md\"\n</code></pre>"},{"location":"user-guide/basic-usage/#gitignore-integration","title":"Gitignore Integration","text":"<pre><code># Use patterns from a gitignore-style file\nrecursivist visualize --ignore-file .gitignore\n</code></pre>"},{"location":"user-guide/basic-usage/#export-formats","title":"Export Formats","text":"<p>Export directory structures to various formats:</p> <pre><code># Export to Markdown\nrecursivist export --format md\n\n# Export to JSON\nrecursivist export --format json\n\n# Export to HTML\nrecursivist export --format html\n\n# Export to plain text\nrecursivist export --format txt\n\n# Export to React component\nrecursivist export --format jsx\n</code></pre>"},{"location":"user-guide/basic-usage/#directory-comparison","title":"Directory Comparison","text":"<p>Compare two directory structures:</p> <pre><code># Basic comparison\nrecursivist compare dir1 dir2\n\n# Save comparison as HTML\nrecursivist compare dir1 dir2 --save\n</code></pre>"},{"location":"user-guide/basic-usage/#shell-completion","title":"Shell Completion","text":"<p>Generate shell completion scripts:</p> <pre><code># For Bash\nrecursivist completion bash &gt; ~/.bash_completion.d/recursivist\n\n# For Zsh, Fish, or PowerShell\nrecursivist completion zsh|fish|powershell\n</code></pre>"},{"location":"user-guide/basic-usage/#exit-codes","title":"Exit Codes","text":"<p>Recursivist uses standard exit codes to indicate success or failure:</p> <ul> <li><code>0</code>: Success</li> <li><code>1</code>: General error (like invalid arguments or directories)</li> <li>Other non-zero values: Specific error conditions</li> </ul> <p>These exit codes can be useful when incorporating Recursivist into scripts or automation.</p>"},{"location":"user-guide/basic-usage/#next-steps","title":"Next Steps","text":"<p>Now that you're familiar with the basic usage, you can explore:</p> <ul> <li>Visualization options for customizing how directory trees are displayed</li> <li>Export formats for saving directory structures</li> <li>Comparison features for identifying differences between directories</li> <li>Pattern filtering for precisely controlling what's included/excluded</li> </ul>"},{"location":"user-guide/compare/","title":"Compare","text":"<p>The <code>compare</code> command allows you to compare two directory structures side by side with highlighted differences. This guide explains how to use it effectively.</p>"},{"location":"user-guide/compare/#basic-comparison","title":"Basic Comparison","text":"<p>To compare two directories:</p> <pre><code>recursivist compare dir1 dir2\n</code></pre> <p>This will display both directory trees side by side in the terminal, with highlighted differences between them.</p>"},{"location":"user-guide/compare/#understanding-the-output","title":"Understanding the Output","text":"<p>The comparison output uses color highlighting to show differences:</p> <ul> <li>Items that exist in both directories are displayed normally</li> <li>Items unique to directory 1 are highlighted in green</li> <li>Items unique to directory 2 are highlighted in red</li> </ul> <p>A legend explains the color coding at the top of the output.</p>"},{"location":"user-guide/compare/#including-file-statistics","title":"Including File Statistics","text":"<p>You can include file statistics in the comparison:</p> <pre><code># Include lines of code\nrecursivist compare dir1 dir2 --sort-by-loc\n\n# Include file sizes\nrecursivist compare dir1 dir2 --sort-by-size\n\n# Include modification times\nrecursivist compare dir1 dir2 --sort-by-mtime\n\n# Combine multiple statistics\nrecursivist compare dir1 dir2 --sort-by-loc --sort-by-size\n</code></pre> <p>This makes it easy to see not just structural differences but also differences in file content size, modification time, or other metrics.</p>"},{"location":"user-guide/compare/#exporting-comparison-results","title":"Exporting Comparison Results","text":"<p>By default, the comparison is displayed in the terminal. To save it as an HTML file:</p> <pre><code>recursivist compare dir1 dir2 --save\n</code></pre> <p>This creates an HTML file named <code>comparison.html</code> in the current directory.</p> <p>To specify a different output directory:</p> <pre><code>recursivist compare dir1 dir2 --save --output-dir ./reports\n</code></pre> <p>To customize the filename prefix:</p> <pre><code>recursivist compare dir1 dir2 --save --prefix project-diff\n</code></pre> <p>This creates a file named <code>project-diff.html</code>.</p>"},{"location":"user-guide/compare/#filtering-the-comparison","title":"Filtering the Comparison","text":"<p>All of the filtering options available for other Recursivist commands also work with <code>compare</code>:</p>"},{"location":"user-guide/compare/#excluding-directories","title":"Excluding Directories","text":"<pre><code>recursivist compare dir1 dir2 --exclude \"node_modules .git\"\n</code></pre>"},{"location":"user-guide/compare/#excluding-file-extensions","title":"Excluding File Extensions","text":"<pre><code>recursivist compare dir1 dir2 --exclude-ext \".pyc .log\"\n</code></pre>"},{"location":"user-guide/compare/#pattern-based-filtering","title":"Pattern-Based Filtering","text":"<pre><code># Exclude with glob patterns (default)\nrecursivist compare dir1 dir2 --exclude-pattern \"*.test.js\"\n\n# Exclude with regex patterns\nrecursivist compare dir1 dir2 --exclude-pattern \"^test_.*\\.py$\" --regex\n\n# Include only specific patterns\nrecursivist compare dir1 dir2 --include-pattern \"src/*\" \"*.md\"\n</code></pre> <p>See the Pattern Filtering guide for more details.</p>"},{"location":"user-guide/compare/#using-gitignore-files","title":"Using Gitignore Files","text":"<pre><code>recursivist compare dir1 dir2 --ignore-file .gitignore\n</code></pre>"},{"location":"user-guide/compare/#depth-control","title":"Depth Control","text":"<p>For large directories, limit the comparison depth:</p> <pre><code>recursivist compare dir1 dir2 --depth 3\n</code></pre>"},{"location":"user-guide/compare/#full-path-display","title":"Full Path Display","text":"<p>To show full paths instead of just filenames:</p> <pre><code>recursivist compare dir1 dir2 --full-path\n</code></pre>"},{"location":"user-guide/compare/#use-cases","title":"Use Cases","text":"<p>The comparison feature is particularly useful for:</p>"},{"location":"user-guide/compare/#project-evolution","title":"Project Evolution","text":"<p>Compare different versions of a project:</p> <pre><code>recursivist compare project-v1.0 project-v2.0\n</code></pre>"},{"location":"user-guide/compare/#code-reviews","title":"Code Reviews","text":"<p>Compare branches or pull requests:</p> <pre><code># Clone the branches to compare\ngit clone -b main repo main-branch\ngit clone -b feature/new-feature repo feature-branch\n\n# Compare directory structures\nrecursivist compare main-branch feature-branch\n</code></pre>"},{"location":"user-guide/compare/#deployment-verification","title":"Deployment Verification","text":"<p>Compare local development and production environments:</p> <pre><code>recursivist compare local-build production-build\n</code></pre>"},{"location":"user-guide/compare/#backup-validation","title":"Backup Validation","text":"<p>Compare original files with backups:</p> <pre><code>recursivist compare original-files backup-files\n</code></pre>"},{"location":"user-guide/compare/#examples","title":"Examples","text":""},{"location":"user-guide/compare/#basic-comparison_1","title":"Basic Comparison","text":"<pre><code>recursivist compare project-v1 project-v2\n</code></pre>"},{"location":"user-guide/compare/#compare-with-exclusions","title":"Compare with Exclusions","text":"<pre><code>recursivist compare project-v1 project-v2 \\\n--exclude \"node_modules .git\" \\\n--exclude-ext \".pyc .log\"\n</code></pre>"},{"location":"user-guide/compare/#compare-with-depth-limit-and-html-export","title":"Compare with Depth Limit and HTML Export","text":"<pre><code>recursivist compare project-v1 project-v2 \\\n--depth 3 \\\n--save \\\n--output-dir ./reports \\\n--prefix version-comparison\n</code></pre>"},{"location":"user-guide/compare/#compare-source-directories-only","title":"Compare Source Directories Only","text":"<pre><code>recursivist compare project-v1/src project-v2/src \\\n--include-pattern \"*.js\" \"*.css\" \"*.jsx\"\n</code></pre>"},{"location":"user-guide/compare/#compare-with-file-statistics","title":"Compare with File Statistics","text":"<pre><code>recursivist compare project-v1 project-v2 \\\n--sort-by-loc \\\n--sort-by-size\n</code></pre>"},{"location":"user-guide/compare/#html-output-features","title":"HTML Output Features","text":"<p>When exporting to HTML (<code>--save</code> option), the generated file includes:</p> <ul> <li>Interactive, side-by-side comparison</li> <li>Color-coded highlighting of differences</li> <li>Responsive layout that works on different screen sizes</li> <li>Proper styling for directories and files</li> <li>File statistics display when enabled</li> <li>Detailed metadata about the comparison settings</li> <li>Visual legend explaining the highlighting scheme</li> </ul> <p>This is useful for sharing comparison results with team members or keeping records of structural changes.</p>"},{"location":"user-guide/compare/#terminal-compatibility","title":"Terminal Compatibility","text":"<p>The terminal comparison view works best in terminals with:</p> <ul> <li>Unicode support for special characters</li> <li>ANSI color support</li> <li>Sufficient width to display side-by-side content</li> </ul> <p>For narrow terminals, the comparison may not display optimally. In these cases, using the HTML export option (<code>--save</code>) is recommended.</p>"},{"location":"user-guide/export/","title":"Export","text":"<p>The <code>export</code> command allows you to save directory structures to various file formats. This guide covers how to use the export features effectively.</p>"},{"location":"user-guide/export/#basic-export-usage","title":"Basic Export Usage","text":"<p>To export the current directory structure:</p> <pre><code>recursivist export --format FORMAT\n</code></pre> <p>Replace <code>FORMAT</code> with one of: <code>txt</code>, <code>json</code>, <code>html</code>, <code>md</code>, or <code>jsx</code>.</p> <p>For a specific directory:</p> <pre><code>recursivist export /path/to/directory --format FORMAT\n</code></pre>"},{"location":"user-guide/export/#available-export-formats","title":"Available Export Formats","text":"<p>Recursivist supports multiple export formats, each suitable for different purposes:</p> Format Extension Description Use Case Text <code>.txt</code> Simple ASCII tree Quick reference, text-only environments JSON <code>.json</code> Structured data Integration with other tools, processing HTML <code>.html</code> Web-based view Sharing, web documentation Markdown <code>.md</code> GitHub-compatible Documentation, GitHub readmes React <code>.jsx</code> Interactive component Web applications, dashboards"},{"location":"user-guide/export/#exporting-to-multiple-formats","title":"Exporting to Multiple Formats","text":"<p>You can export to multiple formats in a single command:</p> <pre><code># Space-separated formats\nrecursivist export --format \"txt json html md\"\n\n# Multiple format flags\nrecursivist export --format txt --format json --format html\n</code></pre>"},{"location":"user-guide/export/#output-directory","title":"Output Directory","text":"<p>By default, exports are saved to the current directory. To specify a different location:</p> <pre><code>recursivist export --format md --output-dir ./exports\n</code></pre> <p>This will create a file at <code>./exports/structure.md</code>.</p>"},{"location":"user-guide/export/#customizing-filenames","title":"Customizing Filenames","text":"<p>By default, all exports use the prefix <code>structure</code>. You can specify a different prefix:</p> <pre><code>recursivist export --format json --prefix my-project\n</code></pre> <p>This will create a file named <code>my-project.json</code>.</p>"},{"location":"user-guide/export/#including-file-statistics","title":"Including File Statistics","text":"<p>You can include statistics in your exports, just like with the <code>visualize</code> command:</p> <pre><code># Include lines of code in export\nrecursivist export --format md --sort-by-loc\n\n# Include file sizes\nrecursivist export --format html --sort-by-size\n\n# Include modification times\nrecursivist export --format json --sort-by-mtime\n\n# Combine multiple statistics\nrecursivist export --format md --sort-by-loc --sort-by-size\n</code></pre> <p>These statistics will be included in the export file with appropriate formatting for each format.</p>"},{"location":"user-guide/export/#filtering-exports","title":"Filtering Exports","text":"<p>All of the filtering options available for the <code>visualize</code> command also work with <code>export</code>:</p> <pre><code>recursivist export --format md \\\n--exclude \"node_modules .git\" \\\n--exclude-ext .pyc \\\n--exclude-pattern \"*.test.js\"\n</code></pre> <p>See the Pattern Filtering guide for more details on filtering options.</p>"},{"location":"user-guide/export/#depth-control","title":"Depth Control","text":"<p>For large projects, you can limit the export depth:</p> <pre><code>recursivist export --format html --depth 3\n</code></pre>"},{"location":"user-guide/export/#full-path-display","title":"Full Path Display","text":"<p>By default, exports show only filenames. To include full paths:</p> <pre><code>recursivist export --format json --full-path\n</code></pre> <p>This is particularly useful for JSON exports that might be processed by other tools.</p>"},{"location":"user-guide/export/#format-specific-features","title":"Format-Specific Features","text":""},{"location":"user-guide/export/#text-format-txt","title":"Text Format (.txt)","text":"<p>The text format provides a simple ASCII tree view:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 utils.py\n\u251c\u2500\u2500 \ud83d\udcc4 README.md\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py\n</code></pre> <p>This format works well in environments where Unicode is supported.</p>"},{"location":"user-guide/export/#json-format-json","title":"JSON Format (.json)","text":"<p>The JSON format provides a structured representation:</p> <pre><code>{\n  \"root\": \"my-project\",\n  \"structure\": {\n    \"src\": {\n      \"_files\": [\"main.py\", \"utils.py\"]\n    },\n    \"_files\": [\"README.md\", \"setup.py\"]\n  }\n}\n</code></pre> <p>When file statistics are included:</p> <pre><code>{\n  \"root\": \"my-project\",\n  \"structure\": {\n    \"_loc\": 4328,\n    \"src\": {\n      \"_loc\": 3851,\n      \"_files\": [\n        { \"name\": \"main.py\", \"path\": \"main.py\", \"loc\": 245 },\n        { \"name\": \"utils.py\", \"path\": \"utils.py\", \"loc\": 157 }\n      ]\n    },\n    \"_files\": [\n      { \"name\": \"README.md\", \"path\": \"README.md\", \"loc\": 124 },\n      { \"name\": \"setup.py\", \"path\": \"setup.py\", \"loc\": 65 }\n    ]\n  },\n  \"show_loc\": true,\n  \"show_size\": false,\n  \"show_mtime\": false\n}\n</code></pre> <p>This format is ideal for programmatic processing or integration with other tools.</p>"},{"location":"user-guide/export/#html-format-html","title":"HTML Format (.html)","text":"<p>The HTML format creates a web page with an interactive directory structure. It includes:</p> <ul> <li>Proper styling for directories and files</li> <li>Color coding based on file types</li> <li>Statistics display when enabled</li> <li>Responsive design for viewing on different devices</li> </ul> <p>When file statistics are included, they are displayed next to each file and directory with appropriate styling.</p>"},{"location":"user-guide/export/#markdown-format-md","title":"Markdown Format (.md)","text":"<p>The Markdown format creates a representation that renders well on platforms like GitHub:</p> <pre><code># \ud83d\udcc2 my-project\n\n- \ud83d\udcc1 **src**\n  - \ud83d\udcc4 `main.py`\n  - \ud83d\udcc4 `utils.py`\n- \ud83d\udcc4 `README.md`\n- \ud83d\udcc4 `setup.py`\n</code></pre> <p>With statistics:</p> <pre><code># \ud83d\udcc2 my-project (4328 lines)\n\n- \ud83d\udcc1 **src** (3851 lines)\n  - \ud83d\udcc4 `main.py` (245 lines)\n  - \ud83d\udcc4 `utils.py` (157 lines)\n- \ud83d\udcc4 `README.md` (124 lines)\n- \ud83d\udcc4 `setup.py` (65 lines)\n</code></pre>"},{"location":"user-guide/export/#react-component-jsx","title":"React Component (.jsx)","text":"<p>The JSX format creates an interactive React component with:</p> <ul> <li>Collapsible folder structure</li> <li>Search functionality</li> <li>Breadcrumb navigation</li> <li>Path copying</li> <li>Dark mode toggle</li> <li>File statistics display when enabled</li> <li>Expand/collapse all buttons</li> <li>Mobile-responsive design</li> </ul> <p>This is the most sophisticated export option, designed for integration into web applications.</p>"},{"location":"user-guide/export/#using-the-react-component","title":"Using the React Component","text":"<p>To use the exported React component in your project:</p> <ol> <li>Copy the generated <code>.jsx</code> file to your React project's components directory</li> <li>Install required dependencies:    <pre><code>npm install lucide-react\n</code></pre></li> <li>Import and use the component:</li> </ol> <pre><code>import DirectoryViewer from \"./components/structure.jsx\";\n\nfunction App() {\n  return (\n    &lt;div className=\"App\"&gt;\n      &lt;DirectoryViewer /&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>The component is designed to work with Tailwind CSS. If your project doesn't use Tailwind, you'll need to adapt the component accordingly.</p>"},{"location":"user-guide/export/#examples","title":"Examples","text":""},{"location":"user-guide/export/#basic-export-to-markdown","title":"Basic Export to Markdown","text":"<pre><code>recursivist export --format md\n</code></pre>"},{"location":"user-guide/export/#export-to-multiple-formats-with-custom-prefix","title":"Export to Multiple Formats with Custom Prefix","text":"<pre><code>recursivist export \\\n--format \"txt md json\" \\\n--prefix project-structure \\\n--output-dir ./docs\n</code></pre>"},{"location":"user-guide/export/#export-source-directory-only","title":"Export Source Directory Only","text":"<pre><code>recursivist export src \\\n--format html \\\n--prefix source-structure\n</code></pre>"},{"location":"user-guide/export/#export-with-depth-control-and-exclusions","title":"Export with Depth Control and Exclusions","text":"<pre><code>recursivist export \\\n--format jsx \\\n--depth 3 \\\n--exclude \"node_modules .git\" \\\n--exclude-ext \".log .tmp\"\n</code></pre>"},{"location":"user-guide/export/#export-with-file-statistics","title":"Export with File Statistics","text":"<pre><code>recursivist export \\\n--format html \\\n--sort-by-loc \\\n--sort-by-size \\\n--sort-by-mtime\n</code></pre> <p>For more detailed information about export formats, see the Export Formats reference.</p>"},{"location":"user-guide/pattern-filtering/","title":"Pattern Filtering","text":"<p>Recursivist provides powerful pattern-based filtering to help you focus on the files and directories that matter most. This guide explains the different filtering methods available.</p>"},{"location":"user-guide/pattern-filtering/#basic-filtering","title":"Basic Filtering","text":""},{"location":"user-guide/pattern-filtering/#excluding-directories","title":"Excluding Directories","text":"<p>To exclude specific directories from the visualization or export, you can specify multiple directories either as space-separated values with a single flag or with multiple flags:</p> <pre><code># Space-separated\nrecursivist visualize --exclude \"node_modules .git venv\"\n\n# Multiple flags\nrecursivist visualize --exclude node_modules --exclude .git --exclude venv\n</code></pre>"},{"location":"user-guide/pattern-filtering/#excluding-file-extensions","title":"Excluding File Extensions","text":"<p>To exclude files with specific extensions:</p> <pre><code>recursivist visualize --exclude-ext \".pyc .log .cache\"\n</code></pre> <p>File extensions can be specified with or without the leading dot (<code>.</code>), as Recursivist normalizes them internally.</p>"},{"location":"user-guide/pattern-filtering/#advanced-filtering","title":"Advanced Filtering","text":""},{"location":"user-guide/pattern-filtering/#using-gitignore-files","title":"Using Gitignore Files","text":"<p>If you have a <code>.gitignore</code> file (or similar), you can use it to filter the directory structure:</p> <pre><code>recursivist visualize --ignore-file .gitignore\n</code></pre> <p>You can also specify a different file:</p> <pre><code>recursivist visualize --ignore-file .recursivist-ignore\n</code></pre>"},{"location":"user-guide/pattern-filtering/#glob-pattern-filtering","title":"Glob Pattern Filtering","text":"<p>By default, Recursivist supports glob patterns for filtering:</p> <pre><code># Exclude all JavaScript test files\nrecursivist visualize --exclude-pattern \"*.test.js\" \"*.spec.js\"\n\n# Exclude all Python cache files and directories\nrecursivist visualize --exclude-pattern \"__pycache__\" \"*.pyc\"\n</code></pre> <p>Glob patterns use simple wildcard characters:</p> <ul> <li><code>*</code>: Matches any number of characters</li> <li><code>?</code>: Matches a single character</li> <li><code>[abc]</code>: Matches one character in the brackets</li> <li><code>[!abc]</code>: Matches one character not in the brackets</li> <li><code>**</code>: Matches directories recursively (e.g., <code>src/**/*.js</code> matches all JS files in src and subdirectories)</li> </ul>"},{"location":"user-guide/pattern-filtering/#regex-pattern-filtering","title":"Regex Pattern Filtering","text":"<p>For more complex patterns, you can use regular expressions by adding the <code>--regex</code> flag:</p> <pre><code># Exclude files starting with \"test_\" and ending with \".py\"\nrecursivist visualize --exclude-pattern \"^test_.*\\.py$\" --regex\n\n# Exclude both JavaScript and TypeScript test files\nrecursivist visualize --exclude-pattern \".*\\.(spec|test)\\.(js|ts)$\" --regex\n</code></pre> <p>Regular expressions provide more powerful matching capabilities but can be more complex to write.</p>"},{"location":"user-guide/pattern-filtering/#include-patterns","title":"Include Patterns","text":"<p>Sometimes it's easier to specify what you want to include rather than what you want to exclude. For this, use the <code>--include-pattern</code> option:</p> <pre><code># Include only source code files and documentation\nrecursivist visualize --include-pattern \"src/**/*.js\" \"docs/*.md\"\n</code></pre> <p>When you specify include patterns, they take precedence over exclude patterns. Only files that match at least one include pattern will be shown.</p> <p>With regex:</p> <pre><code># Include only React components and their tests\nrecursivist visualize --include-pattern \"^src/.*\\.(jsx|tsx)$\" \"^src/.*\\.test\\.(jsx|tsx)$\" --regex\n</code></pre>"},{"location":"user-guide/pattern-filtering/#combining-filters","title":"Combining Filters","text":"<p>You can combine different filtering methods for precise control:</p> <pre><code>recursivist visualize \\\n--exclude \"node_modules .git\" \\\n--exclude-ext \".pyc .log\" \\\n--exclude-pattern \"*.test.js\" \\\n--include-pattern \"src/*\" \"*.md\" \\\n--ignore-file .gitignore\n</code></pre>"},{"location":"user-guide/pattern-filtering/#filter-order-of-precedence","title":"Filter Order of Precedence","text":"<p>When multiple filtering methods are used, Recursivist applies them in the following order:</p> <ol> <li>Include patterns (if specified, only matching files will be considered)</li> <li>Exclude patterns (matching files are excluded)</li> <li>Excluded extensions (files with matching extensions are excluded)</li> <li>Excluded directories (directories matching these names are excluded)</li> <li>Gitignore patterns (if specified, patterns from the ignore file are applied)</li> </ol> <p>This means that include patterns have the highest precedence and can override all other exclusions.</p>"},{"location":"user-guide/pattern-filtering/#examples","title":"Examples","text":""},{"location":"user-guide/pattern-filtering/#focus-on-source-code-only","title":"Focus on Source Code Only","text":"<pre><code>recursivist visualize --include-pattern \"src/*\"\n</code></pre>"},{"location":"user-guide/pattern-filtering/#exclude-generated-files","title":"Exclude Generated Files","text":"<pre><code>recursivist visualize --exclude \"dist build coverage\" --exclude-ext \".min.js .map\"\n</code></pre>"},{"location":"user-guide/pattern-filtering/#view-only-documentation","title":"View Only Documentation","text":"<pre><code>recursivist visualize --include-pattern \"*.md\" \"*.rst\" \"docs/*\"\n</code></pre>"},{"location":"user-guide/pattern-filtering/#complex-filtering-with-regex","title":"Complex Filtering with Regex","text":"<pre><code>recursivist visualize \\\n--include-pattern \"^src/.*\\.(jsx?|tsx?)$\" \\\n--exclude-pattern \".*\\.(spec|test)\\.(jsx?|tsx?)$\" \\\n--regex\n</code></pre> <p>This includes only JavaScript and TypeScript source files from the <code>src</code> directory, but excludes test files.</p>"},{"location":"user-guide/pattern-filtering/#filtering-with-file-statistics","title":"Filtering with File Statistics","text":"<p>You can combine filtering with file statistics to focus on specific aspects of your codebase:</p> <pre><code># Show only source files with more than 100 lines\nrecursivist visualize \\\n--include-pattern \"src/**/*.py\" \\\n--sort-by-loc\n\n# Find largest files in a specific directory\nrecursivist visualize \\\n--include-pattern \"assets/**/*\" \\\n--sort-by-size\n\n# See recently modified files\nrecursivist visualize \\\n--exclude \"node_modules .git\" \\\n--sort-by-mtime\n</code></pre> <p>While Recursivist doesn't directly filter by the statistics themselves (like \"show only files larger than X\"), sorting by these metrics helps identify key files of interest.</p>"},{"location":"user-guide/pattern-filtering/#filtering-in-export-and-compare-commands","title":"Filtering in Export and Compare Commands","text":"<p>All the filtering techniques described above work the same way with the <code>export</code> and <code>compare</code> commands:</p> <pre><code># Export only source files\nrecursivist export --format md --include-pattern \"src/**/*.js\"\n\n# Compare only specific directories\nrecursivist compare dir1 dir2 --include-pattern \"src/*\" \"config/*\"\n</code></pre> <p>This consistency across commands allows you to apply the same filtering logic regardless of the operation you're performing.</p>"},{"location":"user-guide/shell-completion/","title":"Shell Completion","text":"<p>Recursivist supports shell completion for easier command entry. This guide explains how to set up and use shell completion for different shells.</p>"},{"location":"user-guide/shell-completion/#what-is-shell-completion","title":"What is Shell Completion?","text":"<p>Shell completion allows you to press the <code>Tab</code> key while typing a command to:</p> <ul> <li>Complete command names, options, and arguments</li> <li>See available options and subcommands</li> <li>Auto-complete file and directory paths</li> </ul> <p>This makes Recursivist faster and easier to use from the command line.</p>"},{"location":"user-guide/shell-completion/#generating-completion-scripts","title":"Generating Completion Scripts","text":"<p>Recursivist can generate shell completion scripts for different shells:</p> <ul> <li>Bash</li> <li>Zsh</li> <li>Fish</li> <li>PowerShell</li> </ul> <p>Use the <code>completion</code> command to generate the appropriate script:</p> <pre><code>recursivist completion SHELL\n</code></pre> <p>Replace <code>SHELL</code> with one of: <code>bash</code>, <code>zsh</code>, <code>fish</code>, or <code>powershell</code>.</p>"},{"location":"user-guide/shell-completion/#setting-up-completion-for-different-shells","title":"Setting Up Completion for Different Shells","text":""},{"location":"user-guide/shell-completion/#bash","title":"Bash","text":"<pre><code># Create the completions directory if it doesn't exist\nmkdir -p ~/.bash_completion.d\n\n# Generate and save the completion script\nrecursivist completion bash &gt; ~/.bash_completion.d/recursivist\n\n# Add to .bashrc to load on startup\necho 'source ~/.bash_completion.d/recursivist' &gt;&gt; ~/.bashrc\n\n# Load the completion in the current session\nsource ~/.bash_completion.d/recursivist\n</code></pre>"},{"location":"user-guide/shell-completion/#zsh","title":"Zsh","text":"<pre><code># Create the completions directory if it doesn't exist\nmkdir -p ~/.zsh/completion\n\n# Generate and save the completion script\nrecursivist completion zsh &gt; ~/.zsh/completion/_recursivist\n\n# Add to .zshrc to load on startup (if not already configured)\necho 'fpath=(~/.zsh/completion $fpath)' &gt;&gt; ~/.zshrc\necho 'autoload -U compinit; compinit' &gt;&gt; ~/.zshrc\n\n# Load the completion in the current session\nfpath=(~/.zsh/completion $fpath)\nautoload -U compinit; compinit\n</code></pre>"},{"location":"user-guide/shell-completion/#fish","title":"Fish","text":"<pre><code># Create the completions directory if it doesn't exist\nmkdir -p ~/.config/fish/completions\n\n# Generate and save the completion script\nrecursivist completion fish &gt; ~/.config/fish/completions/recursivist.fish\n\n# Completions will be loaded automatically the next time you start fish\n# To load them immediately:\nsource ~/.config/fish/completions/recursivist.fish\n</code></pre>"},{"location":"user-guide/shell-completion/#powershell","title":"PowerShell","text":"<pre><code># Generate the completion script\nrecursivist completion powershell &gt; recursivist.ps1\n\n# Create a profile if it doesn't exist (check first)\nif (!(Test-Path -Path $PROFILE)) {\n    New-Item -ItemType File -Path $PROFILE -Force\n}\n\n# Add the completion script to your profile\nAdd-Content -Path $PROFILE -Value \". $(pwd)\\recursivist.ps1\"\n\n# Load the completion in the current session\n. .\\recursivist.ps1\n</code></pre>"},{"location":"user-guide/shell-completion/#using-shell-completion","title":"Using Shell Completion","text":"<p>Once set up, you can use tab completion with Recursivist commands:</p> <ol> <li>Type a partial command and press <code>Tab</code> to complete it:</li> </ol> <pre><code>recursis[Tab]  # completes to \"recursivist\"\n</code></pre> <ol> <li>Type a command and press <code>Tab</code> to see available subcommands:</li> </ol> <pre><code>recursivist [Tab]  # shows visualize, export, compare, etc.\n</code></pre> <ol> <li>Type a subcommand and press <code>Tab</code> to see available options:</li> </ol> <pre><code>recursivist visualize --[Tab]  # shows --exclude, --depth, etc.\n</code></pre> <ol> <li>Type a path argument and press <code>Tab</code> to complete the path:    <pre><code>recursivist visualize ~/pro[Tab]  # completes to \"~/projects/\"\n</code></pre></li> </ol>"},{"location":"user-guide/shell-completion/#completion-features","title":"Completion Features","text":"<p>Recursivist's completion system provides:</p> <ul> <li>Command and subcommand completion</li> <li>Option name completion (both long and short forms)</li> <li>Option value completion for some options</li> <li>File and directory path completion</li> <li>Contextual help for available options</li> </ul>"},{"location":"user-guide/shell-completion/#troubleshooting","title":"Troubleshooting","text":"<p>If shell completion isn't working:</p> <ol> <li>Make sure you've sourced the completion script correctly</li> <li>Verify that your shell's completion system is enabled</li> <li>Try restarting your shell session</li> <li>Check for error messages when loading the completion script</li> </ol>"},{"location":"user-guide/shell-completion/#common-issues","title":"Common Issues","text":""},{"location":"user-guide/shell-completion/#permission-denied","title":"Permission Denied","text":"<p>If you get a \"permission denied\" error when generating the completion script:</p> <pre><code># Make sure you have write permission to the target directory\nchmod +w ~/.bash_completion.d\n\n# Or use sudo to generate the script (system-wide)\nsudo recursivist completion bash &gt; /etc/bash_completion.d/recursivist\n</code></pre>"},{"location":"user-guide/shell-completion/#completion-not-working","title":"Completion Not Working","text":"<p>If completion doesn't work even after setting up:</p> <pre><code># Make sure the script is executable\nchmod +x ~/.bash_completion.d/recursivist\n\n# Try sourcing it explicitly\nsource ~/.bash_completion.d/recursivist\n\n# Check for errors in the script\ncat ~/.bash_completion.d/recursivist\n</code></pre>"},{"location":"user-guide/shell-completion/#zsh-insecure-directories-warning","title":"Zsh Insecure Directories Warning","text":"<p>If you see a warning about insecure directories in Zsh:</p> <pre><code># Fix directory permissions\nchmod 755 ~/.zsh\nchmod 755 ~/.zsh/completion\n</code></pre>"},{"location":"user-guide/shell-completion/#system-wide-installation","title":"System-Wide Installation","text":"<p>For system-wide installation (requires admin privileges):</p>"},{"location":"user-guide/shell-completion/#bash-ubuntudebian","title":"Bash (Ubuntu/Debian)","text":"<pre><code>sudo recursivist completion bash &gt; /etc/bash_completion.d/recursivist\n</code></pre>"},{"location":"user-guide/shell-completion/#bash-rhelcentosfedora","title":"Bash (RHEL/CentOS/Fedora)","text":"<pre><code>sudo recursivist completion bash &gt; /etc/bash_completion.d/recursivist\n</code></pre>"},{"location":"user-guide/shell-completion/#zsh_1","title":"Zsh","text":"<pre><code>sudo recursivist completion zsh &gt; /usr/local/share/zsh/site-functions/_recursivist\n</code></pre>"},{"location":"user-guide/shell-completion/#fish_1","title":"Fish","text":"<pre><code>sudo recursivist completion fish &gt; /usr/share/fish/vendor_completions.d/recursivist.fish\n</code></pre>"},{"location":"user-guide/shell-completion/#command-completion-options","title":"Command Completion Options","text":"<p>The tab completion for Recursivist is particularly helpful for:</p>"},{"location":"user-guide/shell-completion/#complex-options","title":"Complex Options","text":"<pre><code># Tab completion suggests available options\nrecursivist visualize --sort-by-[Tab]\n# Shows: --sort-by-loc --sort-by-size --sort-by-mtime\n</code></pre>"},{"location":"user-guide/shell-completion/#format-selection","title":"Format Selection","text":"<pre><code># Tab completion suggests available formats\nrecursivist export --format [Tab]\n# Shows: txt json html md jsx\n</code></pre>"},{"location":"user-guide/shell-completion/#shell-selection","title":"Shell Selection","text":"<pre><code># Tab completion suggests available shells\nrecursivist completion [Tab]\n# Shows: bash zsh fish powershell\n</code></pre> <p>This makes it much easier to use Recursivist's more advanced features without needing to remember all the available options.</p>"},{"location":"user-guide/visualization/","title":"Visualization","text":"<p>The <code>visualize</code> command is the primary way to display directory structures in the terminal with Recursivist. This guide explains how to use it effectively and customize the output.</p>"},{"location":"user-guide/visualization/#basic-visualization","title":"Basic Visualization","text":"<p>To visualize the current directory structure:</p> <pre><code>recursivist visualize\n</code></pre> <p>For a specific directory:</p> <pre><code>recursivist visualize /path/to/directory\n</code></pre>"},{"location":"user-guide/visualization/#customizing-the-visualization","title":"Customizing the Visualization","text":""},{"location":"user-guide/visualization/#color-coding","title":"Color Coding","text":"<p>By default, Recursivist color-codes files based on their extensions. Each file extension gets a unique color, generated deterministically to ensure consistent visualization:</p> <ul> <li>The same extension always gets the same color in all visualizations</li> <li>Colors are generated to be visually distinct between different file types</li> <li>The color scheme provides good contrast for readability</li> </ul>"},{"location":"user-guide/visualization/#file-statistics","title":"File Statistics","text":"<p>Recursivist can display and sort by various file statistics:</p>"},{"location":"user-guide/visualization/#lines-of-code","title":"Lines of Code","text":"<p>Calculate and display the number of lines in each file and total lines per directory:</p> <pre><code>recursivist visualize --sort-by-loc\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (4328 lines)\n\u251c\u2500\u2500 \ud83d\udcc1 src (3851 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (245 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (157 lines)\n...\n</code></pre>"},{"location":"user-guide/visualization/#file-sizes","title":"File Sizes","text":"<p>Display file sizes with appropriate units (B, KB, MB, GB):</p> <pre><code>recursivist visualize --sort-by-size\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (1.2 MB)\n\u251c\u2500\u2500 \ud83d\udcc1 src (850.5 KB)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (12.4 KB)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (8.2 KB)\n...\n</code></pre>"},{"location":"user-guide/visualization/#modification-times","title":"Modification Times","text":"<p>Show when files were last modified with smart formatting:</p> <pre><code>recursivist visualize --sort-by-mtime\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (Today 14:30)\n\u251c\u2500\u2500 \ud83d\udcc1 src (Today 14:25)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (Today 14:25)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (Yesterday 18:10)\n...\n</code></pre>"},{"location":"user-guide/visualization/#combining-statistics","title":"Combining Statistics","text":"<p>You can combine multiple statistics in a single view:</p> <pre><code>recursivist visualize --sort-by-loc --sort-by-size --sort-by-mtime\n</code></pre> <p>Output:</p> <pre><code>\ud83d\udcc2 my-project (4328 lines, 1.2 MB, Today 14:30)\n\u251c\u2500\u2500 \ud83d\udcc1 src (3851 lines, 850.5 KB, Today 14:25)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (245 lines, 12.4 KB, Today 14:25)\n...\n</code></pre>"},{"location":"user-guide/visualization/#directory-depth-control","title":"Directory Depth Control","text":"<p>For large projects, it can be helpful to limit the directory depth:</p> <pre><code>recursivist visualize --depth 2\n</code></pre> <p>This will display only the top two levels of the directory structure, with indicators showing where the depth limit was reached:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests\n\u2502       \u22ef (max depth reached)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md\n...\n</code></pre>"},{"location":"user-guide/visualization/#full-path-display","title":"Full Path Display","text":"<p>By default, Recursivist shows only filenames. For a view with full paths:</p> <pre><code>recursivist visualize --full-path\n</code></pre> <p>Example:</p> <pre><code>\ud83d\udcc2 project\n\u251c\u2500\u2500 \ud83d\udcc4 /home/user/project/README.md\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 /home/user/project/src/main.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 /home/user/project/src/utils.py\n</code></pre>"},{"location":"user-guide/visualization/#filtering-the-visualization","title":"Filtering the Visualization","text":""},{"location":"user-guide/visualization/#excluding-directories","title":"Excluding Directories","text":"<p>To exclude specific directories:</p> <pre><code>recursivist visualize --exclude \"node_modules .git\"\n</code></pre>"},{"location":"user-guide/visualization/#excluding-file-extensions","title":"Excluding File Extensions","text":"<p>To exclude files with specific extensions:</p> <pre><code>recursivist visualize --exclude-ext \".pyc .log\"\n</code></pre>"},{"location":"user-guide/visualization/#pattern-based-filtering","title":"Pattern-Based Filtering","text":"<p>For more precise control, you can use patterns:</p> <pre><code># Exclude with glob patterns (default)\nrecursivist visualize --exclude-pattern \"*.test.js\" \"*.spec.js\"\n\n# Exclude with regex patterns\nrecursivist visualize --exclude-pattern \"^test_.*\\.py$\" --regex\n\n# Include only specific patterns (overrides exclusions)\nrecursivist visualize --include-pattern \"src/*\" \"*.md\"\n</code></pre> <p>See the Pattern Filtering guide for more details.</p>"},{"location":"user-guide/visualization/#using-gitignore-files","title":"Using Gitignore Files","text":"<p>If you have a <code>.gitignore</code> file, you can use it to filter the directory structure:</p> <pre><code>recursivist visualize --ignore-file .gitignore\n</code></pre> <p>You can also specify a different ignore file:</p> <pre><code>recursivist visualize --ignore-file .recursivist-ignore\n</code></pre>"},{"location":"user-guide/visualization/#output-example","title":"Output Example","text":"<p>The visualization output looks like this:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py\n\u251c\u2500\u2500 \ud83d\udcc4 README.md\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py\n</code></pre> <p>With depth limits, you might see:</p> <pre><code>\ud83d\udcc2 my-project\n\u251c\u2500\u2500 \ud83d\udcc1 src\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests\n\u2502       \u22ef (max depth reached)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py\n</code></pre> <p>With file statistics enabled:</p> <pre><code>\ud83d\udcc2 my-project (4328 lines)\n\u251c\u2500\u2500 \ud83d\udcc1 src (3851 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 main.py (245 lines)\n\u2502   \u251c\u2500\u2500 \ud83d\udcc4 utils.py (157 lines)\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 tests (653 lines)\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 test_main.py (412 lines)\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 test_utils.py (241 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 README.md (124 lines)\n\u251c\u2500\u2500 \ud83d\udcc4 requirements.txt (18 lines)\n\u2514\u2500\u2500 \ud83d\udcc4 setup.py (65 lines)\n</code></pre>"},{"location":"user-guide/visualization/#verbose-mode","title":"Verbose Mode","text":"<p>For detailed information about the visualization process:</p> <pre><code>recursivist visualize --verbose\n</code></pre> <p>This is useful for debugging or understanding how patterns are applied.</p>"},{"location":"user-guide/visualization/#terminal-compatibility","title":"Terminal Compatibility","text":"<p>Recursivist works in most modern terminals with:</p> <ul> <li>Unicode support for special characters (\ud83d\udcc1, \ud83d\udcc4, etc.)</li> <li>ANSI color support</li> </ul> <p>If your terminal doesn't support these features, you might see different characters or no colors.</p>"},{"location":"user-guide/visualization/#performance-tips","title":"Performance Tips","text":"<p>For large directories:</p> <ol> <li>Use the <code>--depth</code> option to limit the directory depth</li> <li>Exclude large directories you don't need with <code>--exclude</code></li> <li>Use pattern matching to focus on specific parts of the directory tree</li> <li>Avoid using <code>--sort-by-loc</code> for very large repositories as line counting can be time-consuming</li> </ol>"},{"location":"user-guide/visualization/#related-commands","title":"Related Commands","text":"<ul> <li>Export: Save directory structures to various formats</li> <li>Compare: Compare two directory structures side by side</li> </ul> <p>For complete command options, see the CLI Reference.</p>"}]}